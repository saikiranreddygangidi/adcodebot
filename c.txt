 C Program to Check if a given Integer is Odd or Even 
================================ EOPN
#include <stdio.h> void main(){    int ival, remainder;     printf("Enter an integer : ");    scanf("%d", &ival);    remainder = ival % 2;    if (remainder == 0)        printf("%d is an even integer\n", ival);    else        printf("%d is an odd integer\n", ival);}
================================ EOKW
--------------------------------
output:
 
Case 1:
Enter an integer : 24
24 is an even integer
 
Case 2:
Enter an integer : 75
75 is an odd integer
 
Case 3:
Enter an integer : 0
0 is an even integer
--------------------------------
 ETP 
 
 C Program to Calculate the Sum of Odd & Even Numbers 
================================ EOPN
 #include <stdio.h> void main(){    int i, num, odd_sum = 0, even_sum = 0;     printf("Enter the value of num\n");    scanf("%d", &num);    for (i = 1; i <= num; i++)    {        if (i % 2 == 0)            even_sum = even_sum + i;        else            odd_sum = odd_sum + i;    }    printf("Sum of all odd numbers  = %d\n", odd_sum);    printf("Sum of all even numbers = %d\n", even_sum);}
================================ EOKW
--------------------------------
output:
Case 1:
Enter the value of num
10
Sum of all odd numbers  = 25
Sum of all even numbers = 30
 
Case 2:
Enter the value of num
100
Sum of all odd numbers  = 2500
Sum of all even numbers = 2550
--------------------------------
 ETP 
 
 C Program to Check if a given Integer is Positive or Negative 
================================ EOPN
#include <stdio.h> void main(){    int number;     printf("Enter a number \n");    scanf("%d", &number);    if (number >= 0)        printf("%d is a positive number \n", number);    else        printf("%d is a negative number \n", number);}
================================ EOKW
--------------------------------
output:
Case:1
Enter a number
-10
-10 is a negative number
 
Case:2
Enter a number
45
45 is a positive number
--------------------------------
 ETP 
 
 C Program to Find the Number of Integers Divisible by 5  
================================ EOPN
/* * C program to find the number of integers divisible by  * 5 between the given range num1 and num2, where num1 < num2. * * Also find the sum of all these integer numbers which are divisible * by 5 and display the total. 
================================ EOKW
--------------------------------
output:
Case:1
Enter the value of num1 and num2
12 17
Integers divisible by 5 are
 15,
Number of integers divisible by 5 between 12 and 17 = 1
Sum of all integers that are divisible by 5 = 15
 
Case:2
Enter the value of num1 and num2
1 10
Integers divisible by 5 are
 5,10
Number of integers divisible by 5 between 1 and 10 = 2
Sum of all integers that are divisible by 5 = 15
--------------------------------
#include <stdio.h>

void main()
{
int i, num1, num2, count = 0, sum = 0;

printf("Enter the value of num1 and num2 \n");
scanf("%d %d", &num1, &num2);
/* Count the number and compute their sum*/
printf("Integers divisible by 5 are \n");
for (i = num1; i < num2; i++)
{
if (i % 5 == 0)
{
printf("%3d,", i);
count++;
sum = sum + i;
}
}
printf("\n Number of integers divisible by 5 between %d and %d =
%d\n", num1, num2, count);
printf("Sum of all integers that are divisible by 5 = %d\n", sum);
}
 ETP 
 
 C Program to Read Two Integers M and N & Swap their Values 
================================ EOPN
/* * C program to read two integers M and N and to swap their values. * Use a user-defined function for swapping. Output the values of M * and N before and after swapping. 
================================ EOKW
--------------------------------
output:
Enter the values of M and N
2 3
Before Swapping:M =  2.00    N =  3.00
After Swapping:M  =  3.00    N =  2.00
--------------------------------
#include <stdio.h>
void swap(float *ptr1, float  *ptr2);

void main()
{
float m, n;

printf("Enter the values of M and N \n");
scanf("%f %f", &m, &n);
printf("Before Swapping:M = %5.2ftN = %5.2f\n", m, n);
swap(&m, &n);
printf("After Swapping:M  = %5.2ftN = %5.2f\n", m, n);
}
/*  Function swap - to interchanges the contents of two items */
void swap(float *ptr1, float *ptr2)
{
float temp;

temp = *ptr1;
*ptr1 = *ptr2;
*ptr2 = temp;
}
 ETP 
 
 C Program to Accept two Integers and Check if they are Equal 
================================ EOPN
/* * C program to accept two integers and check if they are equal 
================================ EOKW
--------------------------------
output:
Case:1
Enter the values for M and N
3 3
M and N are equal
 
Case:2
Enter the values for M and N
5 8
M and N are not equal
--------------------------------
#include <stdio.h>
void main()
{
int m, n;

printf("Enter the values for M and N\n");
scanf("%d %d", &m, &n);
if (m == n)
printf("M and N are equal\n");
else
printf("M and N are not equal\n");
}
 ETP 
 
 C Program to Compute the Sum of Digits in a given Integer 
================================ EOPN
/* * C program to accept an integer & find the sum of its digits 
================================ EOKW
--------------------------------
output:
Enter the number
300
Given number = 300
Sum of the digits 300 = 3
 
 
Enter the number
16789
Given number = 16789
Sum of the digits 16789 = 31
--------------------------------
#include <stdio.h>

void main()
{
long num, temp, digit, sum = 0;

printf("Enter the number \n");
scanf("%ld", &num);
temp = num;
while (num > 0)
{
digit = num % 10;
sum  = sum + digit;
num /= 10;
}
printf("Given number = %ld\n", temp);
printf("Sum of the digits %ld = %ld\n", temp, sum);
}
 ETP 
 
 C Program to Convert the given Binary Number into Decimal 
================================ EOPN
/* * C program to convert the given binary number into decimal 
================================ EOKW
--------------------------------
output:
 
Enter a binary number(1s and 0s)
10101001
The Binary number is = 10101001
Its decimal equivalent is = 169
--------------------------------
#include <stdio.h>

void main()
{
int  num, binary_val, decimal_val = 0, base = 1, rem;

printf("Enter a binary number(1s and 0s) \n");
scanf("%d", &num); /* maximum five digits */
binary_val = num;
while (num > 0)
{
rem = num % 10;
decimal_val = decimal_val + rem * base;
num = num / 10 ;
base = base * 2;
}
printf("The Binary number is = %d \n", binary_val);
printf("Its decimal equivalent is = %d \n", decimal_val);
}
 ETP 
 
 C Program to Convert a Decimal Number to Binary & Count the Number of 1s 
================================ EOPN
/*
 * C program to accept a decimal number and convert it to binary
 * and count the number of 1's in the binary number
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm46.c
$ a.out
Enter a decimal integer
134
Input number is = 134
Its binary equivalent is = 10000110
No.of 1's in the binary number is = 3
--------------------------------

#include <stdio.h>
 
void main()
{
    long num, decimal_num, remainder, base = 1, binary = 0, no_of_1s = 0;
 
    printf("Enter a decimal integer \n");
    scanf("%ld", &num);
    decimal_num = num;
    while (num > 0)
    {
        remainder = num % 2;
        /*  To count no.of 1s 
 ETP 
 
 C Program to Convert a Given Number of Days in terms of Years, Weeks & Days 
================================ EOPN
/* * C program to convert given number of days to a measure of time given * in years, weeks and days. For example 375 days is equal to 1 year * 1 week and 3 days (ignore leap year) 
================================ EOKW
--------------------------------
output:
Case:1
Enter the number of days
29
29 is equivalent to 0 years, 4 weeks and 1 days
 
Case:2
Enter the number of days
1000
1000 is equivalent to 2 years, 38 weeks and 4 days
--------------------------------
#include <stdio.h>
#define DAYSINWEEK 7

void main()
{
int ndays, year, week, days;

printf("Enter the number of days\n");
scanf("%d", &ndays);
year = ndays / 365;
week =(ndays % 365) / DAYSINWEEK;
days =(ndays % 365) % DAYSINWEEK;
printf ("%d is equivalent to %d years, %d weeks and %d daysn",
ndays, year, week, days);
}
 ETP 
 
C Program to Convert Binary to Octal
================================ EOPN
/* * C Program to Convert Binary to Octal 
================================ EOKW
--------------------------------
output:
Output:
 
Enter the value for  binary number: 10101
Equivalent octal value: 25
--------------------------------
#include <stdio.h>

int main()
{
long int binarynum, octalnum = 0, j = 1, remainder;

printf("Enter the value for  binary number: ");
scanf("%ld", &binarynum);
while (binarynum != 0)
{
remainder = binarynum % 10;
octalnum = octalnum + remainder * j;
j = j * 2;
binarynum = binarynum / 10;
}
printf("Equivalent octal value: %lo", octalnum);
return 0;
}
 ETP 
 
C Program to Convert Binary to Hexadecimal
================================ EOPN
/* * C Program to Convert Binary to Hexadecimal  
================================ EOKW
--------------------------------
output:
Output:
Enter the binary number: 10000
Equivalent hexadecimal value: 10
--------------------------------
#include <stdio.h>

int main()
{
long int binaryval, hexadecimalval = 0, i = 1, remainder;

printf("Enter the binary number: ");
scanf("%ld", &binaryval);
while (binaryval != 0)
{
remainder = binaryval % 10;
hexadecimalval = hexadecimalval + remainder * i;
i = i * 2;
binaryval = binaryval / 10;
}
printf("Equivalent hexadecimal value: %lX", hexadecimalval);
return 0;
}
 ETP 
 
C Program to Convert Decimal to Octal 
================================ EOPN
/* * C program to Convert Decimal to Octal 
================================ EOKW
--------------------------------
output:
Output:
Enter the decimal number: 68
Equivalent octal value of decimal no 68: 104
--------------------------------
#include <stdio.h>

int main()
{
long decimalnum, remainder, quotient;
int octalNumber[100], i = 1, j;

printf("Enter the decimal number: ");
scanf("%ld", &decimalnum);
quotient = decimalnum;
while (quotient != 0)
{
octalNumber[i++] = quotient % 8;
quotient = quotient / 8;
}
printf("Equivalent octal value of decimal no %d: ", decimalnum);
for (j = i - 1; j > 0; j--)
printf("%d", octalNumber[j]);
return 0;
}
 ETP 
 
C program to Convert Decimal to Hexadecimal
================================ EOPN
/* * C program to Convert Decimal to Hexadecimal 
================================ EOKW
--------------------------------
output:
Output:
 
Enter decimal number: 12
Equivalent hexadecimal value of 12 : C
--------------------------------
#include <stdio.h>

int main()
{
long decimalnum, quotient, remainder;
int i, j = 0;
char hexadecimalnum[100];

printf("Enter decimal number: ");
scanf("%ld", &decimalnum);

quotient = decimalnum;

while (quotient != 0)
{
remainder = quotient % 16;
if (remainder < 10)
hexadecimalnum[j++] = 48 + remainder;
else
hexadecimalnum[j++] = 55 + remainder;
quotient = quotient / 16;
}

// display integer into character
for (i = j; i >= 0; i--)
printf("%c", hexadecimalnum[i]);
return 0;
}
 ETP 
 
C Program to Convert Roman Number to Decimal Number
================================ EOPN
/
================================ EOKW
--------------------------------
output:
Output:
Enter any roman number (Valid digits are I, V, X, L, C, D, M):
XVII
Its decimal value is: 17
--------------------------------

#include<stdio.h>
#include<string.h>

int digit(char);

int main(){

char roman_Number[1000];
int i=0;
long int number =0;

printf("Enter any roman number (Valid digits are I, V, X, L, C, D, M):  \n");
scanf("%s",roman_Number);

while(roman_Number[i]){

if(digit(roman_Number[i]) < 0){
printf("Invalid roman digit : %c",roman_Number[i]);
return 0;
}

if((strlen(roman_Number) -i) > 2){
if(digit(roman_Number[i]) < digit(roman_Number[i+2])){
printf("Invalid roman number");
return 0;
}
}

if(digit(roman_Number[i]) >= digit(roman_Number[i+1]))
number = number + digit(roman_Number[i]);
else{
number = number + (digit(roman_Number[i+1]) - digit(roman_Number[i]));
i++;
}
i++;
}

printf("Its decimal value is : %ld",number);

return 0;

}

int digit(char c){

int value=0;

switch(c){
case 'I': value = 1; break;
case 'V': value = 5; break;
case 'X': value = 10; break;
case 'L': value = 50; break;
case 'C': value = 100; break;
case 'D': value = 500; break;
case 'M': value = 1000; break;
case '\0': value = 0; break;
default: value = -1;
}

return value;
}
 ETP 
 
C Program to Convert Octal to Binary
================================ EOPN
/* * C Program to Convert Octal to Binary 
================================ EOKW
--------------------------------
output:
Output:
 
Enter any octal number: a
Equivalent binary value:
Invalid octal digit a
 
 
Enter any octal number: 160
Equivalent binary value: 001110000
--------------------------------
#include <stdio.h>
#define MAX 1000

int main()
{
char octalnum[MAX];
long i = 0;

printf("Enter any octal number: ");
scanf("%s", octalnum);
printf("Equivalent binary value: ");
while (octalnum[i])
{
switch (octalnum[i])
{
case '0':
printf("000"); break;
case '1':
printf("001"); break;
case '2':
printf("010"); break;
case '3':
printf("011"); break;
case '4':
printf("100"); break;
case '5':
printf("101"); break;
case '6':
printf("110"); break;
case '7':
printf("111"); break;
default:
printf("\n Invalid octal digit %c ", octalnum[i]);
return 0;
}
i++;
}
return 0;
}
 ETP 
 
C Program to Convert Hexadecimal to Binary
================================ EOPN
/* * C Program to Convert Hexadecimal to Binary 
================================ EOKW
--------------------------------
output:
Output:
 
Enter the value for hexadecimal ab
Equivalent binary value: 10101011
--------------------------------
#include <stdio.h>
#define MAX 1000

int main()
{
char binarynum[MAX], hexa[MAX];
long int i = 0;

printf("Enter the value for hexadecimal ");
scanf("%s", hexa);
printf("\n Equivalent binary value: ");
while (hexa[i])
{
switch (hexa[i])
{
case '0':
printf("0000"); break;
case '1':
printf("0001"); break;
case '2':
printf("0010"); break;
case '3':
printf("0011"); break;
case '4':
printf("0100"); break;
case '5':
printf("0101"); break;
case '6':
printf("0110"); break;
case '7':
printf("0111"); break;
case '8':
printf("1000"); break;
case '9':
printf("1001"); break;
case 'A':
printf("1010"); break;
case 'B':
printf("1011"); break;
case 'C':
printf("1100"); break;
case 'D':
printf("1101"); break;
case 'E':
printf("1110"); break;
case 'F':
printf("1111"); break;
case 'a':
printf("1010"); break;
case 'b':
printf("1011"); break;
case 'c':
printf("1100"); break;
case 'd':
printf("1101"); break;
case 'e':
printf("1110"); break;
case 'f':
printf("1111"); break;
default:
printf("\n Invalid hexa digit %c ", hexa[i]);
return 0;
}
i++;
}
return 0;
}
 ETP 
 
C Program to Convert Numbers to Roman Numerals
================================ EOPN
/* * C Program to Convert Numbers to Roman Numerals 
================================ EOKW
--------------------------------
output:
Output:
 
Enter the number: 500
Roman number is be: D
--------------------------------
#include <stdio.h>

void predigit(char num1, char num2);
void postdigit(char c, int n);

char romanval[1000];
int i = 0;
int main()
{
int j;
long number;

printf("Enter the number: ");
scanf("%d", &number);
if (number <= 0)
{
printf("Invalid number");
return 0;
}
while (number != 0)
{
if (number >= 1000)
{
postdigit('M', number / 1000);
number = number - (number / 1000) * 1000;
}
else if (number >= 500)
{
if (number < (500 + 4 * 100))
{
postdigit('D', number / 500);
number = number - (number / 500) * 500;
}
else
{
predigit('C','M');
number = number - (1000-100);
}
}
else if (number >= 100)
{
if (number < (100 + 3 * 100))
{
postdigit('C', number / 100);
number = number - (number / 100) * 100;
}
else
{
predigit('L', 'D');
number = number - (500 - 100);
}
}
else if (number >= 50 )
{
if (number < (50 + 4 * 10))
{
postdigit('L', number / 50);
number = number - (number / 50) * 50;
}
else
{
predigit('X','C');
number = number - (100-10);
}
}
else if (number >= 10)
{
if (number < (10 + 3 * 10))
{
postdigit('X', number / 10);
number = number - (number / 10) * 10;
}
else
{
predigit('X','L');
number = number - (50 - 10);
}
}
else if (number >= 5)
{
if (number < (5 + 4 * 1))
{
postdigit('V', number / 5);
number = number - (number / 5) * 5;
}
else
{
predigit('I', 'X');
number = number - (10 - 1);
}
}
else if (number >= 1)
{
if (number < 4)
{
postdigit('I', number / 1);
number = number - (number / 1) * 1;
}
else
{
predigit('I', 'V');
number = number - (5 - 1);
}
}
}
printf("Roman number is: ");
for(j = 0; j < i; j++)
printf("%c", romanval[j]);
return 0;
}

void predigit(char num1, char num2)
{
romanval[i++] = num1;
romanval[i++] = num2;
}

void postdigit(char c, int n)
{
int j;
for (j = 0; j < n; j++)
romanval[i++] = c;
}
 ETP 
 
C Program to Convert Octal to Decimal 
================================ EOPN
/* * C Program to Convert Octal to Decimal 
================================ EOKW
--------------------------------
output:
Output:
 
Enter any octal number: 67
Equivalent decimal value: 55
--------------------------------
#include <stdio.h>
#include <math.h>

int main()
{

long int octal, decimal = 0;
int i = 0;

printf("Enter any octal number: ");
scanf("%ld", &octal);
while (octal != 0)
{
decimal =  decimal +(octal % 10)* pow(8, i++);
octal = octal / 10;
}
printf("Equivalent decimal value: %ld",decimal);
return 0;
}
 ETP 
 
C Program to Convert a Number Decimal System to Binary System using Recursion
================================ EOPN
/*  
 * C Program to Convert a Number Decimal System to Binary System using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm31.c
$ a.out
Enter a decimal number: 10
The binary equivalent of 10 is 1010.
--------------------------------

#include <stdio.h>
 
int convert(int);
 
int main()
{
    int dec, bin;
 
    printf("Enter a decimal number: ");
    scanf("%d", &dec);
    bin = convert(dec);
    printf("The binary equivalent of %d is %d.\n", dec, bin);
 
    return 0;
}
 
int convert(int dec)
{
    if (dec == 0)
    {
        return 0;
    }
    else
    {
        return (dec % 2 + 10 * convert(dec / 2));
    }
}
 ETP 
 
C Program to Convert Binary Code of a Number into its Equivalent Gray’s Code without using Recursion
================================ EOPN
/*  
 * C Program to Convert Binary Code of a Number into its Equivalent 
 * Gray's Code without using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm26.c -lm
$ a.out
Enter a binary number: 1111001010
The gray code of 1111001010 is 1000101111
--------------------------------

#include <stdio.h>
#include <math.h>
 
int bintogray(int);
 
int main ()
{
    int bin, gray;
 
    printf("Enter a binary number: ");
    scanf("%d", &bin);
    gray = bintogray(bin);
    printf("The gray code of %d is %d\n", bin, gray);
    return 0;
}
 
int bintogray(int bin)
{
    int a, b, result = 0, i = 0;
 
    while (bin != 0)
    {
        a = bin % 10;
        bin = bin / 10;
        b = bin % 10;
        if ((a && !b) || (!a && b))
        {
            result = result + pow(10, i);
        }
        i++;
    }
    return result;
}
 ETP 
 
C Program to Convert Binary Code of a Number into its Equivalent Gray’s Code using Recursion
================================ EOPN
/* 
 * C Program to Convert Binary Code of a Number into its Equivalent 
 * Gray's Code using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm21.c
$ a.out
Enter a binary number:  1011101
The gray code of 1011101 is 1110011
--------------------------------

#include <stdio.h>
 
int bintogray(int);
 
int main ()
{
    int bin, gray;
 
    printf("Enter a binary number: ");
    scanf("%d", &bin);
    gray = bintogray(bin);
    printf("The gray code of %d is %d\n", bin, gray);
    return 0;
}
 
int bintogray(int bin)
{
    int a, b, result = 0, i = 0;
 
    if (!bin)
    {
        return 0;
    }
    else
    {
        a = bin % 10;
        bin = bin / 10;
        b = bin % 10;
        if ((a && !b) || (!a && b))
        {
            return (1 + 10 * bintogray(bin));
        }
        else
        {
            return (10 * bintogray(bin));
        }
    }
}
 ETP 
 
C Program to find Sum of Digits of a Number using Recursion
================================ EOPN
/*  
 * C Program to find Sum of Digits of a Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm25.c
$ a.out
Enter the number: 2345
Sum of digits in 2345 is 14
--------------------------------

#include <stdio.h>
 
int sum (int a);
 
int main()
{
    int num, result;
 
    printf("Enter the number: ");
    scanf("%d", &num);
    result = sum(num);
    printf("Sum of digits in %d is %d\n", num, result);
    return 0;
}
 
int sum (int num)
{
    if (num != 0)
    {
        return (num % 10 + sum (num / 10));
    }
    else
    {
       return 0;
    }
}
 ETP 
 
C Program to find Reverse of a Number using Recursion
================================ EOPN
/*  
 * C program to find the reverse of a number using recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm34.c
$ a.out
Enter an integer number to reverse: 1234
The reverse of 1234 is 4321.
--------------------------------

#include <stdio.h>
#include <math.h>
 
int rev(int, int);
 
int main()
{
    int num, result;
    int length = 0, temp;
 
    printf("Enter an integer number to reverse: ");
    scanf("%d", &num);
    temp = num;
    while (temp != 0)
    {
        length++;
        temp = temp / 10;
    }
    result = rev(num, length);
    printf("The reverse of %d is %d.\n", num, result);
    return 0;
}
 
int rev(int num, int len)
{
    if (len == 1)
    {
        return num;
    }
    else
    {
        return (((num % 10) * pow(10, len - 1)) + rev(num / 10, --len));
    }
}
 ETP 
 
C Program to find Sum of N Numbers using Recursion
================================ EOPN
/*  
 * C Program to find Sum of N Numbers using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm33.c
$ a.out
Enter the Nth number: 3
Sum of first N numbers is 6
 
$ a.out
Enter the Nth number: 5
Sum of first N numbers is 15
--------------------------------

#include <stdio.h>
 
void display_sum(int);
 
int main()
{
    int num;
 
    printf("Enter the Nth number: ");
    scanf("%d", &num);
    display_sum(num);
    return 0;
}
 
void display_sum(int num)
{
    static int sum = 0;
 
    if (num == 0)
    {
        printf("Sum of first N numbers is %d\n", sum);
        return;
    }
    else
    {
        sum += num;
        display_sum(--num);
    }
}
 ETP 
 
C Program to find whether a Number is Prime or Not using Recursion
================================ EOPN
/*
 * C Program to find whether a Number is Prime or Not using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm24.c
$ a.out
Enter a number: 456
456 is not a prime number
 
$ a.out
Enter a number: 89
89 is a prime number
--------------------------------

#include <stdio.h>
 
int primeno(int, int);
 
int main()
{
    int num, check;
    printf("Enter a number: ");
    scanf("%d", &num);
    check = primeno(num, num / 2);
    if (check == 1)
    {
        printf("%d is a prime number\n", num);
    }
    else
    {
        printf("%d is not a prime number\n", num);
    }
    return 0;
}
 
int primeno(int num, int i)
{
    if (i == 1)
    {
        return 1;
    }
    else
    {
       if (num % i == 0)
       {
         return 0;
       }
       else
       {
         return primeno(num, i - 1);
       }       
    }
}
 ETP 
 
C Program to Print Binary Equivalent of an Integer using Recursion
================================ EOPN
/*  
 * C Program to Print Binary Equivalent of an Integer using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ gcc binary_recr.c -o binary_recr
$ a.out
Enter a decimal number: 10
The binary equivalent of 10 is 1010
--------------------------------

#include <stdio.h>
 
int binary_conversion(int);
 
int main()
{
   int num, bin;
 
   printf("Enter a decimal number: ");
   scanf("%d", &num);
   bin = binary_conversion(num);
   printf("The binary equivalent of %d is %d\n", num, bin);
}
 
int binary_conversion(int num)
{
    if (num == 0)
    {
        return 0;
    }
    else
    {
        return (num % 2) + 10 * binary_conversion(num / 2);
    }
}
 ETP 
 
C Program to find Product of 2 Numbers using Recursion
================================ EOPN
/*  
 * C Program to find Product of 2 Numbers using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm20.c
$ a.out
Enter two numbers to find their product: 176 340
Product of 176 and 340 is 59840
--------------------------------

#include <stdio.h>
 
int product(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter two numbers to find their product: ");
    scanf("%d%d", &a, &b);
    result = product(a, b);
    printf("Product of %d and %d is %d\n", a, b, result);
    return 0;
}
 
int product(int a, int b)
{
    if (a < b)
    {
        return product(b, a);
    }
    else if (b != 0)
    {
        return (a + product(a, b - 1));
    }
    else
    {
        return 0;
    }
}
 ETP 
 
 C Program to Find the Biggest of 3 Numbers 
================================ EOPN
/* * C program to find the biggest of three numbers 
================================ EOKW
--------------------------------
output:
Case:1
Enter the values of num1, num2 and num3
6 8 10
num1 = 6  num2 = 8  num3 = 10
num3 is the greatest among three
 
Case:2
Enter the values of num1, num2 and num3
10 87 99
num1 = 10  num2 = 87  num3 = 99
num3 is the greatest among three
--------------------------------
#include <stdio.h>

void main()
{
int num1, num2, num3;

printf("Enter the values of num1, num2 and num3\n");
scanf("%d %d %d", &num1, &num2, &num3);
printf("num1 = %d\tnum2 = %d\tnum3 = %d\n", num1, num2, num3);
if (num1 > num2)
{
if (num1 > num3)
{
printf("num1 is the greatest among three \n");
}
else
{
printf("num3 is the greatest among three \n");
}
}
else if (num2 > num3)
printf("num2 is the greatest among three \n");
else
printf("num3 is the greatest among three \n");
}
 ETP 
 
 C Program to Reverse a Given Number 
================================ EOPN
 #include <stdio.h> void main(){    long  num, reverse = 0, temp, remainder;     printf("Enter the number\n");    scanf("%ld", &num);    temp = num;    while (num > 0)    {        remainder = num % 10;        reverse = reverse * 10 + remainder;        num /= 10;    }    printf("Given number = %ld\n", temp);    printf("Its reverse is = %ld\n", reverse);}
================================ EOKW
--------------------------------
output:
Case:1
Enter the number
567865
Given number   = 567865
Its reverse is = 568765
 
Case:2
Enter the number
00001
Given number   = 00001
Its reverse is = 10000
--------------------------------
 ETP 
 
 C Program to Reverse a Number & Check if it is a Palindrome 
================================ EOPN
  #include <stdio.h> void main(){    int num, temp, remainder, reverse = 0;     printf("Enter an integer \n");    scanf("%d", &num);    /*  original number is stored at temp 
================================ EOKW
--------------------------------
output:
Case:1
Enter an integer
6789
Given number is = 6789
Its reverse is  = 9876
Number is not a palindrome
 
Case:2
Enter an integer
58085
Given number is = 58085
Its reverse is  = 58085
Number is a palindrome
--------------------------------
temp = num;
while (num > 0)
{
remainder = num % 10;
reverse = reverse * 10 + remainder;
num /= 10;
}
printf("Given number is = %d\n", temp);
printf("Its reverse is  = %d\n", reverse);
if (temp == reverse)
printf("Number is a palindrome \n");
else
printf("Number is not a palindrome \n");
}
 ETP 
 
C Program to Find the Sum of two Binary Numbers
================================ EOPN
/* * C Program to Find the Sum of two Binary Numbers 
================================ EOKW
--------------------------------
output:
Output:
 
Enter the first binary number: 100000
Enter the second binary number: 101010
Sum of two binary numbers: 1001010
--------------------------------
#include <stdio.h>

int main()
{

long binary1, binary2;
int i = 0, remainder = 0, sum[20];

printf("Enter the first binary number: ");
scanf("%ld", &binary1);
printf("Enter the second binary number: ");
scanf("%ld", &binary2);
while (binary1 != 0 || binary2 != 0)
{
sum[i++] =(binary1 % 10 + binary2 % 10 + remainder) % 2;
remainder =(binary1 % 10 + binary2 % 10 + remainder) / 2;
binary1 = binary1 / 10;
binary2 = binary2 / 10;
}
if (remainder != 0)
sum[i++] = remainder;
--i;
printf("Sum of two binary numbers: ");
while (i >= 0)
printf("%d", sum[i--]);
return 0;
}
 ETP 
 
C Program to Find Multiplication of two Binary Numbers
================================ EOPN
/* * C Program to Find Multiplication of two Binary Numbers 
================================ EOKW
--------------------------------
output:
Output:
 
Enter the first binary number: 10010
Enter the second binary number: 10101
Product of two binary numbers: 101111010
--------------------------------
#include <stdio.h>

int binaryproduct(int, int);

int main()
{

long binary1, binary2, multiply = 0;
int digit, factor = 1;

printf("Enter the first binary number: ");
scanf("%ld", &binary1);
printf("Enter the second binary number: ");
scanf("%ld", &binary2);
while (binary2 != 0)
{
digit =  binary2 % 10;
if (digit == 1)
{
binary1 = binary1 * factor;
multiply = binaryproduct(binary1, multiply);
}
else
binary1 = binary1 * factor;
binary2 = binary2 / 10;
factor = 10;
}
printf("Product of two binary numbers: %ld", multiply);
return 0;
}

int binaryproduct(int binary1, int binary2)
{
int i = 0, remainder = 0, sum[20];
int binaryprod = 0;

while (binary1 != 0 || binary2 != 0)
{
sum[i++] =(binary1 % 10 + binary2 % 10 + remainder) % 2;
remainder =(binary1 % 10 + binary2 % 10 + remainder) / 2;
binary1 = binary1 / 10;
binary2 = binary2 / 10;
}
if (remainder != 0)
sum[i++] = remainder;
--i;
while (i >= 0)
binaryprod = binaryprod * 10 + sum[i--];
return binaryprod;
}
 ETP 
 
C Program to find Product of 2 Numbers without using Recursion
================================ EOPN
/*  
 * C Program to find Product of 2 Numbers without using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm19.c
$ a.out
Enter two numbers to find their product:  89  458
Product of 89 and 458 is 40762
--------------------------------

 
#include <stdio.h>
 
int product(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter two numbers to find their product: ");
    scanf("%d%d", &a, &b);
    result = product(a, b);
    printf("Product of %d and %d is %d\n", a, b, result);
    return 0;
}
 
int product(int a, int b)
{
    int temp = 0;
 
    while (b != 0)
    {
        temp += a;
        b--;
    }
    return temp;
}
 ETP 
 
C Program to Check whether a given Number is Armstrong
================================ EOPN
/*
 * C Program to Check whether a given Number is Armstrong
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm41.c -lm
$ a.out
enter a number370
The given no is armstrong no
 
$ a.out
enter a number1500
The given no is not a armstrong no
--------------------------------

#include <stdio.h>
#include <math.h>
 
void main()
{
    int number, sum = 0, rem = 0, cube = 0, temp;
 
    printf ("enter a number");
    scanf("%d", &number);
    temp = number;
    while (number != 0)
    {
        rem = number % 10;
        cube = pow(rem, 3);
        sum = sum + cube;
        number = number / 10;
    }
    if (sum == temp)
        printf ("The given no is armstrong no");
    else
        printf ("The given no is not a armstrong no");
}
 ETP 
 
C Program to Check whether a given Number is Perfect Number
================================ EOPN
/*
 * C Program to Check whether a given Number is Perfect Number
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm42.c
$ a.out
Enter a Number
6
Entered Number is perfect number
 
$ a.out
Enter a Number
100
Entered Number is not a perfect number
--------------------------------

#include <stdio.h>
 
int main()
{
    int number, rem, sum = 0, i;
 
    printf("Enter a Number\n");
    scanf("%d", &number);
    for (i = 1; i <= (number - 1); i++)
    {
        rem = number % i;
    if (rem == 0)
        {
            sum = sum + i;
        }
    }
    if (sum == number)
        printf("Entered Number is perfect number");
    else
        printf("Entered Number is not a perfect number");
    return 0;
}
 ETP 
 
C Program to Print Armstrong Number from 1 to 1000
================================ EOPN
/*
 * C Program to Print Armstrong Number from 1 to 1000
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm44.c
$ a.out
Print all Armstrong numbers between 1 and 1000:
 
Amstrong no is:1
Amstrong no is:153
Amstrong no is:370
Amstrong no is:371
Amstrong no is:407
--------------------------------

#include <stdio.h>
 
main()
{
    int number, temp, digit1, digit2, digit3;
 
    printf("Print all Armstrong numbers between 1 and 1000:\n");
    number = 001;
    while (number <= 900)
    {
        digit1 = number - ((number / 10) * 10);
        digit2 = (number / 10) - ((number / 100) * 10);
        digit3 = (number / 100) - ((number / 1000) * 10);
        temp = (digit1 * digit1 * digit1) + (digit2 * digit2 * digit2) + (digit3 * digit3 * digit3);
        if (temp == number)
        {
            printf("\n Armstrong no is:%d", temp);
        }
        number++;
    }
}
 ETP 
 
C Program to Add two Complex Numbers
================================ EOPN
/*
 * C Program to Add two Complex Numbers
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm55.c
$ a.out
Enter value of a and b complex number a + ib.
value of complex number a is = 10
value of complex number b is = 12
Enter value of c and d complex number c + id.
value of complex number c is = 15
value of complex number d is = 22
complex numbers sum is = 25 + 34i
--------------------------------

#include <stdio.h>
 
struct complex
{
   int realpart, imaginary;
};
 
main()
{
    struct complex a, b, c;
 
    printf("Enter value of a and b complex number a + ib.\n");
    printf("value of complex number a is = ");
    scanf("%d", &a.realpart);
    printf("value of complex number b is = ");
    scanf("%d", &a.imaginary);
    printf("Enter value of c and d complex number c + id.\n");
    printf("value of complex number c is = ");
    scanf("%d", &b.realpart);
    printf("value of complex number d is = ");
    scanf("%d", &b.imaginary);
    c.realpart = a.realpart + b.realpart;
    c.imaginary = a.imaginary + b.imaginary;
    if (c.imaginary >= 0)
        printf("complex numbers sum is = %d + %di\n", c.realpart, c.imaginary);
    else
        printf("complex numbers sum = %d %di\n", c.realpart, c.imaginary);
    return 0;
}
 ETP 
 
C Program to Generate Fibonacci Series of N Numbers using Command-Line Argument
================================ EOPN
/*
 * C program to generate Fibonacci Series. Fibonacci Series
 * is 0 1 1 2 3 5 8 13 21 ...
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm40.c
$ a.out
Enter the limit to generate the Fibonacci Series
6
Fibonacci Series is ...
0
1
1
2
3
5
--------------------------------

#include <stdio.h>
 
void main()
{
    int  fib1 = 0, fib2 = 1, fib3, limit, count = 0;
 
    printf("Enter the limit to generate the Fibonacci Series \n");
    scanf("%d", &limit);
    printf("Fibonacci Series is ...\n");
    printf("%d\n", fib1);
    printf("%d\n", fib2);
    count = 2;
    while (count < limit)
    {
        fib3 = fib1 + fib2;
        count++;
        printf("%d\n", fib3);
        fib1 = fib2;
        fib2 = fib3;
    }
}
 ETP 
 
C Program to Compute First N Fibonacci Numbers using Command Line Arguments
================================ EOPN
/* * C Program to Compute First N Fibonacci Numbers using Command Line Arguments 
================================ EOKW
--------------------------------
output:
$ cc arg6.c
$ a.out 10
0       1       1       2       3       5       8       13      21      34
--------------------------------
#include <stdio.h>

/* Global Variable Declaration */
int first = 0;
int second = 1;
int third;
/* Function Prototype */
void rec_fibonacci(int);

void main(int argc, char *argv[])/* Command line Arguments*/
{
int number = atoi(argv[1]);
printf("%d\t%d", first, second); /* To print first and second number of fibonacci series */
rec_fibonacci(number);
printf("\n");
}

/* Code to print fibonacci series using recursive function */
void rec_fibonacci(int num)
{
if (num == 2)    /* To exit the function as the first two numbers are already printed */
{
return;
}
third = first + second;
printf("\t%d", third);
first = second;
second = third;
num--;
rec_fibonacci(num);
}
 ETP 
 
 C Program to Find the Sum of first 50 Natural Numbers using For Loop   
================================ EOPN
/*
 * C program to find the sum of first 50 natural numbers
 * using for loop
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm73.c
$ a.out
Sum = 1275
--------------------------------

#include <stdio.h>
 
void main()
{
    int  num, sum = 0;
 
    for (num = 1; num <= 50; num++)
    {
        sum = sum + num;
    }
    printf("Sum = %4d\n", sum);
}
 ETP 
 
 C Program to Swap the Contents of two Numbers using Bitwise XOR Operation 
================================ EOPN
/*
 * C program to swap the contents of two numbers using bitwise XOR
 * operation. Don't use either the temporary variable or arithmetic
 * operators
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm48.c
$ a.out
Enter two integers
45
89
 
Before swapping i= 45 and k = 89
After swapping i= 89 and k = 45
--------------------------------

#include <stdio.h>
 
void main()
{
    long i, k;
 
    printf("Enter two integers \n");
    scanf("%ld %ld", &i, &k);
    printf("\n Before swapping i= %ld and k = %ld", i, k);
    i = i ^ k;
    k = i ^ k;
    i = i ^ k;
    printf("\n After swapping i= %ld and k = %ld", i, k);
}
 ETP 
 
 C Program to Multiply given Number by 4 using Bitwise Operators  
================================ EOPN
/*
 * C program to multiply given number by 4 using bitwise operators
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm62.c
$ a.out
Enter an integer
450
450 x 4 = 1800
--------------------------------

#include <stdio.h>
 
void main()
{
    long number, tempnum;
 
    printf("Enter an integer \n");
    scanf("%ld", &number);
    tempnum = number;
    /*  left shift by two bits 
 ETP 
 
 C Program to Illustrate how User Authentication is Done 
================================ EOPN
/* * C program is to illustrate how user authentication is done. * Program asks for the user name and password and displays * the password as '*' character 
================================ EOKW
--------------------------------
output:
 
Enter User name: rajaraman
Enter the password <any 8 characters>: shashi12
********
Your password is :shashi12
--------------------------------
#include <stdio.h>

void main()
{
char password[10], username[10], ch;
int i;

printf("Enter User name: ");
gets(username);
printf("Enter the password < any 8 characters>: ");
for (i = 0; i < 8; i++)
{
ch = getchar();
password[i] = ch;
ch = '*' ;
printf("%c", ch);
}
password[i] = '\0';
/*  Original password can be printed, if needed */
printf("\n Your password is :");
for (i = 0; i < 8; i++)
{
printf("%c", password[i]);
}
}
 ETP 
 
C Program to Display the IP Address of the System
================================ EOPN
/* * C Program to Get IP Address 
================================ EOKW
--------------------------------
output:
 
IP Address is eth0 - 192.168.225.135
--------------------------------
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <unistd.h>
#include <arpa/inet.h>

int main()
{
int n;
struct ifreq ifr;
char array[] = "eth0";

n = socket(AF_INET, SOCK_DGRAM, 0);
//Type of address to retrieve - IPv4 IP address
ifr.ifr_addr.sa_family = AF_INET;
//Copy the interface name in the ifreq structure
strncpy(ifr.ifr_name , array , IFNAMSIZ - 1);
ioctl(n, SIOCGIFADDR, &ifr);
close(n);
//display result
printf("IP Address is %s - %s\n" , array , inet_ntoa(( (struct sockaddr_in *)&ifr.ifr_addr )->sin_addr) );
return 0;
}
 ETP 
 
C Program to Shutdown or Turn Off the Computer in Linux
================================ EOPN
/* * C Program to Shutdown or Turn Off the Computer in Linux. 
================================ EOKW
--------------------------------
output:
 
shutdown: Need to be root
--------------------------------
#include <stdio.h>

int main()
{
system("shutdown -P now");
return 0;
}
 ETP 
 
 C Program to Find if a given Year is a Leap Year 
================================ EOPN
/* * C program to find whether a given year is leap year or not 
================================ EOKW
--------------------------------
output:
 
Enter a year
2012
2012 is a leap year
 
 
Enter a year
2009
2009 is not a leap year
--------------------------------
void main()
{
int year;

printf("Enter a year \n");
scanf("%d", &year);
if ((year % 400) == 0)
printf("%d is a leap year \n", year);
else if ((year % 100) == 0)
printf("%d is a not leap year \n", year);
else if ((year % 4) == 0)
printf("%d is a leap year \n", year);
else
printf("%d is not a leap year \n", year);
}
 ETP 
 
C Program to Extract Last two Digits of a given Year
================================ EOPN
/* * C Program to Extract Last two Digits of a given Year 
================================ EOKW
--------------------------------
output:
Output:
Enter the year 2012
Last two digits of year is: 12
--------------------------------
#include <stdio.h>

int main()
{
int year, yr;

printf("Enter the year ");
scanf("%d", &year);
yr = year % 100;
printf("Last two digits of year is: %02d", yr);
return 0;
}
 ETP 
 
 C Program to Display the Inventory of Items in a Store 
================================ EOPN
/*
 * C program to display the inventory of items in a store / shop
 * The inventory maintains details such as name, price, quantity
 * and manufacturing date of each item.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm60.c
$ a.out
Enter number of items:3
Item name:
pendrive
Item code:
123
Quantity:
6
price:
3000
Manufacturing date(dd-mm-yyyy):
30-9-2012
Item name:
computer
Item code:
124
Quantity:
10
price:
10000
Manufacturing date(dd-mm-yyyy):
30-7-2012
Item name:
optical mouse
Item code:
Quantity:
price:
Manufacturing date(dd-mm-yyyy):
             *****  INVENTORY *****
------------------------------------------------------------------
S.N.|    NAME           |   CODE   |  QUANTITY |  PRICE  | MFG.DATE
------------------------------------------------------------------
1     pendrive               123          6        3000     30/9/2012
2     computer               124          10       10000    30/7/2012
3     optical                0            0        0        0/0/0
------------------------------------------------------------------
 
$ a.out
Enter number of items:3
Item name:
pendrive
Item code:
123
Quantity:
6
price:
3000
Manufacturing date(dd-mm-yyyy):
30-9-2012
Item name:
computer
Item code:
124
Quantity:
10
price:
10000
Manufacturing date(dd-mm-yyyy):
30-7-2012
Item name:
Mouse
Item code:
125
Quantity:
10
price:
1500
Manufacturing date(dd-mm-yyyy):
30-6-2012
 
             *****  INVENTORY *****
------------------------------------------------------------------
S.N.|    NAME           |   CODE   |  QUANTITY |  PRICE    | MFG.DATE
------------------------------------------------------------------
1     pendrive               123          6        3000      30/9/2012
2     computer               124          10       10000     30/7/2012
3     Mouse                  125          10       1500      30/6/2012
------------------------------------------------------------------
--------------------------------

#include <stdio.h>
 
void main()
{
    struct date
    {
        int day;
        int month;
        int year;
    };
    struct details
    {
        char name[20];
        int price;
        int code;
        int qty;
        struct date mfg;
    };
    struct details item[50];
    int n, i;
 
    printf("Enter number of items:");
    scanf("%d", &n);
    fflush(stdin);
    for (i = 0; i < n; i++)
    {
        fflush(stdin);
        printf("Item name: \n");
        scanf("%s", item[i].name);
        fflush(stdin);
        printf("Item code: \n");
        scanf("%d", &item[i].code);
        fflush(stdin);
        printf("Quantity: \n");
        scanf("%d", &item[i].qty);
        fflush(stdin);
        printf("price: \n");
        scanf("%d",  &item[i].price);
        fflush(stdin);
        printf("Manufacturing date(dd-mm-yyyy): \n");
        scanf("%d-%d-%d", &item[i].mfg.day,
        &item[i].mfg.month, &item[i].mfg.year);
    }
    printf("             *****  INVENTORY ***** \n");
    printf("---------------------------------------------------------
    ---------\n");
    printf("S.N.|    NAME           |   CODE   |  QUANTITY |  PRICE
    | MFG.DATE \n");
    printf("---------------------------------------------------------
    ---------\n");
    for (i = 0; i < n; i++)
        printf("%d     %-15s        %-d          %-5d     %-5d
        %d/%d/%d \n", i + 1, item[i].name, item[i].code, item[i].qty,
        item[i].price, item[i].mfg.day, item[i].mfg.month,
        item[i].mfg.year);
    printf("---------------------------------------------------------
    ---------\n");
}
 ETP 
 
C Program to Display the ATM Transaction
================================ EOPN
/* * C Program to Display the ATM Transaction 
================================ EOKW
--------------------------------
output:
 
 
ENTER YOUR SECRET PIN NUMBER:1520
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: 1
 
YOUR BALANCE IN Rs : 1000
 
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: 2
 
ENTER THE AMOUNT TO WITHDRAW: 200
 
 
PLEASE COLLECT CASH
YOUR CURRENT BALANCE IS 800
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: 3
 
ENTER THE AMOUNT TO DEPOSIT 5000
YOUR BALANCE IS 5800
 
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: 1
 
YOUR BALANCE IN Rs : 5800
 
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: 4
 
THANK U USING ATM
 
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: 4
 
THANK U USING ATM
 
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
********Welcome to ATM Service**************
1. Check Balance
2. Withdraw Cash
3. Deposit Cash
4. Quit
******************?**************************?*
 
Enter your choice: n
 
THANK U USING ATM
 
 
DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n):
 
THANKS FOR USING OUT ATM SERVICE.
--------------------------------
#include <stdio.h>

unsigned long amount=1000, deposit, withdraw;
int choice, pin, k;
char transaction ='y';

void main()
{
while (pin != 1520)
{
printf("ENTER YOUR SECRET PIN NUMBER:");
scanf("%d", &pin);
if (pin != 1520)
printf("PLEASE ENTER VALID PASSWORD\n");
}
do
{
printf("********Welcome to ATM Service**************\n");
printf("1. Check Balance\n");
printf("2. Withdraw Cash\n");
printf("3. Deposit Cash\n");
printf("4. Quit\n");
printf("******************?**************************?*\n\n");
printf("Enter your choice: ");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("\n YOUR BALANCE IN Rs : %lu ", amount);
break;
case 2:
printf("\n ENTER THE AMOUNT TO WITHDRAW: ");
scanf("%lu", &withdraw);
if (withdraw % 100 != 0)
{
printf("\n PLEASE ENTER THE AMOUNT IN MULTIPLES OF 100");
}
else if (withdraw >(amount - 500))
{
printf("\n INSUFFICENT BALANCE");
}
else
{
amount = amount - withdraw;
printf("\n\n PLEASE COLLECT CASH");
printf("\n YOUR CURRENT BALANCE IS%lu", amount);
}
break;
case 3:
printf("\n ENTER THE AMOUNT TO DEPOSIT");
scanf("%lu", &deposit);
amount = amount + deposit;
printf("YOUR BALANCE IS %lu", amount);
break;
case 4:
printf("\n THANK U USING ATM");
break;
default:
printf("\n INVALID CHOICE");
}
printf("\n\n\n DO U WISH TO HAVE ANOTHER TRANSCATION?(y/n): \n");
fflush(stdin);
scanf("%c", &transaction);
if (transaction == 'n'|| transaction == 'N')
k = 1;
} while (!k);
printf("\n\n THANKS FOR USING OUT ATM SERVICE");
}
 ETP 
 
 C Program to Accept the Height of a Person & Categorize as Taller, Dwarf & Average 
================================ EOPN
/* * C program to accept the height of a person in centimeter and * categorize the person based on height as taller, dwarf and * average height person 
================================ EOKW
--------------------------------
output:
Enter  the Height (in centimetres)
165
Average Height
 
Enter  the Height (in centimetres)
140
Dwarf
 
Enter  the Height (in centimetres)
190
Taller
--------------------------------

#include <stdio.h>
void main()
{
float height;

printf("Enter  the Height (in centimetres) \n");
scanf("%f", &height);
if (height < 150.0)
printf("Dwarf \n");
else if ((height >= 150.0) && (height <= 165.0))
printf(" Average Height \n");
else if ((height > 165.0) && (height <= 195.0))
printf("Taller \n");
else
printf("Abnormal height \n");
}
 ETP 
 
 C Program to Read a Grade & Display the Equivalent Description 
================================ EOPN
/* * C Program to accept a grade and declare the equivalent description * if code is S, then print SUPER * if code is A, then print VERY GOOD * if code is B, then print FAIR * if code is Y, then print ABSENT * if code is F, then print FAILS 
================================ EOKW
--------------------------------
output:
 
Enter the grade
s
RESULT  :  SUPER
 
Enter the grade
a
RESULT  :  VERY GOOD
 
Enter the grade
b
RESULT  :  FAIR
 
Enter the grade
y
RESULT  :  ABSENT
 
Enter the grade
f
RESULT  :  FAILS
--------------------------------
#include <stdio.h>
#include <ctype.h>
#include <string.h>

void main()
{
char remark[15];
char grade;

printf("Enter the grade \n");
scanf("%c", &grade);
/*  lower case letter to upper case */
grade = toupper(grade);
switch(grade)
{
case 'S':
strcpy(remark, " SUPER");
break;
case 'A':
strcpy(remark, " VERY GOOD");
break;
case 'B':
strcpy(remark, " FAIR");
break;
case 'Y':
strcpy(remark, " ABSENT");
break;
case 'F':
strcpy(remark, " FAILS");
break;
default :
strcpy(remark, "ERROR IN GRADE \n");
break;
}
printf("RESULT  : %s\n", remark);
}
 ETP 
 
 C Program to Illustrate the Concept of Unions 
================================ EOPN
/* * C program to illustrate the concept of unions 
================================ EOKW
--------------------------------
output:
 
Enter the value of n1: 10
Value of n1 = 10
Enter the value of n2: 50
Value of n2 = 50.000000
--------------------------------
#include <stdio.h>

void main()
{
union number
{
int  n1;
float n2;
};
union number x;

printf("Enter the value of n1: ");
scanf("%d", &x.n1);
printf("Value of n1 = %d", x.n1);
printf("\nEnter the value of n2: ");
scanf("%f", &x.n2);
printf("Value of n2 = %f\n", x.n2);
}
 ETP 
 
 C Program to Find the Size of a Union 
================================ EOPN
/* * C program to find the size of a union 
================================ EOKW
--------------------------------
output:
 
The size of union = 4
25 0.000000 
1045220557 0.200000
1045220464 0.199999
--------------------------------
#include <stdio.h>

void main()
{
union sample
{
int   m;
float n;
char  ch;
};
union sample u;

printf("The size of union = %d\n", sizeof(u));
/*  initialization */
u.m = 25;
printf("%d %f %c\n", u.m, u.n, u.ch);
u.n = 0.2;
printf("%d %f %c\n", u.m, u.n, u.ch);
u.ch = 'p';
printf("%d %f %c\n", u.m, u.n, u.ch);
}
 ETP 
 
C Program to Display Function without using the Main Function
================================ EOPN
/* * C Program to display function without using the Main Function 
================================ EOKW
--------------------------------
output:
Output:
 
helloworld
--------------------------------
#include <stdio.h>
#define decode(s,t,u,m,p,e,d) m##s##u##t
#define begin decode(a,n,i,m,a,t,e)

int begin()
{
printf(" helloworld ");
}
 ETP 
 
C Program to Print a Semicolon without using a Semicolon anywhere in the Code
================================ EOPN
/* * C Program to Print a Semicolon without using a Semicolon * anywhere in the code 
================================ EOKW
--------------------------------
output:
 
;
--------------------------------
#include <stdio.h>

int main(void)
{
//59 is the ascii value of semicolumn
if (printf("%c ", 59))
{
}
return 0;
}
 ETP 
 
C program to Increase 1 to all of the given Integer Digit
================================ EOPN
 /* * C program to Increase 1 to all of the given Integer Digit 
================================ EOKW
--------------------------------
output:
Enter a number: 3456
increasing 1 to all digits:  22
--------------------------------
#include <stdio.h>

int main()
{
int number, sum = 0, remainder, count;

printf("Enter a number: ");
scanf("%d", &number);
while (number)
{
remainder = number % 10;
sum  = sum + (remainder + 1);
number /= 10;
}
printf("increasing 1 to all digits:  %d", sum);
return 0;
}
 ETP 
 
C Program to Print Diamond Pattern
================================ EOPN
 /* * C Program to Print Diamond Pattern 
================================ EOKW
--------------------------------
output:
Enter number of rows
5
    *
   ***
  *****
 *******
*********
 *******
  *****
   ***
    *
 
Enter number of rows
2
 *
***
 *
--------------------------------
#include <stdio.h>

int main()
{
int number, i, k, count = 1;

printf("Enter number of rows\n");
scanf("%d", &number);
count = number - 1;
for (k = 1; k <= number; k++)
{
for (i = 1; i <= count; i++)
printf(" ");
count--;
for (i = 1; i <= 2 * k - 1; i++)
printf("*");
printf("\n");
}
count = 1;
for (k = 1; k <= number - 1; k++)
{
for (i = 1; i <= count; i++)
printf(" ");
count++;
for (i = 1 ; i <= 2 *(number - k)-  1; i++)
printf("*");
printf("\n");
}
return 0;
}
 ETP 
 
C Program to Print any Print Statement without using Semicolon
================================ EOPN
/* * C Program to Print any Print Statement without using Semicolon 
================================ EOKW
--------------------------------
output:
Output:
 
Hi.. Welcome to sanfoundry
--------------------------------
#include <stdio.h>

void main()
{
if(printf("Hi.. Welcome to sanfoundry"))
{
}
}
 ETP 
 
C Program to Display its own Source Code as its Output
================================ EOPN
/* * C Program to Display its own Source Code as its Output 
================================ EOKW
--------------------------------
output:
Output:
 
/*
 * C Program to display its own source code as its output
 */
#include <stdio.h>
 
int main()
{
    FILE *fp;
    char ch;
 
    fp = fopen(__FILE__,"r");
    do
    {
        ch = getc(fp);
        putchar(ch);
     }
     while (ch != EOF);
     fclose(fp);
     return 0;
}
--------------------------------
#include <stdio.h>

int main()
{
FILE *fp;
char ch;

fp = fopen(__FILE__,"r");
do
{
ch = getc(fp);
putchar(ch);
}
while (ch != EOF);
fclose(fp);
return 0;
}
 ETP 
 
C Program to Illustrate Pass by Reference
================================ EOPN
/* * C Program to Illustrate Pass by Reference 
================================ EOKW
--------------------------------
output:
output:
the cube of the given number is 1000
--------------------------------
#include <stdio.h>

void cube( int *x);

int main()
{
int num = 10;

cube(&num);
printf("the cube of the given number is %d", num);
return 0;
}

void  cube(int *x)
{
*x = (*x) * (*x) * (*x);
}
 ETP 
 
C Program to Illustrate Pass by Value
================================ EOPN
/* * C Program to Illustrate Pass by Value. 
================================ EOKW
--------------------------------
output:
 
Before swapping num1 = 10 num2 = 20
After swapping num1 = 10 num2 = 20
--------------------------------
#include <stdio.h>

void swap(int a, int b)
{
int temp;
temp = a;
a = b;
b = temp;
}

int main()
{
int num1 = 10, num2 = 20;

printf("Before swapping num1 = %d num2 = %d\n", num1, num2);
swap(num1, num2);
printf("After swapping num1 = %d num2 = %d \n", num1, num2);
return 0;
}
 ETP 
 
C Program to Input 3 Arguments and Operate Appropriately on the Numbers
================================ EOPN
/*  * C Program to Input 3 Arguments and Operate Appropriately on the  * Numbers 
================================ EOKW
--------------------------------
output:
arguments entered:
5 4 +
The result of the operation is 9
 
arguments entered:
8 7 -
The result of the operation is 1
 
arguments entered:
9 6 x
The result of the operation is 54
 
arguments entered:
100 10 /
The result of the operation is 10
--------------------------------
#include <stdio.h>

void main(int argc, char * argv[])
{
int a, b, result;
char ch;

printf("arguments entered: \n");
a = atoi(argv[1]);
b = atoi(argv[2]);
ch  = *argv[3];
printf("%d %d %c", a, b, ch);
switch (ch)
{
case '+':
result = a + b;
break;
case '-':
result = a - b;
break;
case 'x':
result = a * b;
break;
case '/':
result = a / b;
break;
default:
printf("Enter a valid choice");
}
printf("\nThe result of the operation is %d", result);
printf("\n");
}
 ETP 
 
C Program to Print the Program Name and All its Arguments
================================ EOPN
/*
 * C Program to Print the Program Name and All its Arguments
 
================================ EOKW
--------------------------------
output:
 
$ cc arg9.c
$ a.out this is  c class by sanfoundry
a.out this is c class by sanfoundry
--------------------------------

#include <stdio.h>
 
void main(int argc, char *argv[])    /* command line Arguments 
 ETP 
 
 C Program to Calculate Sum & Average of an Array 
================================ EOPN
/* * C program to read N integers into an array A and * a) Find the sum of all numbers * b) Find the average of all numbers * Display the results with suitable headings 
================================ EOKW
--------------------------------
output:
Enter the value of N
5
Enter 5 numbers (-ve, +ve and zero)
10
20
30
40
50
 
Input array elements
10
20
30
40
50
 
Sum of all numbers =  150
 
Average of all input numbers =  30
--------------------------------

#include  <stdio.h>

int main()
{
int i, num;
float total = 0.0, average;
printf ("Enter the value of N \n");
scanf("%d", &num);
int array[num];

printf("Enter %d numbers (-ve, +ve and zero) \n", num);

for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}

printf("Input array elements \n");

for (i = 0; i < num; i++)
{
printf("%+3d\n", array[i]);
}

/*  Summation starts */

for (i = 0; i < num; i++)
{
total+=array[i];/* this means total=total+array[i]; */
}

average = total / num;

printf("\n Sum of all numbers =  %.2f\n", total);

printf("\n Average of all input numbers =  %.2f\n", average);

}
 ETP 
 
 C Program to Calculate the Sum of the Array Elements using Pointer 
================================ EOPN
/* * C program to read N integers and store them in an array A. * Find the sum of all these elements using pointer. 
================================ EOKW
--------------------------------
output:
Enter the size of array A
5
Enter Elements of the List
4
9
10
56
100
Sum of all elements in array = 179
--------------------------------

#include <stdio.h>
#include <malloc.h>

void main()
{
int i, n, sum = 0;
int *a;

printf("Enter the size of array A \n");
scanf("%d", &n);

a = (int *) malloc(n * sizeof(int));

printf("Enter Elements of the List \n");
for (i = 0; i < n; i++)
{
scanf("%d", a + i);
}

/*  Compute the sum of all elements in the given array */

for (i = 0; i < n; i++)
{
sum = sum + *(a + i);
/* this *(a+i) is used to access the value stored at the address*/
}

printf("Sum of all elements in array = %d\n", sum);
return 0;
}
 ETP 
 
 C Program to Calculate Sum of all Elements of an Array using Pointers as Arguments 
================================ EOPN
     /*     * C program to find the sum of all elements of an array using      * pointers as arguments.    
================================ EOKW
--------------------------------
output:
 
Sum of all array elements =  3000
--------------------------------

#include <stdio.h>

void main()
{
static int array[5] = { 200, 400, 600, 800, 1000 };
int sum;

int addnum(int *ptr);
sum = addnum(array);

printf("Sum of all array elements = %5d\n", sum);

}

int addnum(int *ptr)
{
int index, total = 0;
for (index = 0; index < 5; index++)
{
total += *(ptr + index);
}
return(total);

}
 ETP 
 
C Program to Compute the Sum of two One-Dimensional Arrays using Malloc 
================================ EOPN
/* * C program to find the sum of two one-dimensional arrays using * Dynamic Memory Allocation 
================================ EOKW
--------------------------------
output:
Enter the size of the arrays
5
Enter Elements of First List
23
45
67
12
90
Enter Elements of Second List
87
56
90
45
10
Resultant List is
110
101
157
57
100
--------------------------------

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main()
{

int i, n;
int *a, *b, *c;

printf("Enter the size of the arrays\n");
scanf("%d", &n);

a = (int *)malloc(n * sizeof(int));
b = (int *)malloc(n * sizeof(int));
c = (int *)malloc(n * sizeof(int));

printf("Enter Elements of First List\n");

for (i = 0; i < n; i++)
{
scanf("%d", a + i);
}

printf("Enter Elements of Second List\n");

for (i = 0; i < n; i++)
{
scanf("%d", b + i);
}

for (i = 0; i < n; i++)
{
*(c + i) = *(a + i) + *(b + i);
}

printf("Resultant List is\n");

for (i = 0; i < n; i++)
{
printf("%d\n", *(c + i));
}
return 0;
}
 ETP 
 
C Program to Find the Sum of Contiguous Subarray within a 1 – D Array of Numbers which has the Largest Sum
================================ EOPN
/* * C Program to Find the Sum of Contiguous Subarray within a  * 1 - D Array of Numbers which has the Largest Sum 
================================ EOKW
--------------------------------
output:
Type the length of the array
8
type the elements of the array
-1
-5
5
3
-2
5
4
1
 
The largest contiguous subarray is 5  3  -2  5  4  1
The sum of the largest contiguous subarray is 16
--------------------------------

#include<stdio.h>

int main()
{
int size,m=0,l=0;

printf("Type the length of the array\n");
scanf("%d",&size);
int array[size];
printf("type the elements of the array\n");

for(int i=0;i<size;i++)
{
scanf("%d",&array[i]);

}

int largest=array[0];
for(int i=0;i<size;i++)
{
int sum=0;
for(int j=i;j<size;j++)
{
sum=sum+array[j];
if(sum>largest)
{
m=i;l=j;
largest=sum;
}
}
}

printf("\n The largest contigous subarray is");
for(int z=m;z<=l;z++)
{
printf(" %d ",array[z]);
}
printf("\n The sum of the largest contigous subarray is");
printf(" %d",largest);
return 0;
}
 ETP 
 
 C Program to Find the Largest Two Numbers in a given Array 
================================ EOPN
/* * C program to read elements into an array and find the * largest two elements in a given array. 
================================ EOKW
--------------------------------
output:
Enter the size of the array
5
Enter the elements
2
4
5
8
7
The array elements are :
2       4       5       8       7
The FIRST LARGEST = 8
THE SECOND LARGEST = 7
--------------------------------

#include <stdio.h>
int main ()
{
int n = 0, i = 0, largest1 = 0, largest2 = 0, temp = 0;

printf ("Enter the size of the array\n");
scanf ("%d", &n);
int array[n];
printf ("Enter the elements\n");
for (i = 0; i < n; i++)
{
scanf ("%d", &array[i]);
}

printf ("The array elements are : \n");
for (i = 0; i < n; i++)
{
printf ("%d\t", array[i]);
}

printf ("\n");

largest1 = array[0];
largest2 = array[1];

if (largest1 < largest2)
{
temp = largest1;
largest1 = largest2;
largest2 = temp;
}

for (int i = 2; i < n; i++)
{
if (array[i] > largest1)
{
largest2 = largest1;
largest1 = array[i];
}
else if (array[i] > largest2 && array[i] != largest1)
{
largest2 = array[i];
}
}

printf ("The FIRST LARGEST = %d\n", largest1);
printf ("THE SECOND LARGEST = %d\n", largest2);

return 0;
}
 ETP 
 
 C Program to Find the Second Largest & Smallest Elements in an Array 
================================ EOPN
     /*     * C program to accept a list of data items and find the second largest     * and smallest elements in it. Compute the average of both and search     * for the average value if it is present in the array.     * Display appropriate message on successful search.    
================================ EOKW
--------------------------------
output:
Enter the value of N
4
Enter the numbers
450
340
120
670
The numbers arranged in descending order are given below
670
450
340
120
The 2nd largest number is  = 450
The 2nd smallest number is = 340
The average of 450  and 340 is = 395 is not in the array
--------------------------------

#include <stdio.h>
void main ()
{

int number[30];
int i, j, a, n, counter, average;

printf("Enter the value of N\n");
scanf("%d", &n);

printf("Enter the numbers \n");
for (i = 0; i < n; ++i)
scanf("%d", &number[i]);

for (i = 0; i < n; ++i)
{
for (j = i + 1; j < n; ++j)
{
if (number[i] < number[j])
{
a = number[i];
number[i] = number[j];
number[j] = a;
}
}

}

printf("The numbers arranged in descending order are given below \n");

for (i = 0; i < n; ++i)
{
printf("%d\n", number[i]);
}

printf("The 2nd largest number is  = %d\n", number[1]);
printf("The 2nd smallest number is = %d\n", number[n - 2]);

average = (number[1] + number[n - 2]) / 2;
counter = 0;

for (i = 0; i < n; ++i)
{
if (average == number[i])
{
++counter;
}
}

if (counter == 0 )
printf("The average of %d  and %d is = %d is not in the array \n",
number[1], number[n - 2], average);

else
printf("The average of %d  and %d in array is %d in numbers \n",
number[1], number[n - 2], counter);
}
 ETP 
 
C Program to Find the Largest Number in an Array
================================ EOPN
/* * C program to read N integers into an array A and * a) Find the sum of all numbers * b) Find the average of all numbers * Display the results with suitable headings 
================================ EOKW
--------------------------------
output:
Enter the size of the array: 5
 
Enter 5 elements of  the array: 
12
56
34
78
100
 
largest element present in the given array is: 100
--------------------------------

#include <stdio.h>

int main()
{

int size, i, largest;

printf("\n Enter the size of the array: ");
scanf("%d", &size);
int array[size];

printf("\n Enter %d elements of  the array: \n", size);

for (i = 0; i < size; i++)
{
scanf("%d", &array[i]);
}

largest = array[0];

for (i = 1; i < size; i++)
{
if (largest < array[i])
largest = array[i];
}

printf("\n largest element present in the given array is : %d", largest);

return 0;

}
 ETP 
 
 C Program to Put Even & Odd Elements of an Array in 2 Separate Arrays 
================================ EOPN
     /*     * C Program to accept N integer number and store them in an array AR.     * The odd elements in the AR are copied into OAR and other elements     * are copied into EAR. Display the contents of OAR and EAR.    
================================ EOKW
--------------------------------
output:
Enter the size of array AR
6
Enter the elements of the array
34
56
78
90
12
39
The elements of OAR are
39
The elements of EAR are
34
56
78
90
12
--------------------------------

#include <stdio.h>
void main()
{

long int ARR[10], OAR[10], EAR[10];
int i, j = 0, k = 0, n;

printf("Enter the size of array AR n");
scanf("%d", &n);

printf("Enter the elements of the array n");
for (i = 0; i < n; i++)
{
scanf("%ld", &ARR[i]);
fflush(stdin);
}

/*  Copy odd and even elements into their respective arrays */

for (i = 0; i < n; i++)
{
if (ARR[i] % 2 == 0)
{
EAR[j] = ARR[i];
j++;
}
else
{
OAR[k] = ARR[i];
k++;
}
}

printf("The elements of OAR are n");
for (i = 0; i < k; i++)
{
printf("%ldn", OAR[i]);
}

printf("The elements of EAR are n");
for (i = 0; i < j; i++)
{
printf("%ldn", EAR[i]);
}

}
 ETP 
 
 C Program to Insert an Element in a Specified Position in a given Array  
================================ EOPN
   /*   * C program to insert a particular element in a specified position   * in a given array  
================================ EOKW
--------------------------------
output:
Enter how many elements
5
Enter the elements
76
90
56
78
12
Input array elements are
76
90
56
78
12
Sorted list is
12
56
76
78
90
Enter the element to be inserted
61
Final list is
12
56
61
76
78
90
--------------------------------

#include <stdio.h>
void main()
{
int array[10];
int i, j, n, m, temp, key, pos;

printf("Enter how many elements \n");
scanf("%d", &n);
printf("Enter the elements \n");

for (i = 0; i < n; i++)
{
scanf("%d", &array[i]);
}

printf("Input array elements are \n");
for (i = 0; i < n; i++)
{
printf("%d\n", array[i]);
}

// Sorting the elements of the array
for (i = 0; i < n; i++)
{
for (j = i + 1; j < n; j++)
{
if (array[i] > array[j])
{
temp = array[i];
array[i] = array[j];
array[j] = temp;
}
}
}

printf("Sorted list is \n");
for (i = 0; i < n; i++)
{
printf("%d\n", array[i]);
}

printf("Enter the element to be inserted \n");
scanf("%d", &key);

for (i = 0; i < n; i++)
{
if (key < array[i])
{
pos = i;
break;
}
if (key > array[n-1])
{
pos = n;
break;
}
}
if (pos != n)
{
m = n - pos + 1 ;
for (i = 0; i <= m; i++)
{
array[n - i + 2] = array[n - i + 1] ;
}
}

array[pos] = key;

printf("Final list is \n");
for (i = 0; i < n + 1; i++)
{
printf("%d\n", array[i]);
}

}
 ETP 
 
 C Program to Delete the Specified Integer from an Array 
================================ EOPN
     /*     * C program to accept an array of integers and delete the     * specified integer from the list    
================================ EOKW
--------------------------------
output:
Enter how many elements
4
Enter the elements
345
234
678
987
Input array elements are
345
234
678
987
Enter the element to be deleted
234
The resultant vector is
345
678
987
--------------------------------



#include <stdio.h>
void main()
{
int vectorx[10];
int i, n, pos, element, found = 0;

printf("Enter how many elements\n");
scanf("%d", &n);
printf("Enter the elements\n");

for (i = 0; i < n; i++)
{
scanf("%d", &vectorx[i]);
}

printf("Input array elements are\n");
for (i = 0; i < n; i++)
{
printf("%d\n", vectorx[i]);
}

printf("Enter the element to be deleted\n");
scanf("%d", &element);

for (i = 0; i < n; i++)
{
if (vectorx[i] == element)
{
found = 1;
pos = i;
break;
}
}

if (found == 1)
{
for (i = pos; i <  n - 1; i++)
{
vectorx[i] = vectorx[i + 1];
}

printf("The resultant vector is \n");
for (i = 0; i < n - 1; i++)
{
printf("%d\n", vectorx[i]);
}

}
else
printf("Element %d is not found in the vector\n", element);

}
 ETP 
 
 C Program to Cyclically Permute the Elements of an Array 
================================ EOPN
    /*     * C program to cyclically permute the elements of an array A.     * i.e. the content of A1 become that of A2. And A2 contains     * that of A3 & so on as An contains A1     
================================ EOKW
--------------------------------
output:
Enter the value of the n = 4
Enter the numbers
3
40
100
68
Cyclically permuted numbers are given below
40
100
68
3
--------------------------------

#include <stdio.h>
void main ()
{

int i, n, number[30];
printf("Enter the value of the n = ");
scanf("%d", &n);

printf("Enter the numbers\n");
for (i = 0; i < n; ++i)
{
scanf("%d", &number[i]);
}

number[n] = number[0];
for (i = 0; i < n; ++i)
{
number[i] = number[i + 1];
}

printf("Cyclically permuted numbers are given below \n");
for (i = 0; i < n; ++i)
printf("%d\n", number[i]);

}
 ETP 
 
 C Program to Sort the Array in an Ascending Order 
================================ EOPN
     /*     * C program to accept N numbers and arrange them in an ascending order     
================================ EOKW
--------------------------------
output:
 
Enter the value of N
6
Enter the numbers
3
78
90
456
780
200
The numbers arranged in ascending order are given below
3
78
90
200
456
780
--------------------------------

#include <stdio.h>
void main()
{

int i, j, a, n, number[30];
printf("Enter the value of N \n");
scanf("%d", &n);

printf("Enter the numbers \n");
for (i = 0; i < n; ++i)
scanf("%d", &number[i]);

for (i = 0; i < n; ++i)
{

for (j = i + 1; j < n; ++j)
{

if (number[i] > number[j])
{

a =  number[i];
number[i] = number[j];
number[j] = a;

}

}

}

printf("The numbers arranged in ascending order are given below \n");
for (i = 0; i < n; ++i)
printf("%d\n", number[i]);

}
 ETP 
 
 C Program to Sort the Array in Descending Order 
================================ EOPN
   /*    * C program to accept a set of numbers and arrange them    * in a descending order    
================================ EOKW
--------------------------------
output:
Enter the value of N
5
Enter the numbers
234
780
130
56
90
The numbers arranged in descending order are given below
780
234
130
90
56
--------------------------------

#include <stdio.h>
void main ()
{

int number[30];

int i, j, a, n;
printf("Enter the value of N\n");
scanf("%d", &n);

printf("Enter the numbers \n");
for (i = 0; i < n; ++i)
scanf("%d", &number[i]);

/*  sorting begins ... */

for (i = 0; i < n; ++i)
{
for (j = i + 1; j < n; ++j)
{
if (number[i] < number[j])
{
a = number[i];
number[i] = number[j];
number[j] = a;
}
}
}

printf("The numbers arranged in descending order are given below\n");

for (i = 0; i < n; ++i)
{
printf("%d\n", number[i]);
}

}
 ETP 
 
 C Program to Sort Names in an Alphabetical Order 
================================ EOPN
    /*     * C program to read N names, store them in the form of an array     * and sort them in alphabetical order. Output the given names and     * the sorted names in two columns side by side.     
================================ EOKW
--------------------------------
output:
Enter the value of n
7
Enter 7 names
heap
stack
queue
object
class
program
project
 
----------------------------------------
Input Names    Sorted names
------------------------------------------
heap           class
stack          heap
queue          object
object         program
class          project
program        queue
project        stack
------------------------------------------
--------------------------------

#include <stdio.h>
#include <string.h>
void main()
{

char name[10][8], tname[10][8], temp[8];
int i, j, n;

printf("Enter the value of n \n");
scanf("%d", &n);
printf("Enter %d names n \n", n);

for (i = 0; i < n; i++)
{
scanf("%s", name[i]);
strcpy(tname[i], name[i]);
}

for (i = 0; i < n - 1 ; i++)
{
for (j = i + 1; j < n; j++)
{
if (strcmp(name[i], name[j]) > 0)
{
strcpy(temp, name[i]);
strcpy(name[i], name[j]);
strcpy(name[j], temp);
}
}
}

printf("\n----------------------------------------\n");
printf("Input NamestSorted names\n");
printf("------------------------------------------\n");

for (i = 0; i < n; i++)
{
printf("%s\t\t%s\n", tname[i], name[i]);
}

printf("------------------------------------------\n");

}
 ETP 
 
C Program to Merge and Sort Elements of 2 different Arrays 
================================ EOPN
/* * C Program to Merge and Sort Elements of 2 different arrays 
================================ EOKW
--------------------------------
output:
$ cc pgm82.c
$ a.out
 
enter the size of an array10
 
enter the array elements-12
10
45
32
49
-58
69
38
98
34
-58 -12 10 32 34 38 45 49 69 98
--------------------------------
#include <stdio.h>

void Merge(int * , int , int , int );

void MergeSort(int *array, int left, int right)
{
int middle = (left+right)/2;
/* We have to sort only when left<right because when left=right it is anyhow sorted*/
if(left<right)
{
/* Sort the left part */
MergeSort(array, left, middle);
/* Sort the right part */
MergeSort(array, middle + 1, right);
/* Merge the two sorted parts */
Merge(array, left, middle, right);
}
}
/* Merge functions merges the two sorted parts */
void Merge(int *array, int left, int middle, int right)
{
/*to store sorted array*/
int tmp[right - left + 1];
int pos = 0, leftposition = left, rightposition = middle + 1;
while (leftposition <= middle && rightposition <= right)
{
if (array[leftposition] < array[rightposition])
{
tmp[pos++] = array[leftposition++];
}
else
{
tmp[pos++] = array[rightposition++];
}
}
while (leftposition <= middle)
tmp[pos++] = array[leftposition++];
while (rightposition <= right)
tmp[pos++] = array[rightposition++];
int i;
/* Copy back the sorted array to the original array */
for (i = 0; i < pos; i++)
{
array[i + left] = tmp[i];
}
return;
}
int main()
{
int size;
printf("\n enter the size of an array");
scanf("%d", &size);
int array[size];
int i, j, k;
printf("\n enter the array elements");
for (i = 0; i < size; i++)
{
scanf("%d", &array[i]);
}
/* Calling this functions sorts the array */
MergeSort(array, 0, size - 1);
for (i = 0; i < size; i++)
{
printf("%d ", array[i]);
}
printf("\n");
return 0;
}
 ETP 
 
C Program to Merge the Elements of 2 Sorted Array
================================ EOPN
    /*     * C Program to Merge the Elements of 2 Sorted Array     
================================ EOKW
--------------------------------
output:
Enter size of array Array 1: 4
 
Enter sorted elements of array 1:
12
18
40
60
 
Enter size of array 2: 4
 
Enter sorted elements of array 2:
47
56
89
90
 
After merging:
 
12
18
40
47
56
60
89
90
--------------------------------

#include <stdio.h>
void main()
{

int array1[50], array2[50], array3[100], m, n, i, j, k = 0;
printf("\n Enter size of array Array 1: ");
scanf("%d", &m);

printf("\n Enter sorted elements of array 1: \n");
for (i = 0; i < m; i++)
{
scanf("%d", &array1[i]);
}

printf("\n Enter size of array 2: ");
scanf("%d", &n);

printf("\n Enter sorted elements of array 2: \n");
for (i = 0; i < n; i++)
{
scanf("%d", &array2[i]);
}

i = 0;
j = 0;

while (i < m && j < n)
{
if (array1[i] < array2[j])
{
array3[k] = array1[i];
i++;
}

else
{
array3[k] = array2[j];
j++;
}
k++;
}

if (i >= m)
{
while (j < n)
{
array3[k] = array2[j];
j++;
k++;
}
}

if (j >= n)
{
while (i < m)
{
array3[k] = array1[i];
i++;
k++;
}
}

printf("\n After merging: \n");
for (i = 0; i < m + n; i++)
{
printf("\n%d", array3[i]);
}

}
 ETP 
 
C Program to Sort N Numbers in Ascending Order using Bubble Sort
================================ EOPN
/* * C program to sort N numbers in ascending order using Bubble sort * and print both the given and the sorted array 
================================ EOKW
--------------------------------
output:
 
$ cc pgm21.c
$ a.out
Enter the value of num
6
Enter the elements one by one
23
45
67
89
12
34
Input array is
23
45
67
89
12
34
Sorted array is...
12
23
34
45
67
89
--------------------------------
#include <stdio.h>
#define MAXSIZE 10

void main()
{
int array[MAXSIZE];
int i, j, num, temp;

printf("Enter the value of num \n");
scanf("%d", &num);
printf("Enter the elements one by one \n");
for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}
printf("Input array is \n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
/*   Bubble sorting begins */
for (i = 0; i < num; i++)
{
for (j = 0; j < (num - i - 1); j++)
{
if (array[j] > array[j + 1])
{
temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
}
}
}
printf("Sorted array is...\n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
}
 ETP 
 
 C Program to Split  an Array from Specified Position & Add First Part to the End 
================================ EOPN
     /*     * C program to read an array, accept a key & split the array.     * Add the first half to the end of second half.     
================================ EOKW
--------------------------------
output:
Enter the value of n
4
enter the numbers
3
678
345
876
Enter the position of the element to split the array
3
The resultant array is
876
3
678
345
--------------------------------

#include <stdio.h>
void main ()
{

int number[30];
int i, n, a, j;

printf("Enter the value of n\n");
scanf("%d", &n);

printf("enter the numbers\n");
for (i = 0; i < n; ++i)
scanf("%d", &number[i]);

printf("Enter the position of the element to split the array \n");
scanf("%d", &a);

for (i = 0; i < a; ++i)
{

number[n] = number[0];
for (j = 0; j < n; ++j)
{
number[j] = number[j + 1];
}

}

printf("The resultant array is\n");

for (i = 0; i < n; ++i)
{
printf("%d\n", number[i]);
}

}
 ETP 
 
 C Program to Accept an Array & Swap Elements using Pointers 
================================ EOPN
    /*     * C program to accept an array of 10 elements and swap 3rd element     * with 4th element using pointers and display the results.     
================================ EOKW
--------------------------------
output:
How many Elements...
4
Enter Elements one by one
23
67
45
15
 
Resultant Array...
X[0] = 23.000000
X[1] = 67.000000
X[2] = 15.000000
X[3] = 45.000000
--------------------------------

#include <stdio.h>
void swap34(float *ptr1, float *ptr2);
void main()
{

float x[10];
int i, n;

printf("How many Elements...\n");
scanf("%d", &n);

printf("Enter Elements one by one\n");
for (i = 0; i < n; i++)
{
scanf("%f", x + i);
}

/*  Function call:Interchanging 3rd element by 4th */

swap34(x + 2, x + 3);
printf("\nResultant Array...\n");

for (i = 0; i < n; i++)
{
printf("X[%d] = %f\n", i, x[i]);
}

}

/*  Function to swap the 3rd element with the 4th element in the array */

void swap34(float *ptr1, float *ptr2 )
{

float temp;
temp = *ptr1;
*ptr1 = *ptr2;
*ptr2 = temp;

}
 ETP 
 
 C Program to Read an Array and Search for an Element 
================================ EOPN
     /*     * C program accept an array of N elements and a key to search.     * If the search is successful, it displays "SUCCESSFUL SEARCH".     * Otherwise, a message "UNSUCCESSFUL SEARCH" is displayed.     
================================ EOKW
--------------------------------
output:
Enter the size of an array
4
Enter the array elements
90
560
300
390
Enter the key
90
SUCCESSFUL SEARCH
 
$ a.out
Enter the size of an array
4
Enter the array elements
100
500
580
470
Enter the key
300
UNSUCCESSFUL SEARCH
--------------------------------

#include <stdio.h>
void main()
{

int array[20];
int i, low, mid, high, key, size;

printf("Enter the size of an array\n");
scanf("%d", &size);

printf("Enter the array elements\n");
for (i = 0; i < size; i++)
{
scanf("%d", &array[i]);
}

printf("Enter the key\n");
scanf("%d", &key);

/*  search begins */

low = 0;
high = (size - 1);

while (low <= high)
{
mid = (low + high) / 2;

if (key == array[mid])
{
printf("SUCCESSFUL SEARCH\n");
return;
}

if (key < array[mid])
high = mid - 1;

else
low = mid + 1;

}

printf("UNSUCCESSFUL SEARCH\n");

}
 ETP 
 
C Program to accept Sorted Array and do Search using Binary Search 
================================ EOPN
/* * C program to accept N numbers sorted in ascending order * and to search for a given number using Binary Search. * Report success or failure. 
================================ EOKW
--------------------------------
output:
If the input array is {1, 2, 3, 4, 5, 6}
and the key to be searched for is 6
then the expected output will be "Search Successful".
--------------------------------
#include <stdio.h>

void main()
{
int array[10];
int i, j, num, temp, keynum;
int low, mid, high;
printf("Enter the value of num \n");
scanf("%d", &num);
printf("Enter the elements one by one \n");
for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}
printf("Input array elements \n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
/*  Bubble sorting begins */
for (i = 0; i < num; i++)
{
for (j = 0; j < (num - i - 1); j++)
{
if (array[j] > array[j + 1])
{
temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
}
}
}
printf("Sorted array is...\n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
printf("Enter the element to be searched \n");
scanf("%d", &keynum);
/*  Binary searching begins */
low = 1;
high = num;
do
{
mid = (low + high) / 2;
if (keynum < array[mid])
high = mid - 1;
else if (keynum > array[mid])
low = mid + 1;
} while (keynum != array[mid] && low <= high);
if (keynum == array[mid])
{
printf("SEARCH SUCCESSFUL \n");
}
else
{
printf("SEARCH FAILED \n");
}
}
 ETP 
 
C Program to find the Biggest Number in an Array of Numbers using Recursion
================================ EOPN
     /*     * C Program to find the Biggest Number in an Array of Numbers using      * Recursion     
================================ EOKW
--------------------------------
output:
Enter size of the list:8
Printing the list:
7   6   1   3   1   7   2   4
The largest number in the list is: 7
--------------------------------

#include <stdio.h>
int large(int[], int, int);

int main()
{

int size;
int largest;
int list[20];
int i;

printf("Enter size of the list:");
scanf("%d", &size);

printf("Printing the list:\n");
for (i = 0; i < size ; i++)
{
list[i] = rand() % size;
printf("%d \t", list[i]);
}

if (size == 0)
{
printf("Empty list\n");
}

else
{
largest = list[0];
largest = large(list, size - 1, largest);
printf("\nThe largest number in the list is: %d\n", largest);
}

}

int large(int list[], int position, int largest)
{

if (position == 0)
return largest;

if (position > 0)
{
if (list[position] > largest)
{
largest = list[position];
}
return large(list, position - 1, largest);
}

}
 ETP 
 
C Program to Implement a Queue using an Array
================================ EOPN
/* * C Program to Implement a Queue using an Array 
================================ EOKW
--------------------------------
output:
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 10
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 15
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 20
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 30
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 2
Element deleted from queue is : 10
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 3
Queue is :
15 20 30
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 4
--------------------------------
#include <stdio.h>

#define MAX 50

void insert();
void delete();
void display();
int queue_array[MAX];
int rear = - 1;
int front = - 1;
main()
{
int choice;
while (1)
{
printf("1.Insert element to queue \n");
printf("2.Delete element from queue \n");
printf("3.Display all elements of queue \n");
printf("4.Quit \n");
printf("Enter your choice : ");
scanf("%d", &choice);
switch (choice)
{
case 1:
insert();
break;
case 2:
delete();
break;
case 3:
display();
break;
case 4:
exit(1);
default:
printf("Wrong choice \n");
} /* End of switch */
} /* End of while */
} /* End of main() */

void insert()
{
int add_item;
if (rear == MAX - 1)
printf("Queue Overflow \n");
else
{
if (front == - 1)
/*If queue is initially empty */
front = 0;
printf("Inset the element in queue : ");
scanf("%d", &add_item);
rear = rear + 1;
queue_array[rear] = add_item;
}
} /* End of insert() */

void delete()
{
if (front == - 1 || front > rear)
{
printf("Queue Underflow \n");
return ;
}
else
{
printf("Element deleted from queue is : %d\n", queue_array[front]);
front = front + 1;
}
} /* End of delete() */

void display()
{
int i;
if (front == - 1)
printf("Queue is empty \n");
else
{
printf("Queue is : \n");
for (i = front; i <= rear; i++)
printf("%d ", queue_array[i]);
printf("\n");
}
} /* End of display() */
 ETP 
 
C Program to Implement two Stacks using a Single Array & Check for Overflow & Underflow
================================ EOPN
//This is a C Program to Implement two Stacks using a Single Array & Check for Overflow & Underflow#include <stdio.h>#define SIZE 10  int ar[SIZE];int top1 = -1;int top2 = SIZE; //Functions to push datavoid push_stack1 (int data){  if (top1 < top2 - 1)  {    ar[++top1] = data;  }  else  {    printf ("Stack Full! Cannot Push\n");  }}void push_stack2 (int data){  if (top1 < top2 - 1)  {    ar[--top2] = data;   }  else  {    printf ("Stack Full! Cannot Push\n");  }} //Functions to pop datavoid pop_stack1 (){  if (top1 >= 0)  {    int popped_value = ar[top1--];    printf ("%d is being popped from Stack 1\n", popped_value);  }  else  {    printf ("Stack Empty! Cannot Pop\n");  }}void pop_stack2 (){  if (top2 < SIZE)  {    int popped_value = ar[top2++];    printf ("%d is being popped from Stack 2\n", popped_value);  }  else  {    printf ("Stack Empty! Cannot Pop\n");  }} //Functions to Print Stack 1 and Stack 2void print_stack1 (){  int i;  for (i = top1; i >= 0; --i)  {    printf ("%d ", ar[i]);  }  printf ("\n");}void print_stack2 (){  int i;  for (i = top2; i < SIZE; ++i)  {    printf ("%d ", ar[i]);  }  printf ("\n");} int main(){  int ar[SIZE];  int i;  int num_of_ele;   printf ("We can push a total of 10 values\n");   //Number of elements pushed in stack 1 is 6  //Number of elements pushed in stack 2 is 4   for (i = 1; i <= 6; ++i)  {    push_stack1 (i);    printf ("Value Pushed in Stack 1 is %d\n", i);  }  for (i = 1; i <= 4; ++i)  {    push_stack2 (i);    printf ("Value Pushed in Stack 2 is %d\n", i);  }   //Print Both Stacks  print_stack1 ();  print_stack2 ();   //Pushing on Stack Full  printf ("Pushing Value in Stack 1 is %d\n", 11);  push_stack1 (11);   //Popping All Elements From Stack 1  num_of_ele = top1 + 1;  while (num_of_ele)  {    pop_stack1 ();    --num_of_ele;  }   //Trying to Pop From Empty Stack  pop_stack1 ();   return 0;}
================================ EOKW
--------------------------------
output:
gcc TwoStacksSingleArray.c
./a.out
We can push a total of 10 values
Value Pushed in Stack 1 is 1
Value Pushed in Stack 1 is 2
Value Pushed in Stack 1 is 3
Value Pushed in Stack 1 is 4
Value Pushed in Stack 1 is 5
Value Pushed in Stack 1 is 6
Value Pushed in Stack 2 is 1
Value Pushed in Stack 2 is 2
Value Pushed in Stack 2 is 3
Value Pushed in Stack 2 is 4
6 5 4 3 2 1 
4 3 2 1 
Pushing Value in Stack 1 is 11
Stack Full! Cannot Push
6 is being popped from Stack 1
5 is being popped from Stack 1
4 is being popped from Stack 1
3 is being popped from Stack 1
2 is being popped from Stack 1
1 is being popped from Stack 1
Stack Empty! Cannot Pop
--------------------------------
 ETP 
 
C Program to Generate Pascal Triangle 1 D Array
================================ EOPN
/* * C Program to Generate Pascal Triangle 1 D Array 
================================ EOKW
--------------------------------
output:
$ cc pgm69.c
$ a.out
Enter the number of lines to be printed: 4
     1
   1  1
 1  2  1
1  3  3  1
--------------------------------
#include <stdio.h>

void main()
{
int array[30], temp[30], i, j, k, l, num;           //using 2 arrays

printf("Enter the number of lines to be printed: ");
scanf("%d", &num);
temp[0] = 1;
array[0] = 1;
for (j = 0; j < num; j++)
printf(" ");
printf(" 1\n");
for (i = 1; i < num; i++)
{
for (j = 0; j < i; j++)
printf(" ");
for (k = 1; k < num; k++)
{
array[k] = temp[k - 1] + temp[k];
}
array[i] = 1;
for (l = 0; l <= i; l++)
{
printf("%3d", array[l]);
temp[l] = array[l];
}
printf("\n");
}
}
 ETP 
 
C Program to Print the Number of Odd & Even Numbers in an Array
================================ EOPN
    /*     * C Program to Print the Number of Odd & Even Numbers in an Array     
================================ EOKW
--------------------------------
output:
Enter the size of an array
6
Enter the elements of the array
12
19
45
69
98
23
Even numbers in the array are - 12     98
 Odd numbers in the array are - 19     45     69     23
--------------------------------

#include <stdio.h>
void main()
{

int array[100], i, num;
printf("Enter the size of an array \n");

scanf("%d", &num);
printf("Enter the elements of the array \n");

for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}

printf("Even numbers in the array are - ");
for (i = 0; i < num; i++)
{
if (array[i] % 2 == 0)
{
printf("%d \t", array[i]);
}
}

printf("\n Odd numbers in the array are -");
for (i = 0; i < num; i++)
{
if (array[i] % 2 != 0)
{
printf("%d \t", array[i]);
}
}

}
 ETP 
 
C Program to Print All the Repeated Numbers with Frequency in an Array
================================ EOPN
/*
 * C Program to Print all the Repeated Numbers with Frequency in an Array
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm71.c
$ a.out
 duplicate elements present in the given array are  10  2
--------------------------------

#include <stdio.h>
#include <malloc.h>
 
void duplicate(int array[], int num)
{
    int *count = (int *)calloc(sizeof(int), (num - 2));
    int i;
 
    printf("duplicate elements present in the given array are ");
    for (i = 0; i < num; i++)
    {
        if (count[array[i]] == 1)
            printf(" %d ", array[i]);
        else
            count[array[i]]++;
    }
}
 
int main()
{
    int array[] = {5, 10, 10, 2, 1, 4, 2};
    int array_freq = sizeof(array) / sizeof(array[0]);
    duplicate(array, array_freq);
    getchar();
    return 0;
}
 ETP 
 
C Program to Print the kth Element in the Array
================================ EOPN
/*
 * C Program to Print all the Repeated Numbers with Frequency in an Array
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm71.c
$ a.out
 duplicate elements present in the given array are  10  2
--------------------------------

#include <stdio.h>
#include <malloc.h>
 
void duplicate(int array[], int num)
{
    int *count = (int *)calloc(sizeof(int), (num - 2));
    int i;
 
    printf("duplicate elements present in the given array are ");
    for (i = 0; i < num; i++)
    {
        if (count[array[i]] == 1)
            printf(" %d ", array[i]);
        else
            count[array[i]]++;
    }
}
 
int main()
{
    int array[] = {5, 10, 10, 2, 1, 4, 2};
    int array_freq = sizeof(array) / sizeof(array[0]);
    duplicate(array, array_freq);
    getchar();
    return 0;
}
 ETP 
 
C Program to Find the Number of Elements in an Array
================================ EOPN
     /*     * C Program to Find the Number of Elements in an Array     
================================ EOKW
--------------------------------
output:
Size of the given array is 7
--------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
int array[] = {15, 50, 34, 20, 10, 79, 100};
int n;
n = sizeof(array);
printf("Size of the given array is %d\n", n/sizeof(int));
return 0;
}
 ETP 
 
C Program to Check Array bounds while Inputing Elements into the Array
================================ EOPN
    /*     * C Program to Check Array bounds while Inputing Elements into the Array     
================================ EOKW
--------------------------------
output:
12
23
56
12
14
23
12 23 56 12 14 23 6 134513824 0 -1081194040 11672807 1 -1081193996 -1081193988 -1216161720
--------------------------------

#include <stdio.h>
int main(void)
{

int array[5], b, c;
for (b = 0; b < 10 && (scanf("%d", &c)); b++)
array[b] = c;

for (b = 0; b < 15; b++)
printf("%d ", array[b]);

return 0;
}
 ETP 
 
C Program to Print the Alternate Elements in an Array
================================ EOPN
     /*     * C Program to Print the Alternate Elements in an Array     
================================ EOKW
--------------------------------
output:
12
23
45
57
68
73
84
97
120
125
Alternate elements of a given array
12
45
68
84
120
--------------------------------

#include <stdio.h>
void main()
{

int array[10];
int i;
printf("enter the element of an array \n");
for (i = 0; i < 10; i++)
scanf("%d", &array[i]);

printf("Alternate elements of a given array \n");
for (i = 0; i < 10; i += 2)
printf( "%d\n", array[i]) ;
}
 ETP 
 
C Program to Find the Odd Element given an Array with only two Different Element
================================ EOPN
/*
 * C Program to Find the Odd Element given an Array with only two Different Element
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm87.c
$ a.out
 
 The ODD elements are 7 & 3
--------------------------------

#include <stdio.h>
 
void printodd(int array[], int size)
{
    int xor2 = array[0]; /* Will hold XOR of two odd occurring elements 
 ETP 
 
C Program to Increment Every Element of the Array by One & Print Incremented Array
================================ EOPN
     /*     * C Program to Increment every Element of the Array by one & Print Incremented Array     
================================ EOKW
--------------------------------
output:
11    21    31   41
--------------------------------

#include <stdio.h>
void incrementArray(int[]);
void main()
{

int i;
int array[4] = {10, 20, 30, 40};
incrementArray(array);
for (i = 0; i < 4; i++)
printf("%d\t", array[i]);   // Prints 2, 3, 4, 5

}

void incrementArray(int arr[])
{

int i;
for (i = 0; i < 4; i++)
arr[i]++;     // this alters values in array in main()

}
 ETP 
 
C Program to Find the Number of Non Repeated Elements in an Array
================================ EOPN
/*
 * C Program to Find the Number of Non Repeated Elements in an Array
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm76.c
$ a.out
 
Enter size of the array: 6
 
Enter 6 elements of an array: 12
10
4
10
12
56
 
The array after removing duplicates is:  12 10 4 56
--------------------------------

#include <stdio.h>
int main()
{
    int array[50];
    int *ptr;
    int i, j, k, size, n;
 
    printf("\n Enter size of the array: ");
    scanf("%d", &n);
    printf("\n Enter %d elements of an array: ", n);
    for (i = 0; i < n; i++)
    scanf("%d", &array[i]);
    size = n;
    ptr = array;
    for (i = 0; i < size; i++)
    {
        for (j = 0; j < size; j++)
        {
            if (i == j)
            {
                continue;
            }
            else if (*(ptr + i) == *(ptr + j))
            {
                k = j;
                size--;
                while (k < size)
                {
                    *(ptr + k) = *(ptr + k + 1);
                    k++;
                }
                j = 0;
            }
        }
    }
    printf("\n The array after removing duplicates is: ");
    for (i = 0; i < size; i++)
    {
        printf(" %d", array[i]);
    }
    return 0;
}
 ETP 
 
C Program to identify missing Numbers in a given Array
================================ EOPN
/*  * C Program to identify missing numbers in a given array 
================================ EOKW
--------------------------------
output:
$ cc bit30.c
$ a.out
Enter size of array : 6
Enter elements into array : 
1
2
3
5
6
Missing element is : 4
--------------------------------
#include <stdio.h>

void main()
{
int n, i, j, c, t, b;

printf("Enter size of array : ");
scanf("%d", &n);
int array[n - 1];     /* array size-1 */
printf("Enter elements into array : \n");
for (i = 0; i < n - 1; i++)
scanf("%d", &array[i]);
b = array[0];
for (i = 1; i < n - 1; i++)
b = b ^ array[i];
for (i = 2, c = 1; i <= n; i++)
c = c ^ i;
c = c ^ b;
printf("Missing element is : %d \n", c);
}
 ETP 
 
C Program to Segregate 0s on Left Side & 1s on right side of the Array
================================ EOPN
/* * C Program to Segregate 0s on Left Side & 1s on right side of the Array (Traverse Array only once) 
================================ EOKW
--------------------------------
output:
$ cc pgm96.c
$ a.out
segregated array is 0 0 0 1 1 1
--------------------------------
#include <stdio.h>

/*Function to segregate all 0s on left and all 1s on right*/
void segregate0and1(int array[], int size)
{
int left = 0, right = size-1;

while (left < right)
{
/* Increment left index while we see 0 at left */
while (array[left] == 0 && left < right)
left++;
/* Decrement right index while we see 1 at right */
while (array[right] == 1 && left < right)
right--;
/* If left is smaller than right then there is a 1 at left and a 0 at right.  Exchange it */
if (left < right)
{
array[left] = 0;
array[right] = 1;
left++;
right--;
}
}
}

int main()
{
int arr[] = {0, 1, 0, 1, 1, 0};
int array_size = 6, i = 0;

segregate0and1(arr, array_size);
printf("segregated array is ");
for (i = 0; i < 6; i++)
printf("%d ", arr[i]);
getchar();
return 0;
}
 ETP 
 
C Program to Find 2 Elements in the Array such that Difference between them is Largest
================================ EOPN
/* * C Program to Find 2 Elements in the Array such that Difference between them is Largest 
================================ EOKW
--------------------------------
output:
$ cc pgm97.c
$ a.out
Maximum difference is 190
--------------------------------
#include <stdio.h>

int maximum_difference(int array[], int arr_size)
{
int max_diff = array[1] - array[0];
int i, j;
for (i = 0; i < arr_size; i++)
{
for (j = i + 1; j < arr_size; j++)
{
if (array[j] - array[i] > max_diff)
max_diff = array[j] - array[i];
}
}
return max_diff;
}

int main()
{
int array[] = {10, 15, 90, 200, 110};
printf("Maximum difference is %d",  maximum_difference(array, 5));
getchar();
return 0;
}
 ETP 
 
C Program to Input a String & Store their Ascii Values in an Integer Array & Print the Array
================================ EOPN
    /*     * C Program to Input a String & Store their Ascii Values in an Integer Array & Print the Array     
================================ EOKW
--------------------------------
output:
Enter the no of characters present in an array
10
Enter the string of 10 characters
sanfoundry
 s = 115
 a = 97
 n = 110
 f = 102
 o = 111
 u = 117
 n = 110
 d = 100
 r = 114
 y = 121
--------------------------------

#include <stdio.h>
void main()
{

char string[20];
int n, count = 0;

printf("Enter the no of characters present in an array \n ");
scanf("%d", &n);

printf(" Enter the string of %d characters \n" , n);
scanf("%s", string);

while (count < n)
{
printf(" %c = %d\n", string[count], string[count] );
++ count ;
}

}
 ETP 
 
C Program to Input an Array, Store the Squares of these Elements in an Array & Print it
================================ EOPN
    /*     * C Program to Input an Array, Store the Squares of these Elements in an Array & Print it     
================================ EOKW
--------------------------------
output:
100    400    900    1600
2500   3600   4900   6400
8100   10000  12100  14400
--------------------------------

#include <stdio.h>
#define MAX_ROWS 3
#define MAX_COLS 4

void print_square(int [ ] );
void main (void)
{

int i;
int num [MAX_ROWS][MAX_COLS] = { {10, 20, 30, 40}, {50, 60, 70, 80}, {90, 100, 110, 120} };
for (i = 0; i < MAX_ROWS; i++)
print_square(num[i]);

}

void print_square(int x[ ])
{

int j;
for (j = 0; j < MAX_COLS; j++)
printf ("%d\t", x[j] * x[j]);
printf("\n");

}
 ETP 
 
C Program to Find the two Elements such that their Sum is Closest to Zero
================================ EOPN
 /* * C Program to Find the two Elements such that their Sum is Closest to Zero 
================================ EOKW
--------------------------------
output:
 The two elements whose sum is minimum are 15 and -10
--------------------------------
# include <stdio.h>
# include <stdlib.h>
# include <math.h>

void minabsvaluepair(int array[], int array_size)
{
int count = 0;
int l, r, min_sum, sum, min_l, min_r;

/* Array should have at least two elements*/
if (array_size < 2)
{
printf("Invalid Input");
return;
}

/* Initialization of values */
min_l = 0;
min_r = 1;
min_sum = array[0] + array[1];
for (l = 0; l < array_size - 1; l++)
{
for (r = l + 1; r < array_size; r++)
{
sum = array[l] + array[r];
if (abs(min_sum) > abs(sum))
{
min_sum = sum;
min_l = l;
min_r = r;
}
}
}
printf(" The two elements whose sum is minimum are %d and %d", array[min_l], array[min_r]);
}

int main()
{
int array[] = {42, 15, -25, 30, -10, 35};
minabsvaluepair(array, 6);
getchar();
return 0;
}
 ETP 
 
C Program to Find if a given Integer X appears more than N/2 times in a Sorted Array of N Integers
================================ EOPN
/* * C Program to Find if a given Integer X appears more than N/2 times in a Sorted Array of N Integers 
================================ EOKW
--------------------------------
output:
$ cc pgm95.c
$ a.out
The given no 15 appears more than 3 times in array[]
--------------------------------
# include <stdio.h>
# define bool int

bool Morenooftimes(int array[], int n, int x)
{
int i;
int final_index = n % 2 ? n / 2 : (n / 2 + 1);

for (i = 0; i < final_index; i++)
{
/* check if x is presents more than n/2 times */
if (array[i] == x && array[i + n / 2] == x)
return 1;
}
return 0;
}

int main()
{
int array[] = {10, 15, 15, 12, 17 ,15};
int n = sizeof(array) / sizeof(array[0]);
int x = 15;
if (Morenooftimes(array, n, x))
printf("The given no %d appears more than %d times in array[]", x, n/2);
else
printf("The given no %d does not appear more than %d times in array[]", x, n/2);
getchar();
return 0;
}
 ETP 
 
C Program to Find the Median of the Elements after Merging these 2 Sorted Arrays with Same Size
================================ EOPN
/*
 * C Program to Find the Median of the Elements after Merging these 2 Sorted Arrays with Same Size
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm91.c
$ a.out
Median is 34
--------------------------------

#include <stdio.h>
 
int getMedian(int array1[], int array2[], int n)
{
    int i = 0;  /* Current index of i/p array array1[] 
 ETP 
 
C Program to Find Union & Intersection of 2 Arrays
================================ EOPN
/* * C Program to Find Union & Intersection of 2 Arrays 
================================ EOKW
--------------------------------
output:
$ cc pgm98.c
$ a.out
 
Enter the elements of Array 1:
 
Enter element 1: 12
 
Enter element 2: 34
 
Enter element 3: 23
 
Enter element 4: 56
 
Enter element 5: 45
 
 
Elements of Array 1: { 12 34 23 56 45 }
 
Sorted elements of Array 1: { 12 23 34 45 56 }
 
Enter the elements of Array 2:
 
Enter element 1: 34
 
Enter element 2: 56
 
Enter element 3: 12
 
Enter element 4: 78
 
Enter element 5: 66
 
 
Elements of Array 2: { 34 56 12 78 66 }
 
Sorted elements of Array 2: { 12 34 56 66 78 }
 
Intersection is: { 12 34 56 }
 
Union is: { 12 23 34 45 56 66 78 }
--------------------------------
#include <stdio.h>
#define SIZE 5

void get_value(int arr[]);
void print_value(int arr[], int n);
void function_sort(int arr[]);
int find_intersection(int array1[], int array2[], int intersection_array[]);
int find_union(int array1[], int array2[], int union_array[]);

void main()
{
int array1[SIZE], array2[SIZE], intersection_array[SIZE], union_array[SIZE*2];
int num_elements;

//input elements of Array1
printf("\n Enter the elements of Array 1: n");
get_value(array1);
printf("\n\n Elements of Array 1: ");
print_value(array1, SIZE);

//Sort array 1
function_sort(array1);
printf("nnSorted elements of Array 1: ");
print_value(array1, SIZE);

//input elements of Array2
printf("nnEnter the elements of Array 2: n");
get_value(array2);
printf("\n\n Elements of Array 2: ");
print_value(array2, SIZE);

//Sort array 2
function_sort(array2);
printf("\n\nSorted elements of Array 2: ");
print_value(array2, SIZE);

//Find Intersection
num_elements = find_intersection(array1, array2, intersection_array);
printf("\n\n Intersection is: ");
print_value(intersection_array, num_elements);

//Find Union
num_elements = find_union(array1, array2, union_array);
printf("\n\n Union is: ");
print_value(union_array, num_elements);
}

void get_value(int arr[])
{
int i, j;
for (i = 0; i < SIZE; i++)
{
j = i + 1;
printf("\n Enter element %d: ", j);
scanf("%d", &arr[i]);
}
}

void print_value(int arr[], int n)
{
int i;
printf("{ ");
for (i = 0; i < n; i++)
{
printf("%d ", arr[i]);
}
printf("}");
}

void function_sort(int arr[])
{
int i, j, temp, swapping;

for (i = 1; i < size; i++)
{
swapping = 0;
for (j = 0; j < size-i; j++)
{
if (arr[j] > arr[j+1])
{
temp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = temp;
swapping = 1;
}
}
if (swapping == 0)
{
break;
}
}
}

int find_intersection(int array1[], int array2[], int intersection_array[])
{
int i = 0, j = 0, k = 0;
while ((i < size) && (j < size))
{
if (array1[i] < array2[j])
{
i++;
}
else if (array1[i] > array2[j])
{
j++;
}
else
{
intersection_array[k] = array1[i];
i++;
j++;
k++;
}
}
return(k);
}

int find_union(int array1[], int array2[], int union_array[])
{
int i = 0, j = 0, k = 0;
while ((i < SIZE) && (j < SIZE))
{
if (array1[i] < array2[j])
{
union_array[k] = array1[i];
i++;
k++;
}
else if (array1[i] > array2[j])
{
union_array[k] = array2[j];
j++;
k++;
}
else
{
union_array[k] = array1[i];
i++;
j++;
k++;
}
}
if (i == SIZE)
{
while (j < SIZE)
{
union_array[k] = array2[j];
j++;
k++;
}
}
else
{
while (i < SIZE)
{
union_array[k] = array1[i];
i++;
k++;
}
}
return(k);
}
 ETP 
 
C Program to Find Ceiling & Floor of  X given a Sorted Array & a value X
================================ EOPN
/* * C Program to Find Ceiling & Floor of  X given a Sorted Array & a value X 
================================ EOKW
--------------------------------
output:
$ cc pgm99.c
$ a.out
ceiling of 3 is 8
--------------------------------
#include <stdio.h>

/* Function to get index of ceiling of x in arr[low..high] */
int ceilSearch(int arr[], int low, int high, int x)
{
int i;

/* If x is smaller than or equal to first element,then return the first element */
if (x <= arr[low])
return low;

/* Otherwise, linearly search for ceil value */
for (i = low; i < high; i++)
{
if (arr[i] == x)
return i;

/* if x lies between arr[i] and arr[i+1] including arr[i+1], then return arr[i+1] */
if (arr[i] < x && arr[i + 1] >= x)
return i + 1;
}

/* If we reach here then x is greater than the last element of the array,  return -1 in this case */
return -1;
}

int main()
{
int arr[] = {1, 2, 8, 10, 10, 12, 19};
int n = sizeof(arr)/sizeof(arr[0]);
int x = 3;
int index = ceilSearch(arr, 0, n-1, x);
if (index == -1)
printf("Ceiling of %d doesn't exist in array ", x);
else
printf("ceiling of %d is %d", x, arr[index]);
getchar();
return 0;
}
 ETP 
 
C Program to Find the Summation of Node values at Row or Level
================================ EOPN
/** C Program to Find the Summation of Node values at level/row and print it
================================ EOKW
--------------------------------
output:
$ cc tree43.c
$ a.out
 
 OPERATIONS ---
 1] Insert an element into tree
 2] Display the sum of the elements at the same level
 3] Exit 
 Enter your choice : 1
 Enter the data of node : 40
 
 Enter your choice : 1
 Enter the data of node : 20
 
 Enter your choice : 1
 Enter the data of node : 60
 
 Enter your choice : 1
 Enter the data of node : 10
 
 Enter your choice : 1
 Enter the data of node : 30
 
 Enter your choice : 1
 Enter the data of node : 80
 
 Enter your choice : 1
 Enter the data of node : 90
 
 Enter your choice : 2
 Sum of nodes : 
  Level      Sum 
   0     : 40 
   1     : 80 
   2     : 120 
   3     : 90 
 Enter your choice : 3
 
                40
                /\
               /  \
             20    60
             / \    \
           10  30   80
                     \
                     90 
 
 $ ./a.out
 
 OPERATIONS ---
 1] Insert an element into tree
 2] Display the sum of the elements at the same level
 3] Exit 
 Enter your choice : 1
 Enter the data of node : 50
 
 Enter your choice : 1
 Enter the data of node : 30
 
 Enter your choice : 1
 Enter the data of node : 20
 
 Enter your choice : 1
 Enter the data of node : 40
 
 Enter your choice : 1
 Enter the data of node : 35
 
 Enter your choice : 1
 Enter the data of node : 100
 
 Enter your choice : 1
 Enter the data of node : 70
 
 Enter your choice : 1
 Enter the data of node : 120
 
 Enter your choice : 1
 Enter the data of node : 140
 
 Enter your choice : 2
 Sum of nodes : 
 Level      Sum 
   0      : 50 
   1      : 130 
   2      : 250 
   3      : 175 
Enter your choice : 3
 
 
 
                50
                /\
               /  \
             30    100
             / \   / \
           20  40 70 120
               /       \
              35       140
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *r,*l;
}*root = NULL, *temp = NULL;

void create();
void insert();
void add(struct btnode *t);
void computesum(struct btnode *t);
void display();

int count = 0, sum[100] = {0}, max = 0;

void main()
{
int ch;

printf("\n OPERATIONS ---");
printf("\n 1] Insert an element into tree");
printf("\n 2] Display the sum of the elements at the same level");
printf("\n 3] Exit ");
while (1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
insert();
break;
case 2:
count = 0;
max = 0;
computesum(root);
display();
break;
case 3:
exit(0);
default :
printf("Wrong choice, Please enter correct choice  ");
break;
}
}
}

/* To create a new node with the data from the user */
void create()
{
int data;

printf("Enter the data of node : ");
scanf("%d", &data);
temp = (struct btnode* ) malloc(1*(sizeof(struct btnode)));
temp->value = data;
temp->l = temp->r = NULL;
}

/* To check for root node and then create it */
void insert()
{
create();

if (root == NULL)
root = temp;
else
add(root);
}

/* Search for the appropriate position to insert the new node */
void add(struct btnode *t)
{
if ((temp->value > t->value) && (t->r != NULL))        /* value more than root node value insert at right */
add(t->r);
else if ((temp->value > t->value) && (t->r == NULL))
t->r = temp;
else if ((temp->value < t->value) && (t->l != NULL))        /* value less than root node value insert at left */
add(t->l);
else if ((temp->value < t->value) && (t->l==NULL))
t->l = temp;
}

/* Function to find the sum of nodes at same distance */
void computesum(struct btnode *t)
{
if (root == NULL)
{
printf("Tree is empty ");
return;
}
if (t->l != NULL)
{
count++;
computesum(t->l);
}
sum[count] = sum[count] + t->value;  /* addition of elelment by row wise */
if (max < count)
max = count;
if (t->r != NULL)
{
count++;
computesum(t->r);
}
count--;
}

/* To display the sum of the nodes at the same distance */
void display()
{
int i;

printf("Sum of nodes : \n Level \t Sum ");
for (i = 0; i <= max; i++)
printf("\n %d \t: %d ", i, sum[i]);
}
 ETP 
 
 C Program to Calculate the Addition or Subtraction & Trace of 2 Matrices 
================================ EOPN
    /*     * C program to read two matrices A(MxN) and B(MxN) and perform addition     * OR subtraction of A and B. Also, find the trace of the resultant     * matrix. Display the given matrices, their sum or differences and     * the trace.     
================================ EOKW
--------------------------------
output:
 
Enter the order of the matrix array1 and array2
3 3
Enter the elements of matrix array1
2 3 4
7 8 9
5 6 8
MATRIX array1 is
  2  3  4
  7  8  9
  5  6  8
Enter the elements of matrix array2
3 3 3
3 4 6
8 4 7
MATRIX array2 is
  3  3  3
  3  4  6
  8  4  7
Enter your option: 1 for Addition and 2 for Subtraction
1
Sum matrix is
  5  6  7
 10 12 15
 13 10 15
Trace of the resultant matrix is = 32
 
$ a.out
Enter the order of the matrix array1 and array2
3 3
Enter the elements of matrix array1
10 20 30
15 18 20
12 14 16
MATRIX array1 is
 10 20 30
 15 18 20
 12 14 16
Enter the elements of matrix array2
1 5 9
10 15 14
9 12 13
MATRIX array2 is
  1  5  9
 10 15 14
  9 12 13
Enter your option: 1 for Addition and 2 for Subtraction
2
Difference matrix is
  9 15 21
  5  3  6
  3  2  3
Trace of the resultant matrix is = 15
--------------------------------

#include <stdio.h>
void trace(int arr[][10], int m, int n);
void main()
{

int array1[10][10], array2[10][10], arraysum[10][10],
arraydiff[10][10];
int i, j, m, n, option;

printf("Enter the order of the matrix array1 and array2 \n");
scanf("%d %d", &m, &n);

printf("Enter the elements of matrix array1 \n");
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
scanf("%d", &array1[i][j]);
}
}

printf("MATRIX array1 is \n");
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
printf("%3d", array1[i][j]);
}
printf("\n");
}

printf("Enter the elements of matrix array2 \n");
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
scanf("%d", &array2[i][j]);
}
}

printf("MATRIX array2 is \n");
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
printf("%3d", array2[i][j]);
}
printf("\n");
}

printf("Enter your option: 1 for Addition and 2 for Subtraction \n");
scanf("%d", &option);

switch (option)
{

case 1:
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
arraysum[i][j] = array1[i][j] + array2[i][j];
}
}

printf("Sum matrix is \n");
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
printf("%3d", arraysum[i][j]) ;
}
printf("\n");
}

trace (arraysum, m, n);
break;

case 2:
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
arraydiff[i][j] = array1[i][j] - array2[i][j];
}
}

printf("Difference matrix is \n");
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
printf("%3d", arraydiff[i][j]) ;
}
printf("\n");
}
trace (arraydiff, m, n);
break;
}

}

/*  Function to find the trace of a given matrix and print it */

void trace (int arr[][10], int m, int n)
{

int i, j, trace = 0;
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
if (i == j)
{
trace = trace + arr[i][j];
}
}
}
printf("Trace of the resultant matrix is = %d\n", trace);
}
 ETP 
 
 C Program to Find the Transpose of a given Matrix  
================================ EOPN
/*
 * C program to accept a matrix of order MxN and find its transpose
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm85.c
$ a.out
Enter the order of the matrix
3 3
Enter the coefiicients of the matrix
3 7 9
2 7 5
6 3 4
The given matrix is
 3 7 9
 2 7 5
 6 3 4
Transpose of matrix is
 3 2 6
 7 7 3
 9 5 4
--------------------------------

#include <stdio.h>
 
void main()
{
    static int array[10][10];
    int i, j, m, n;
 
    printf("Enter the order of the matrix \n");
    scanf("%d %d", &m, &n);
    printf("Enter the coefiicients of the matrix\n");
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            scanf("%d", &array[i][j]);
        }
    }
    printf("The given matrix is \n");
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            printf(" %d", array[i][j]);
        }
        printf("\n");
    }
    printf("Transpose of matrix is \n");
    for (j = 0; j < n; ++j)
    {
        for (i = 0; i < m; ++i)
        {
            printf(" %d", array[i][j]);
        }
        printf("\n");
    }
}
 ETP 
 
 C Program to Compute the Product of Two Matrices 
================================ EOPN
     /*     * Develop functions to read a matrix, display a matrix and compute     * product of two matrices.     * Use these functions to read two MxN matrices and compute their     * product & display the result     
================================ EOKW
--------------------------------
output:
Enter the value of m and n
3 3
Enter matrix array1
4 5 6
1 2 3
3 7 8
Matrix array1
  4  5  6
  1  2  3
  3  7  8
Enter matrix array2
5 6 9
8 5 3
2 9 1
Matrix array2
  5  6  9
  8  5  3
  2  9  1
The product matrix is
 72103 57
 27 43 18
 87125 56
--------------------------------

#include <stdio.h>
#define MAXROWS 10
#define MAXCOLS 10

void readMatrix(int arr[][MAXCOLS], int m, int n);
void printMatrix(int arr[][MAXCOLS], int m, int n);
void productMatrix(int array1[][MAXCOLS], int array2[][MAXCOLS],
int array3[][MAXCOLS], int m, int n);

void main()
{

int array1[MAXROWS][MAXCOLS], array2[MAXROWS][MAXCOLS],
array3[MAXROWS][MAXCOLS];
int m, n;

printf("Enter the value of m and n \n");
scanf("%d %d", &m, &n);

printf("Enter Matrix array1 \n");
readMatrix(array1, m, n);
printf("Matrix array1 \n");
printMatrix(array1, m, n);

printf("Enter Matrix array2 \n");
readMatrix(array2, m, n);
printf("Matrix B \n");
printMatrix(array2, m, n);

productMatrix(array1, array2, array3, m, n);
printf("The product matrix is \n");
printMatrix(array3, m, n);

}

/*  Input Matrix array1 */

void readMatrix(int arr[][MAXCOLS], int m, int n)
{

int i, j;
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
scanf("%d", &arr[i][j]);
}
}
}

void printMatrix(int arr[][MAXCOLS], int m, int n)
{

int i, j;
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
printf("%3d", arr[i][j]);
}
printf("\n");
}
}

/*  Multiplication of matrices */

void productMatrix(int array1[][MAXCOLS], int array2[][MAXCOLS],
int array3[][MAXCOLS], int m, int n)
{

int i, j, k;
for (i = 0; i < m; i++)
{
for (j = 0; j < n; j++)
{
array3[i][j] = 0;
for (k = 0; k < n; k++)
{
array3[i][j] = array3[i][j] + array1[i][k] * array2[k][j];
}
}
}
}
 ETP 
 
 C Program to Calculate the Sum & Difference of the Matrices   
================================ EOPN
    /*     * C program to accept two matrices and find the sum     * and difference of the matrices     
================================ EOKW
--------------------------------
output:
Enter the order of the matrix A
3 3
Enter the order of the matrix B
3 3
Enter the elements of matrix A
1 4 5
6 7 8
4 8 9
MATRIX A is
  1  4  5
  6  7  8
  4  8  9
Enter the elements of matrix B
3 6 7
8 4 2
1 5 3
MATRIX B is
  3  6  7
  8  4  2
  1  5  3
Sum matrix is
  4 10 12
 14 11 10
  5 13 12
Difference matrix is
 -2 -2 -2
 -2  3  6
  3  3  6
--------------------------------

#include <stdio.h>
#include <stdlib.h>

void readmatA();
void printmatA();
void readmatB();
void printmatB();

void sum();
void diff();

int a[10][10], b[10][10], sumarray[10][10], arraydiff[10][10];
int i, j, row1, column1, row2, column2;

void main()
{

printf("Enter the order of the matrix A \n");
scanf("%d %d", &row1, &column1);

printf("Enter the order of the matrix B \n");
scanf("%d %d", &row2, &column2);

if (row1 != row2 && column1 != column2)
{
printf("Addition and subtraction are possible \n");
exit(1);
}

else
{

printf("Enter the elements of matrix A \n");
readmatA();

printf("MATRIX A is \n");
printmatA();

printf("Enter the elements of matrix B \n");
readmatB();

printf("MATRIX B is \n");
printmatB();

sum();
diff();

}

}

/*  Function to read a matrix A */

void readmatA()
{
for (i = 0; i < row1; i++)
{
for (j = 0; j < column1; j++)
{
scanf("%d", &a[i][j]);
}
}
return;
}

/*  Function to read a matrix B */

void readmatB()
{
for (i = 0; i < row2; i++)
{
for (j = 0; j < column2; j++)
{
scanf("%d", &b[i][j]);
}
}
}

/*  Function to print a matrix A */

void printmatA()
{
for (i = 0; i < row1; i++)
{
for (j = 0; j < column1; j++)
{
printf("%3d", a[i][j]);
}
printf("\n");
}

}

/*  Function to print a matrix B */

void printmatB()
{
for (i = 0; i < row2; i++)
{
for (j = 0; j < column2; j++)
{
printf("%3d", b[i][j]);
}
printf("\n");
}

}

/*  Function to do the sum of elements of matrix A and Matrix B */

void sum()
{
for (i = 0; i < row1; i++)
{
for (j = 0; j < column2; j++)
{
sumarray[i][j] = a[i][j] + b[i][j];
}

}

printf("Sum matrix is \n");
for (i = 0; i < row1; i++)
{
for (j = 0; j < column2; j++)
{
printf("%3d", sumarray[i][j]) ;
}
printf("\n");

}
return;

}

/*  Function to do the difference of elements of matrix A and Matrix B */

void diff()
{
for (i = 0; i < row1; i++)
{
for (j = 0; j < column2; j++)
{
arraydiff[i][j] = a[i][j] - b[i][j];
}

}

printf("Difference matrix is \n");
for (i = 0; i < row1; i++)
{
for (j = 0; j < column2; j++)
{
printf("%3d", arraydiff[i][j]);

}
printf("\n");

}
return;

}
 ETP 
 
C Program to Perform Matrix Multiplication using Recursion
================================ EOPN
/* * C Program to Perform Matrix Multiplication using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm23.c
$ a.out
Enter rows and columns for Matrix A respectively: 2
2
Enter rows and columns for Matrix B respectively: 2
2
Enter elements in Matrix A:
12 56
45 78
 
Enter elements in Matrix B:
2 6
5 8
On matrix multiplication of A and B the result is:
304  520  
480  894
--------------------------------
#include <stdio.h>

void multiply(int, int, int [][10], int, int, int [][10], int [][10]);
void display(int, int, int[][10]);

int main()
{
int a[10][10], b[10][10], c[10][10] = {0};
int m1, n1, m2, n2, i, j, k;

printf("Enter rows and columns for Matrix A respectively: ");
scanf("%d%d", &m1, &n1);
printf("Enter rows and columns for Matrix B respectively: ");
scanf("%d%d", &m2, &n2);
if (n1 != m2)
{
printf("Matrix multiplication not possible.\n");
}
else
{
printf("Enter elements in Matrix A:\n");
for (i = 0; i < m1; i++)
for (j = 0; j < n1; j++)
{
scanf("%d", &a[i][j]);
}
printf("\nEnter elements in Matrix B:\n");
for (i = 0; i < m2; i++)
for (j = 0; j < n2; j++)
{
scanf("%d", &b[i][j]);
}
multiply(m1, n1, a, m2, n2, b, c);
}
printf("On matrix multiplication of A and B the result is:\n");
display(m1, n2, c);
}

void multiply (int m1, int n1, int a[10][10], int m2, int n2, int b[10][10], int c[10][10])
{
static int i = 0, j = 0, k = 0;

if (i >= m1)
{
return;
}
else if (i < m1)
{
if (j < n2)
{
if (k < n1)
{
c[i][j] += a[i][k] * b[k][j];
k++;
multiply(m1, n1, a, m2, n2, b, c);
}
k = 0;
j++;
multiply(m1, n1, a, m2, n2, b, c);
}
j = 0;
i++;
multiply(m1, n1, a, m2, n2, b, c);
}
}

void display(int m1, int n2, int c[10][10])
{
int i, j;

for (i = 0; i < m1; i++)
{
for (j = 0; j < n2; j++)
{
printf("%d  ", c[i][j]);
}
printf("\n");
}
}
 ETP 
 
 C Program to Check if 2 Matrices are Equal 
================================ EOPN
     /*     * C Program to accept two matrices and check if they are equal     
================================ EOKW
--------------------------------
output:
Enter the order of the matrix A
2 2
Enter the order of the matrix B
2 2
Enter the elements of matrix A
23 56
45 80
Enter the elements of matrix B
50 26
39 78
MATRIX A is
 23 56
 45 80
MATRIX B is
 50 26
 39 78
Matrices can be compared
But,two matrices are not equal
 
$ a.out
Enter the order of the matrix A
2 2
Enter the order of the matrix B
2 2
Enter the elements of matrix A
10 50
15 30
Enter the elements of matrix B
10 50
15 30
MATRIX A is
 10 50
 15 30
MATRIX B is
 10 50
 15 30
Matrices can be compared
Two matrices are equal
--------------------------------

#include <stdio.h>
#include <stdlib.h>

void main()
{

int a[10][10], b[10][10];
int i, j, row1, column1, row2, column2, flag = 1;

printf("Enter the order of the matrix A \n");
scanf("%d %d", &row1, &column1);

printf("Enter the order of the matrix B \n");
scanf("%d %d", &row2, &column2);

printf("Enter the elements of matrix A \n");
for (i = 0; i < row1; i++)
{
for (j = 0; j < column1; j++)
{
scanf("%d", &a[i][j]);
}
}

printf("Enter the elements of matrix B \n");
for (i = 0; i < row2; i++)
{
for (j = 0; j < column2; j++)
{
scanf("%d", &b[i][j]);
}
}

printf("MATRIX A is \n");
for (i = 0; i < row1; i++)
{
for (j = 0; j < column1; j++)
{
printf("%3d", a[i][j]);
}
printf("\n");

}

printf("MATRIX B is \n");
for (i = 0; i < row2; i++)
{
for (j = 0; j < column2; j++)
{
printf("%3d", b[i][j]);
}
printf("\n");

}

/*  Comparing two matrices for equality */

if (row1 == row2 && column1 == column2)
{
printf("Matrices can be compared \n");
for (i = 0; i < row1; i++)
{
for (j = 0; j < column2; j++)
{
if (a[i][j] != b[i][j])
{
flag = 0;
break;
}
}
}
}

else
{
printf(" Cannot be compared\n");
exit(1);
}

if (flag == 1)
printf("Two matrices are equal \n");
else
printf("But, two matrices are not equal \n");

}
 ETP 
 
 C Program to Check if a given Matrix is an Identity Matrix 
================================ EOPN
 /** C Program to check if a given matrix is an identity matrix
================================ EOKW
--------------------------------
output:
 
Enter the order of the matrix (mxn):
where m = number of rows; and
      n = number of columns
3 3
Enter the elements of the matrix
1 0 0
0 1 0
0 0 1
It is a IDENTITY MATRIX
 
Enter the order of the matrix (mxn):
where m = number of rows; and
      n = number of columns
3 3
Enter the elements of the matrix
1 2 3
4 5 6
5 8 7
It is NOT an identity matrix
--------------------------------
#include <stdio.h>

int main (void)
{
int a[10][10];
int i = 0, j = 0, row = 0, col = 0;

printf ("Enter the order of the matrix (mxn):\n");
printf ("where m = number of rows; and\n");
printf ("      n = number of columns\n");
scanf ("%d %d", &row, &col);

int flag = 0;

printf ("Enter the elements of the matrix\n");
for (i = 0; i < row; i++)
{
for (j = 0; j < col; j++)
{
scanf ("%d", &a[i][j]);
}
}

for (i = 0; i < row; i++)
{
for (j = 0; j < col; j++)
{
if (i == j && a[i][j] != 1)
{
flag = -1;
break;
}
else if (i != j && a[i][j] != 0)
{
flag = -1;
break;
}
}
}

if (flag == 0)
{
printf ("It is a IDENTITY MATRIX\n");
}
else
{
printf ("It is NOT an identity matrix\n");
}

return 0;
}
 ETP 
 
 C Program to Determine if a given Matrix is a Sparse Matrix 
================================ EOPN
/*
 * C program to determine if a given matrix is a sparse matrix.
 * Sparse martix has more zero elements than nonzero elements.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm86.c
$ a.out
Enter the order of the matix
3 3
Enter the co-efficients of the matix
10 20 30
5 10 15
3 6 9
The given matrix is not a sparse matrix
There are 0 number of zeros
 
$ a.out
Enter the order of the matix
3 3
Enter the co-efficients of the matix
5 0 0
0 0 5
0 5 0
The given matrix is sparse matrix
There are 6 number of zeros
--------------------------------

#include <stdio.h>
 
void main ()
{
    static int array[10][10];
    int i, j, m, n;
    int counter = 0;
 
    printf("Enter the order of the matix \n");
    scanf("%d %d", &m, &n);
    printf("Enter the co-efficients of the matix \n");
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            scanf("%d", &array[i][j]);
            if (array[i][j] == 0)
            {
                ++counter;
            }
        }
    }
    if (counter > ((m * n) / 2))
    {
        printf("The given matrix is sparse matrix \n");
    }
    else
        printf("The given matrix is not a sparse matrix \n");
    printf("There are %d number of zeros", counter);
}
 ETP 
 
 C Program to Interchange any two Rows & Columns in the given Matrix 
================================ EOPN
/* * C program to accept a matrix of given order and interchange * any two rows and columns in the original matrix 
================================ EOKW
--------------------------------
output:
$ cc pgm59.c
$ a.out
Enter the order of the matrix
2 2
Enter the co-efficents of the matrix
34 70
45 90
Enter the numbers of two rows to be exchanged
1 2
Enter the numbers of two columns to be exchanged
1 2
The given matrix is
 34 70
 45 90
The matix after interchanging the two rows(in the original matrix)
 45 90
 34 70
The matix after interchanging the two columns(in the original matrix)
 70 34
 90 45
--------------------------------
#include <stdio.h>

void main()
{
static int array1[10][10], array2[10][10];
int i, j, m, n, a, b, c, p, q, r;

printf("Enter the order of the matrix \n");
scanf("%d %d", &m, &n);
printf("Enter the co-efficents of the matrix \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
scanf("%d,", &array1[i][j]);
array2[i][j] = array1[i][j];
}
}
printf("Enter the numbers of two rows to be exchanged \n");
scanf("%d %d", &a, &b);
for (i = 0; i < m; ++i)
{
/*  first row has index is 0 */
c = array1[a - 1][i];
array1[a - 1][i] = array1[b - 1][i];
array1[b - 1][i] = c;
}
printf("Enter the numbers of two columns to be exchanged \n");
scanf("%d %d", &p, &q);
printf("The given matrix is \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
printf(" %d", array2[i][j]);
printf("\n");
}
for (i = 0; i < n; ++i)
{
/*  first column index is 0 */
r = array2[i][p - 1];
array2[i][p - 1] = array2[i][q - 1];
array2[i][q - 1] = r;
}
printf("The matix after interchanging the two rows(in the original matrix) \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
printf(" %d", array1[i][j]);
}
printf("\n");
}
printf("The matix after interchanging the two columns(in the original matrix) \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
printf(" %d", array2[i][j]);
printf("\n");
}
}
 ETP 
 
 C Program to Sort Rows of the Matrix in Ascending & Columns in Descendng Order 
================================ EOPN
/*
 * C program to accept a matrics of order MxN and sort all rows of the
 * matrix in ascending order and all columns in descending order
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm87.c
$ a.out
Enter the order of the matrix
3 3
Enter co-efficients of the matrix
3 7 9
2 4 8
5 2 6
The given matrix is
 3 7 9
 2 4 8
 5 2 6
After arranging rows in ascending order
 3 7 9
 2 4 8
 2 5 6
After arranging the columns in descending order
 5 7 9
 3 4 8
 2 2 6
--------------------------------

#include <stdio.h>
 
void main()
{
    static int array1[10][10], array2[10][10];
    int i, j, k, a, m, n;
 
    printf("Enter the order of the matrix \n");
    scanf("%d %d", &m, &n);
    printf("Enter co-efficients of the matrix \n");
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            scanf("%d", &array1[i][j]);
            array2[i][j] = array1[i][j];
        }
    }
    printf("The given matrix is \n");
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
                printf(" %d", array1[i][j]);
        }
        printf("\n");
    }
    printf("After arranging rows in ascending order\n");
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            for (k =(j + 1); k < n; ++k)
            {
                if (array1[i][j] > array1[i][k])
                {
                    a = array1[i][j];
                    array1[i][j] = array1[i][k];
                    array1[i][k] = a;
                }
            }
        }
    }
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            printf(" %d", array1[i][j]);
        }
        printf("\n");
    }
    printf("After arranging the columns in descending order \n");
    for (j = 0; j < n; ++j)
    {
        for (i = 0; i < m; ++i)
        {
            for (k = i + 1; k < m; ++k)
            {
                if (array2[i][j] < array2[k][j])
                {
                    a = array2[i][j];
                    array2[i][j] = array2[k][j];
                    array2[k][j] = a;
                }
            }
        }
    }
    for (i = 0; i < m; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            printf(" %d", array2[i][j]);
        }
        printf("\n");
    }
}
 ETP 
 
 C Program to Calculate the Sum of the Elements of each Row & Column 
================================ EOPN
/* * C program to read a matrix A (MxN) & find the following using * functions a) Sum of the elements of each row * b) Sum of the elements of each column * c) Find the sum of all the elements of the matrix * Output the computed results 
================================ EOKW
--------------------------------
output:
Enter the order of the matrix
3 3
Enter the elements of the matrix
2 3 4
7 1 5
3 8 9
Input matrix is
  2  3  4
  7  1  5
  3  8  9
Sum of row 1 = 9
Sum of row 2 = 13
Sum of row 3 = 20
Sum of column  1 = 12
Sum of column  2 = 12
Sum of column  3 = 18
Sum of all elements of matrix = 42
--------------------------------
#include <stdio.h>
int Addrow(int array1[10][10], int k, int c);
int Addcol(int array1[10][10], int k, int r);

void main()
{
int arr[10][10];
int i, j, row, col, rowsum, colsum, sumall=0;

printf("Enter the order of the matrix \n");
scanf("%d %d", &row, &col);
printf("Enter the elements of the matrix \n");
for (i = 0; i < row; i++)
{
for (j = 0; j < col; j++)
{
scanf("%d", &arr[i][j]);
}
}
printf("Input matrix is \n");
for (i = 0; i < row; i++)
{
for (j = 0; j < col; j++)
{
printf("%3d", arr[i][j]);
}
printf("\n");
}
/*  computing row sum */
for (i = 0; i < row; i++)
{
rowsum = Addrow(arr, i, col);
printf("Sum of row %d = %d\n", i + 1, rowsum);
}
/*  computing col sum */
for (j = 0; j < col; j++)
{
colsum = Addcol(arr, j, row);
printf("Sum of column  %d = %d\n", j + 1, colsum);
}
/*  computation of all elements */
for (j = 0; j < row; j++)
{
sumall = sumall + Addrow(arr, j, col);
}
printf("Sum of all elements of matrix = %d\n", sumall);
}
/*  Function to add each row */
int Addrow(int array1[10][10], int k, int c)
{
int rsum = 0, i;
for (i = 0; i < c; i++)
{
rsum = rsum + array1[k][i];
}
return(rsum);
}
/*  Function to add each column */
int Addcol(int array1[10][10], int k, int r)
{
int csum = 0, j;
for (j = 0; j < r; j++)
{
csum = csum + array1[j][k];
}
return(csum);
}
 ETP 
 
 C Program to Find the Frequency of Odd & Even Numbers in the given Matrix  
================================ EOPN
    /*     * C program to find the frequency of odd numbers     * and even numbers in the input of a matrix     
================================ EOKW
--------------------------------
output:
Enter the order of the matrix
3 3
Enter the coefficients of matrix
34 36 39
23 57 98
12 39 49
The given matrix is
 34 36 39
 23 57 98
 12 39 49
 
The frequency of occurrence of odd number  = 5
The frequency of occurrence of even number = 4
--------------------------------

#include <stdio.h>
void main()
{

static int array[10][10];
int i, j, m, n, even = 0, odd = 0;

printf("Enter the order ofthe matrix \n");
scanf("%d %d", &m, &n);

printf("Enter the coefficients of matrix \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
scanf("%d", &array[i][j]);
if ((array[i][j] % 2) == 0)
{
++even;
}
else
++odd;
}

}

printf("The given matrix is \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
printf(" %d", array[i][j]);
}
printf("\n");
}

printf("\n The frequency of occurrence of odd number  = %d \n", odd);
printf("The frequency of occurrence of even number = %d\n", even);

}
 ETP 
 
 C Program to Accept a Matrix of Order MxN & Interchange the Diagonals 
================================ EOPN
   /*     * C program to accept a matrix of order M x N and store its elements     * and interchange the main diagonal elements of the matrix     * with that of the secondary diagonal elements     
================================ EOKW
--------------------------------
output:
Enetr the order of the matix
2 2
Enter the co-efficients of the matrix
25 30
78 43
The given matrix is
 25 30
 78 43
The matrix after changing the
main diagonal & secondary diagonal
 30 25
 43 78
--------------------------------

#include <stdio.h>
void main ()
{

static int array[10][10];
int i, j, m, n, a;

printf("Enter the order of the matix \n");
scanf("%d %d", &m, &n);

if (m == n)
{
printf("Enter the co-efficients of the matrix\n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
scanf("%dx%d", &array[i][j]);
}
}

printf("The given matrix is \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
printf(" %d", array[i][j]);
}
printf("\n");
}

for (i = 0; i < m; ++i)
{
a = array[i][i];
array[i][i] = array[i][m - i - 1];
array[i][m - i - 1] = a;
}

printf("The matrix after changing the \n");
printf("main diagonal & secondary diagonal\n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
printf(" %d", array[i][j]);

}

printf("\n");

}

}

else
printf("The given order is not square matrix\n");

}
 ETP 
 
 C Program to Find the Sum of each Row & each Column of a MxN Matrix
================================ EOPN
     /*     * C program to accept a matrix of order M x N and find the sum     * of each row and each column of a matrix     
================================ EOKW
--------------------------------
output:
Enter the order of the matrix
2 2
Enter the co-efficients of the matrix
23 45
80 97
Sum of the 0 row is = 68
Sum of the 1 row is = 177
Sum of the 0 column is = 103
Sum of the 1 column is = 142
--------------------------------

#include <stdio.h>
void main ()
{

static int array[10][10];
int i, j, m, n, sum = 0;

printf("Enter the order of the matrix\n");
scanf("%d %d", &m, &n);

printf("Enter the co-efficients of the matrix\n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
scanf("%d", &array[i][j]);
}
}

for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
sum = sum + array[i][j] ;
}

printf("Sum of the %d row is = %d\n", i, sum);
sum = 0;

}
sum = 0;
for (j = 0; j < n; ++j)
{
for (i = 0; i < m; ++i)
{
sum = sum + array[i][j];
}

printf("Sum of the %d column is = %d\n", j, sum);
sum = 0;

}

}
 ETP 
 
C Program to do the Sum of the Main & Opposite Diagonal Elements of a MxN Matrix
================================ EOPN
    /*     * C program to find accept a matrix of order M x N and find     * the sum of the  main diagonal and off diagonal elements     
================================ EOKW
--------------------------------
output:
Enter the order of the matix
2 2
Enter the co-efficients of the matrix
40 30
38 90
The given matrix is
 40 30
 38 90
 
The sum of the main diagonal elements is = 130
The sum of the off diagonal elements is   = 68
--------------------------------

#include <stdio.h>
void main ()
{

static int array[10][10];
int i, j, m, n, a = 0, sum = 0;

printf("Enetr the order of the matix \n");
scanf("%d %d", &m, &n);

if (m == n )
{

printf("Enter the co-efficients of the matrix\n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
scanf("%d", &array[i][j]);
}
}

printf("The given matrix is \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
printf(" %d", array[i][j]);
}
printf("\n");
}

for (i = 0; i < m; ++i)
{
sum = sum + array[i][i];
a = a + array[i][m - i - 1];
}

printf("\nThe sum of the main diagonal elements is = %d\n", sum);
printf("The sum of the off diagonal elements is   = %d\n", a);

}

else
printf("The given order is not square matrix\n");

}
 ETP 
 
C Program to Find the Trace & Normal of a given Matrix
================================ EOPN
    /*     * C program to find the trace and normal of a matrix     *     * Trace is defined as the sum of main diagonal elements and     * Normal is defined as square root of the sum of all the elements     
================================ EOKW
--------------------------------
output:
Enter the order of the matrix
3 3
Enter the coefficients of the matrix
3  7 9
2 6 10
8 5 9
The normal of the given matrix is = 21
Trace of the matrix is = 18
--------------------------------

#include <stdio.h>
#include <math.h>

void main ()
{

static int array[10][10];
int i, j, m, n, sum = 0, sum1 = 0, a = 0, normal;

printf("Enter the order of the matrix\n");
scanf("%d %d", &m, &n);

printf("Enter the n coefficients of the matrix \n");
for (i = 0; i < m; ++i)
{
for (j = 0; j < n; ++j)
{
scanf("%d", &array[i][j]);
a = array[i][j] * array[i][j];
sum1 = sum1 + a;
}
}

normal = sqrt(sum1);
printf("The normal of the given matrix is = %d\n", normal);
for (i = 0; i < m; ++i)
{
sum = sum + array[i][i];
}

printf("Trace of the matrix is = %d\n", sum);

}
 ETP 
 
C Program to Display Upper Triangular Matrix
================================ EOPN
    /*     * C Program to Display Upper Triangular Matrix     
================================ EOKW
--------------------------------
output:
Enter the r and c value:3 3
array[1][1] = 1 1 1
array[1][2] = array[1][3] = array[2][1] = 1 1 0
array[2][2] = array[2][3] = array[3][1] = 2 0 0
array[3][2] = array[3][3] = matrix is
111
110
200
 
1
11
200
--------------------------------

#include <stdio.h>
void main()
{

int i, j, r, c, array[10][10];
printf("Enter the r and c value:");

scanf("%d%d", &r, &c);
for (i = 1; i <= r; i++)
{
for (j = 1; j <= c; j++)
{
printf("array[%d][%d] = ", i, j);
scanf("%d", &array[i][j]);
}
}

printf("matrix is");
for (i = 1; i <= r; i++)
{
for (j = 1; j <= c; j++)
{
printf("%d", array[i][j]);
}
printf("\n");
}

for (i = 1; i <= r; i++)
{
printf("\n");
for (j = 1; j <= c; j++)
{
if (i >= j)
{
printf("%d", array[i][j]);
}
else
{
printf("\t");
}
}

}

printf("\n\n");
for (i = 1; i <= r; i++)
{
printf("\n");
for (j = 1; j <= c; j++)
{
if (j >= i)
{
printf("%d", array[i][j]);
}
else
{
//printf("\t");
}
// printf("\n");

}

}
 ETP 
 
C Program to Display Lower Triangular Matrix
================================ EOPN
/*
 * C Program to Display Lower Triangular Matrix
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm15.c
$ a.out
Enter the value of Matrix : 1 2 0
1 0 0
0 0 0
Matrix is not a lower triangular matrix
 
$ a.out
Enter the value of Matrix : 1 0 0
1 1 0
1 1 1
Matrix is a Lower triangular matrix
--------------------------------

#include <stdio.h>
 
void main()
{
    int array[3][3], i, j, flag = 0 ;
    printf("\n\t Enter the value of Matrix : ");
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 3; j++)
        {
            scanf("%d", &array[i][j]);
        }
    }
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 3; j++)
        {
            if (array[i] < array[j] && array[i][j] == 0)
            {
                flag = flag + 1;
            }
        }
    }
    if (flag == 3)
        printf("\n\n Matrix is a Lower triangular matrix");
    else
        printf("\n\n Matrix is not a lower triangular matrix");
}
 ETP 
 
 C Program to Check if a given String is Palindrome 
================================ EOPN
 /* * C program to read a string and check if it's a palindrome, without * using library functions. Display the result. 
================================ EOKW
--------------------------------
output:
 
Enter a string
sanfoundry
sanfoundry is not a palindrome
 
 
Enter a string
malayalam
malayalam is a palindrome
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char string[25], reverse_string[25] = {'\0'};
int  i, length = 0, flag = 0;

fflush(stdin);
printf("Enter a string \n");
gets(string);
/*  keep going through each character of the string till its end */
for (i = 0; string[i] != '\0'; i++)
{
length++;
}
for (i = length - 1; i >= 0; i--)
{
reverse_string[length - i - 1] = string[i];
}
/*
* Compare the input string and its reverse. If both are equal
* then the input string is palindrome.
*/
for (i = 0; i < length; i++)
{
if (reverse_string[i] == string[i])
flag = 1;
else
flag = 0;
}
if (flag == 1)
printf("%s is a palindrome \n", string);
else
printf("%s is not a palindrome \n", string);
}
 ETP 
 
 C Program to Check if a String is a Palindrome without using the Built-in Function 
================================ EOPN
 /* * C program to find the length of a string without using the * built-in function also check whether it is a palindrome 
================================ EOKW
--------------------------------
output:
 
Enter a string
how  are you
The length of the string 'how  are you' = 12
how  are you is not a palindrome
 
 
Enter a string
madam
The length of the string 'madam' = 5
madam is a palindrome
 
 
Enter a string
mam
The length of the string 'mam' = 3
mam is a palindrome
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char string[25], reverse_string[25] = {'\0'};
int i, length = 0, flag = 0;

printf("Enter a string \n");
gets(string);
/*  keep going through each character of the string till its end */
for (i = 0; string[i] != '\0'; i++)
{
length++;
}
printf("The length of the string '%s' = %d\n", string, length);
for (i = length - 1; i >= 0 ; i--)
{
reverse_string[length - i - 1] = string[i];
}
/*  Check if the string is a Palindrome */

for (flag = 1, i = 0; i < length ; i++)
{
if (reverse_string[i] != string[i])
flag = 0;
}
if (flag == 1)
printf ("%s is a palindrome \n", string);
else
printf("%s is not a palindrome \n", string);
}
 ETP 
 
C Program to Check whether a given String is Palindrome or not using Recursion
================================ EOPN
/*  
 * C Program to Check whether a given String is Palindrome or not 
 * using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ gcc palindrome.c -o palindrome
$ a.out
Enter a word to check if it is a palindrome
malayalam
The entered word is a palindrome
--------------------------------

#include <stdio.h>
#include <string.h>
 
void check(char [], int);
 
int main()
{
    char word[15];
 
    printf("Enter a word to check if it is a palindrome\n");
    scanf("%s", word);
    check(word, 0);
 
    return 0;
}
 
void check(char word[], int index)
{
    int len = strlen(word) - (index + 1);
    if (word[index] == word[len])
    {
        if (index + 1 == len || index == len)
        {
            printf("The entered word is a palindrome\n");
            return;
        }
        check(word, index + 1);
    }
    else
    {
        printf("The entered word is not a palindrome\n");
    }
}
 ETP 
 
 C Program To Print Smallest and Biggest possible Word which is Palindrome in a given String 
================================ EOPN
/*  
 * C Program To Print Smallest and Biggest possible Word 
 * which is Palindrome in a given String
 
================================ EOKW
--------------------------------
output:
 
$ cc string14i.c
$ a.out
Read a string:
aba abcba abcdcba bcd
aba abcba abcdcba bcd
String aba is a Palindrome
String abcba is a Palindrome
String abcdcba is a Palindrome
The minimum palindrome is aba
The maximum palindrome is abcdcba
 
$ a.out
Read a string:
abc abcd
abc abcd
given string has no pallindrome
--------------------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main()
{
    int i = 0, l = 0, j, k, space = 0, count = 0, init = 0, min = 0, max = 0, len = 0, flag;
    char a[100], b[30][20], c[30], d[30], minP[30], maxP[30];
 
    printf("Read a string:\n");
    fflush(stdin);
    scanf("%[^\n]s", a);
    for (i = 0;a[i] != '\0';i++) 
    {
        if (a[i] == ' ')
            space++;
    }
    i = 0;
    for (j = 0;j<(space+1);i++, j++)
    {
        k = 0;
        while (a[i] != '\0')
        {
            if (a[i] == ' ')
            {
                break;
            }
            else
            {
                b[j][k++] = a[i];
                i++;
            }
        }
        b[j][k] = '\0';
    }
    for (j = 0;j < space + 1;j++)
        printf("%s ", b[j]);
    printf("\n");
    for (i = 0;i < space + 1;i++)
    {
        strcpy(c, b[i]); 
        count = strlen(b[i]);
        k = 0;
        for (l = count - 1;l >= 0;l--)
            d[k++] = b[i][l];
        d[k] = '\0';
        if (strcmp(d, c) == 0)                {
            flag = 1;
        if (init < 1) 
        {
            strcpy(minP, d);
            strcpy(maxP, d);
            min = strlen(minP);
            max = strlen(maxP);
            init++;
        }
        printf("String %s is a Palindrome\n", d);
        len = strlen(d);
        if (len >= max)
            strcpy(maxP, d);
        else if (len <= min)
            strcpy(minP, d);
        else
            printf("");
        }
    }
    if (flag == 1)
    {
        printf("The minimum palindrome is %s\n", minP);
        printf("The maximum palindrome is %s\n", maxP);
    }
    else
        printf("given string has no pallindrome\n");
}
 ETP 
 
 C Program to Find the Largest & Smallest Word in a String 
================================ EOPN
/* 
 * C Program to Find the Largest & Smallest Word in a String
 
================================ EOKW
--------------------------------
output:
 
$ gcc largestsmallest.c 
$ ./a.out
Enter string: amazing programmers exists here
The largest word is 'programmers' and smallest word is 'here' in 'amazing programmers exists here'.
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
 
int main()
{
    char string[100], word[20], max[20], min[20], c;
    int i = 0, j = 0, flag = 0;
 
    printf("Enter string: ");
    i = 0;
    do
    {
        fflush(stdin);
        c = getchar();
        string[i++] = c;
 
    } while (c != '\n');
    string[i - 1] = '\0';
    for (i = 0; i < strlen(string); i++)
    {
        while (i < strlen(string) && !isspace(string[i]) && isalnum(string[i]))
        {
            word[j++] = string[i++];
        }
        if (j != 0)
        {
            word[j] = '\0';
            if (!flag)
            {
                flag = !flag;
                strcpy(max, word);
                strcpy(min, word);
            }
            if (strlen(word) > strlen(max))
            {
                strcpy(max, word);
            }
            if (strlen(word) < strlen(min))
            {
                strcpy(min, word);
            }
            j = 0;
        }
    }
    printf("The largest word is '%s' and smallest word is '%s' in '%s'.\n", max, min, string);
 
    return 0;
}
 ETP 
 
 C Program to read two Strings & Concatenate the Strings 
================================ EOPN
  /* * C program to read two strings and concatenate them, without using * library functions. Display the concatenated string. 
================================ EOKW
--------------------------------
output:
Enter the first string : San
Enter the second string: foundry
First string  = San
Second string = foundry
Concatenated string = Sanfoundry
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char string1[20], string2[20];
int i, j, pos;

/*  Initialize the string to NULL values */
memset(string1, 0, 20);
memset(string2, 0, 20);

printf("Enter the first string : ");
scanf("%s", string1);
printf("Enter the second string: ");
scanf("%s", string2);
printf("First string  = %s\n", string1);
printf("Second string = %s\n", string2);

/*  Concate the second string to the end of the first string */
for (i = 0; string1[i] != '\0'; i++)
{
/*  null statement: simply traversing the string1 */
;
}
pos = i;
for (j = 0; string2[j] != '\0'; i++)
{
string1[i] = string2[j++];
}
/*  set the last character of string1 to NULL */
string1[i] = '\0';
printf("Concatenated string = %s\n", string1);
}
 ETP 
 
 C Program to Concatenate two Strings Lexically 
================================ EOPN
/*  
 * C Program to Concatenate the given two Strings Lexically
 
================================ EOKW
--------------------------------
output:
 
$ cc string17.c
$ a.out
 
Enter a string : hello this
 
Enter another string to concat : is sanfoundry
hello is sanfoundry this
--------------------------------

#include <string.h>
#include <stdio.h>
 
void sort(char *p);
 
void main()
{
    char string1[100], string2[100];
    int i, len, j;
 
    printf("\nEnter a string : ");
    scanf("%[^\n]s", string1);
    printf("\nEnter another string to concat : ");
    scanf(" %[^\n]s", string2);
    len = strlen(string1);
    string1[len] = ' ';
    for(i = 0, j = len + 1; i < strlen(string2); i++, j++)
        string1[j] = string2[i];
    string1[j]='\0';
    sort(string1);
}
 
/* Sorting to make concatenation lexical 
 ETP 
 
 C Program to Check if the Substring is present in the given String 
================================ EOPN
/*  
 * C program to accept a string and a substring and
 * check if the substring is present in the given string
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm44.c
$ a.out
Enter a string: hello
Enter search substring: world
SEARCH UNSUCCESSFUL!
 
$ a.out
Enter a string: helloworld
Enter search substring:ld
SEARCH SUCCESSFUL!
--------------------------------

#include<stdio.h>
 
int main()
{
    char str[80], search[10];
    int count1 = 0, count2 = 0, i, j, flag;
 
    printf("Enter a string:");
    gets(str);
    printf("Enter search substring:");
    gets(search);
    while (str[count1] != '\0')
        count1++;
    while (search[count2] != '\0')
        count2++;
    for (i = 0; i <= count1 - count2; i++)
    {
        for (j = i; j < i + count2; j++)
        {
            flag = 1;
            if (str[j] != search[j - i])
            {
                flag = 0;
                break;
            }
        }
        if (flag == 1)
            break;
    }
    if (flag == 1)
        printf("SEARCH SUCCESSFUL!");
    else
        printf("SEARCH UNSUCCESSFUL!");
 
    return 0;
}
 ETP 
 
 C Program to Accepts two Strings & Compare them  
================================ EOPN
 #include <stdio.h> int main (){    int count1 = 0, count2 = 0, flag = 0, i;    char string1[30], string2[30];  printf ("Enter the First string\n");    gets (string1);     printf ("Enter the Second string\n");   gets (string2);     while (string1[count1] != '\0')     count1 ++;  while (string2[count2] != '\0')     count2 ++;  i = 0;  while (string1[i] == string2[i] && string1[i] != '\0')  {       i ++;   }   if (string1[i] > string2[i])        printf ("First string is greater than Second string\n");    else if (string1[i] < string2[i])       printf("Second string is greater than First string\n"); else        printf ("Both strings are EQUAL\n");    return 0;}
================================ EOKW
--------------------------------
output:
Enter the First string
object
Enter the Second string
class
First string is greater than Second string
 
Enter the First string
object
Enter the Second string
object
Both strings are EQUAL
 
Enter the First string
class
Enter the Second string
object
Second string is greater than First string
--------------------------------
 ETP 
 
 C Program to Find the Length of a String without using the Built-in Function 
================================ EOPN
 /* * C program to find the length of a string without using the * built-in function 
================================ EOKW
--------------------------------
output:
Enter a string
Sanfoundry
The length of a string is the number of characters in it
So, the length of Sanfoundry = 10
--------------------------------
#include <stdio.h>

void main()
{
char string[50];
int i, length = 0;

printf("Enter a string \n");
gets(string);
/*  keep going through each character of the string till its end */
for (i = 0; string[i] != '\0'; i++)
{
length++;
}
printf("The length of a string is the number of characters in it \n");
printf("So, the length of %s = %d\n", string, length);
}
 ETP 
 
 C Program to Replace Lowercase Characters by Uppercase & Vice-Versa 
================================ EOPN
/* * C program to read an English sentence and replace * lowercase characters by uppercase and vice-versa. * Output the given sentence as well as the converted * sentence on two different lines. 
================================ EOKW
--------------------------------
output:
Enter a sentence
wELCOME tO sANFOUNDRY
The given sentence is   : wELCOME tO sANFOUNDRY
Case changed sentence is: Welcome To Sanfoundry
--------------------------------
#include <stdio.h>
#include <ctype.h>

void main()
{
char sentence[100];
int count, ch, i;

printf("Enter a sentence \n");
for (i = 0;(sentence[i] = getchar()) != '\n'; i++)
{
;
}
sentence[i] = '\0';
/*  shows the number of chars accepted in a sentence */
count = i;
printf("The given sentence is   : %s", sentence);
printf("\n Case changed sentence is: ");
for (i = 0; i < count; i++)
{
ch = islower(sentence[i])? toupper(sentence[i]) :
tolower(sentence[i]);
putchar(ch);
}
}
 ETP 
 
 C Program to Remove given Word from a String 
================================ EOPN
 /* * C Program to Remove given Word from a String 
================================ EOKW
--------------------------------
output:
$ gcc remove-word.c -o remove-word
$./remove-word
 
Enter the string:
Hello World hello world Hello W
Enter the word to be removed: Hello
 
World hello world W
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main ()
{
char str[100], word[100], twoD[10][30];
int i = 0, j = 0, k = 0, len1 = 0, len2 = 0;

printf ("Enter the string:\n");
gets (str);

printf ("Enter the word to be removed:\n");
gets (word);

// let us convert the string into 2D array
for (i = 0; str[i] != '\0'; i++)
{
if (str[i] == ' ')
{
twoD[k][j] = '\0';
k ++;
j = 0;
}
else
{
twoD[k][j] = str[i];
j ++;
}
}

twoD[k][j] = '\0';

j = 0;
for (i = 0; i < k + 1; i++)
{
if (strcmp(twoD[i], word) == 0)
{
twoD[i][j] = '\0';
}
}

j = 0;

for (i = 0; i < k + 1; i++)
{
if (twoD[i][j] == '\0')
continue;
else
printf ("%s ", twoD[i]);
}

printf ("\n");

return 0;
}
 ETP 
 
 C Program to Remove all Characters in Second String which are present in First String 
================================ EOPN
/*
 * C Program to Remove all Characters in Second String which are 
 * present in First String 
 
================================ EOKW
--------------------------------
output:
$ gcc removecommonchar.c 
$ ./a.out
 
Enter the First string:
Programming
Enter the Second string:
Computer
 
On removing characters from second string we get: Cpute
--------------------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main ()
{
    char str1[100], str2[100], str_rem[100];
    int i = 0, j = 0, k = 0;
 
    printf ("Enter the First string:\n");
    fflush (stdin);
    gets (str1);
 
    printf ("Enter the Second string:\n");
    gets (str2);
 
    for (i = 0; str1[i]!= '\0'; i++)
    {
        for (j = 0; str2[j] != '\0'; j++)
        {
            if (str1[i] == str2[j])
            {
                continue;
            }
            else
            {
                str_rem[k] = str2[j];
                k ++;
            }
        }
        str_rem[k] = '\0';
        strcpy (str2, str_rem);
        k = 0;
    }
 
    printf ("On removing characters from second string we get: %s\n", str_rem);
 
    return 0;
}
 ETP 
 
 C Program to Replace all the Characters by Lowercase 
================================ EOPN
/* * C Program to Replace all the Characters by Lowercase  
================================ EOKW
--------------------------------
output:
Input a string to convert to lower case
CHANDANA chanikya
rAVELLA
 
Input string in lower case:
chandana chanikya
ravella
--------------------------------
#include <stdio.h>
#include <string.h>

int main()
{
char string[1000];

printf("Input a string to convert to lower case\n");
gets(string);

printf("Input string in lower case: %s\n",strlwr(string));

return  0;
}
 ETP 
 
C Program to Reverse the String using Recursion
================================ EOPN
/*
 * C Program to Reverse the String using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm12.c
$ a.out
Enter a string to reverse: malayalam
The string after reversing is: malayalam
 
$ a.out
Enter a string to reverse: cprogramming
The string after reversing is: gnimmargorpc
--------------------------------

#include <stdio.h>
#include <string.h>
 
void reverse(char [], int, int);
int main()
{
    char str1[20];
    int size;
 
    printf("Enter a string to reverse: ");
    scanf("%s", str1);
    size = strlen(str1);
    reverse(str1, 0, size - 1);
    printf("The string after reversing is: %s\n", str1);
    return 0;
}
 
void reverse(char str1[], int index, int size)
{
    char temp;
    temp = str1[index];
    str1[index] = str1[size - index];
    str1[size - index] = temp;
    if (index == size / 2)
    {
        return;
    }
    reverse(str1, index + 1, size);
}
 ETP 
 
 C Program to Reverse every Word of given String 
================================ EOPN
 /*  *  C Program to Reverse every Word of given String 
================================ EOKW
--------------------------------
output:
enter the string :C Programming Class
C gnimmargorP ssalC
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int i, j = 0, k = 0, x, len;
char str[100], str1[10][20], temp;

printf("enter the string :");
scanf("%[^\n]s", str);

/* reads into 2d character array */
for (i = 0;str[i] != '\0'; i++)
{
if (str[i] == ' ')
{
str1[k][j]='\0';
k++;
j=0;
}
else
{
str1[k][j]=str[i];
j++;
}
}
str1[k][j] = '\0';

/* reverses each word of a given string */
for (i = 0;i <= k;i++)
{
len = strlen(str1[i]);
for (j = 0, x = len - 1;j < x;j++,x--)
{
temp = str1[i][j];
str1[i][j] = str1[i][x];
str1[i][x] = temp;
}
}
for (i = 0;i <= k;i++)
{
printf("%s ", str1[i]);
}
}
 ETP 
 
 C Program to Count the Number of Vowels & Consonants in a Sentence 
================================ EOPN
/* * C program to read a sentence and count the total number of vowels * and consonants in the sentence. 
================================ EOKW
--------------------------------
output:
Enter a sentence
welcome to sanfoundry
No. of vowels in welcome to sanfoundry = 7
No. of consonants in welcome to sanfoundry = 12
--------------------------------
#include <stdio.h>

void main()
{
char sentence[80];
int i, vowels = 0, consonants = 0, special = 0;

printf("Enter a sentence \n");
gets(sentence);
for (i = 0; sentence[i] != '\0'; i++)
{
if ((sentence[i] == 'a' || sentence[i] == 'e' || sentence[i] ==
'i' || sentence[i] == 'o' || sentence[i] == 'u') ||
(sentence[i] == 'A' || sentence[i] == 'E' || sentence[i] ==
'I' || sentence[i] == 'O' || sentence[i] == 'U'))
{
vowels = vowels + 1;
}
else
{
consonants = consonants + 1;
}
if (sentence[i] =='\t' ||sentence[i] =='\0' || sentence[i] ==' ')
{
special = special + 1;
}
}
consonants = consonants - special;
printf("No. of vowels in %s = %d\n", sentence, vowels);
printf("No. of consonants in %s = %d\n", sentence, consonants);
}
 ETP 
 
 C Program to Delete All Repeated Words in String 
================================ EOPN
/* * C Program to Delete All Repeated Words in String 
================================ EOKW
--------------------------------
output:
Enter the string

welcome to sanfoundry's c programming class ,  welcome again to c class !

welcome to sanfoundry's c programming class , again !

 
Enter the string:

Welcome to Sanfoundry C Class, Welcome to Java Programming, Welcome to C++ class

Welcome to Sanfoundry C Class, Java Programming, C++ class
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main ()
{
char str[100], word[100], twoD[10][30];
int i = 0, j = 0, k = 0, len1 = 0, len2 = 0, l = 0;

printf ("Enter the string\n");
gets (str);

// let us convert the string into 2D array
for (i = 0; str[i] != '\0'; i++)
{
if (str[i] == ' ')
{
twoD[k][j] = '\0';
k ++;
j = 0;
}
else
{
twoD[k][j] = str[i];
j ++;
}
}

twoD[k][j] = '\0';

j = 0;
for (i = 0; i < k; i++)
{
int present = 0;
for (l = 1; l < k + 1; l++)
{
if (twoD[l][j] == '\0' || l == i)
{
continue;
}

if (strcmp (twoD[i], twoD[l]) == 0) {
twoD[l][j] = '\0';
present = present + 1;
}
}
// if (present > 0)      | uncomment this `if` block if you
// {                 | want to remove all the occurrences
//  twoD[i][j] = '\0';   | of the words including the word
// }                 | itself.
}

j = 0;

for (i = 0; i < k + 1; i++)
{
if (twoD[i][j] == '\0')
continue;
else
printf ("%s ", twoD[i]);
}

printf ("\n");

return 0;
}
 ETP 
 
 C Program to Reverse the String using Both Recursion and Iteration 
================================ EOPN
/* *  C Program to Reverse the String using Both Recursion and Iteration 
================================ EOKW
--------------------------------
output:
$ cc string21.c
$ a.out
Enter the string:
welcome to sanfoundry's c programming class
 
Using iteration:
ssalc gnimmargorp c s'yrdnuofnas ot emoclew
Using recurssion:
ssalc gnimmargorp c s'yrdnuofnas ot emoclewi
--------------------------------
#include <stdio.h>
#include <string.h>

/* Function Prototype */
void disp_str1_rec(char *);

void main()
{
char str1[100], *ptr;
int len1 = 0, i;
char ch;
printf("Enter the string:\n");
scanf("%[^\n]s", str1);
ptr = str1;
len1 = strlen(str1);
printf("Using iteration:\n");
for (i = len1 - 1; i >= 0;i--)        /* Iterative loop */
{

ch = str1[i];
printf("%c", ch);
}
printf("Using recurssion:\n");
disp_str1_rec(ptr);
}

/* Code to reverse the string using Recursion */
void disp_str1_rec(char *stng)
{
char ch;
if (*stng != '\0')
{
ch = *stng;
stng++;
disp_str1_rec(stng);
printf("%c", ch);
}
else
return;
}
 ETP 
 
 C Program to Count the Total Number of Words in the Sentence using Command Line Argument 
================================ EOPN
/* * C Program to Count Number of Words in a given Text Or Sentence 
================================ EOKW
--------------------------------
output:
Enter the string:
welcome to sanfoundry's c-programming class!
Number of words in given string are: 5
 
Enter the string:
Best Reference Books in C Programming
Number of words in given string are: 6
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char s[200];
int count = 0, i;

printf("Enter the string:\n");
scanf("%[^\n]s", s);
for (i = 0;s[i] != '\0';i++)
{
if (s[i] == ' ' && s[i+1] != ' ')
count++;
}
printf("Number of words in given string are: %d\n", count + 1);
}
 ETP 
 
 C Program to Find the Frequency of the Word ‘the’ in a given Sentence 
================================ EOPN
/* *  C program to accept a string and find the number of times the word * 'the' appears in that string 
================================ EOKW
--------------------------------
output:
Enter a string:
The gandhi jayanthi is celeberated on october 2 is the day
that he has born.
Frequency of the word 'the' is 2
--------------------------------
#include <stdio.h>

void main()
{
int count = 0, i, times = 0, t, h, e, space;
char string[100];

puts("Enter a string:");
gets(string);
/*   Traverse the string to count the number of characters */
while (string[count] != '\0')
{
count++;
}
/*   Finding the frequency of the word 'the' */
for (i = 0; i <= count - 3; i++)
{
t =(string[i] == 't' || string[i] == 'T');
h =(string[i + 1] == 'h' || string[i + 1] == 'H');
e =(string[i + 2] == 'e'|| string[i + 2] == 'E');
space =(string[i + 3] == ' ' || string[i + 3] == '\0');
if ((t && h && e && space) == 1)
times++;
}
printf("Frequency of the word 'the' is %d\n", times);
}
 ETP 
 
 C Program to Read a String and find the Sum of all Digits in the String   
================================ EOPN
  /* * C program to find the sum of all digits present in the string 
================================ EOKW
--------------------------------
output:
Enter the string containing both digits and alphabet
hello100
NO. of Digits in the string = 3
Sum of all digits = 1
--------------------------------
#include <stdio.h>
void main()
{
char string[80];
int count, nc = 0, sum = 0;

printf("Enter the string containing both digits and alphabet \n");
scanf("%s", string);
for (count = 0; string[count] != '\0'; count++)
{
if ((string[count] >= '0') && (string[count] <= '9'))
{
nc += 1;
sum += (string[count] - '0');
}
}
printf("NO. of Digits in the string = %d\n", nc);
printf("Sum of all digits = %d\n", sum);
}
 ETP 
 
C Program to Copy One String to Another using Recursion
================================ EOPN
/*
 * C Program to Copy One String to Another using Recursion
 
================================ EOKW
--------------------------------
output:
$ gcc recursive-copy.c -o recursive-copy
$ ./recursive-copy
 
Enter string to copy: Welcome to Sanfoundry
Copying success.
 
The first string is: Welcome to Sanfoundry
The second string is: Welcome to Sanfoundry
--------------------------------

#include <stdio.h>
 
void copy(char [], char [], int);
 
int main()
{
    char str1[20], str2[20];
 
    printf("Enter string to copy: ");
    scanf("%[^\n]s", str1);
    copy(str1, str2, 0);
    printf("Copying success.\n");
    printf("The first string is: %s\n", str1);
    printf("The second string is: %s\n", str2);
    return 0;
}
 
void copy(char str1[], char str2[], int index)
{
    str2[index] = str1[index];
    // printf ("INDEX IS %d\n", index);
    if (str1[index] == '\0')
        return;
    copy(str1, str2, index + 1);
}
 ETP 
 
C Program to find the First Capital Letter in a String using Recursion
================================ EOPN
/*
 * C Program to find the first capital letter in a string using 
 * Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm32.c
$ a.out
Enter a string to find it's first capital letter: iloveC
The first capital letter in iloveC is C.
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
 
char caps_check(char *);
 
int main()
{
    char string[20], letter;
 
    printf("Enter a string to find it's first capital letter: ");
    scanf("%s", string);
    letter = caps_check(string);
    if (letter == 0)
    {
        printf("No capital letter is present in %s.\n", string);
    }
    else
    {
        printf("The first capital letter in %s is %c.\n", string, letter);    }
        return 0;
    }
    char caps_check(char *string)
    {
        static int i = 0;
        if (i < strlen(string))
        {
            if (isupper(string[i]))
            {
                return string[i];
            }
            else
            {
                i = i + 1;
                return caps_check(string);
            }
        }
        else return 0;
    }
 ETP 
 
C Program to find the First Capital Letter in a String without using Recursion
================================ EOPN
/*
 * C Program to find the First Capital Letter in a String without 
 * using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm35.c
$ a.out
Enter a string to find it's first capital letter: prOgraMmInG
The first capital letter in prOgraMmInG is O.
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
 
char caps_check(char *);
 
int main()
{
    char string[20], letter;
 
    printf("Enter a string to find it's first capital letter: ");
    scanf("%s", string);
    letter = caps_check(string);
    if (letter == 0)
    {
        printf("No capital letter is present in %s.\n", string);
    }
    else
    {
        printf("The first capital letter in %s is %c.\n", string, letter);    }
        return 0;
    }
    char caps_check(char *string)
    {
        int i = 0;
        while (string[i] != '\0')
        {
            if (isupper(string[i]))
            {
                return string[i];
            }
            i++;
        }
        return 0;
    }
 ETP 
 
C Program to find the Length of the String using Recursion
================================ EOPN
/* * Recursive C program to find length of a linked list 
================================ EOKW
--------------------------------
output:
Enter the string:
Sanfoundry C Programming
The length of the given string is: 24
 
Enter the string:
Programming Examples
The length of the given string is: 20
--------------------------------
#include <stdio.h>

int find_len (char [], int);

int main ()
{
char str[100];
int len = 0;

printf ("Enter the string: \n");
scanf ("%[^\n]s", str);

len = find_len (str, 0);

printf ("The length of the given string is: %d\n", len);
return 0;
}

int find_len (char str[], int index)
{
static int l = 0;

if (str[index] == '\0')
return l;
else
l ++;

find_len (str, index + 1);
}
 ETP 
 
 C Program to find Longer Repeating Sequence 
================================ EOPN
/* * C Program to find Longer Repeating Sequence  
================================ EOKW
--------------------------------
output:
$ cc string22.c
$ a.out
Enter the string:Welcome to C Programming Class, Welcome Again to C Programming Class!
 
The longer repeating sequence of the given string is: Programming
 
Enter the string:Welcome to Sanfoundry, Welcome to C Class
 
 
The longer repeating sequence of the given string is: Welcome
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char s1[100], ar[10][20], ar1[10][20], new[10];
int i, j = 0, k = 0, l, count = 0, flag = 0, n, temp, len[20], maxlen = 0;

printf("\nEnter the string:");
scanf(" %[^\n]s", s1);

/*COPYING GIVEN STRING TO 2D ARRAY*/
for (i = 0;s1[i] != '\0';i++,j++)
{
if (s1[i] >= 33 && s1[i] <= 64)
i++;
if (s1[i] == ' ')
{
ar[k][j] = '\0';
k++;
i++;
j = 0;
}
ar[k][j] = s1[i];
}
ar[k][j] = '\0';
/*PLACING THE REPEATED WORDS AND LENGTHS INTO NEW ARRAY*/
l = 0;
for (i = 0;i <= k;i++)
{
for (j = i + 1;j <= k;j++)
{
if (strcmp(ar[i], ar[j]) == 0)
{
for (n = 0;n < l && l != 0; n++)
{
if (strcmp(ar[i], ar1[k]) == 0)
{
flag = 1;
break;
}
}
if (flag != 1)
{
strcpy(ar1[l], ar[i]);
len[l] = strlen(ar1[l]);
l++;
}
flag = 0;
break;
}
}
}
printf("\n");
/*SORTING IS DONE BASED ON THEIR LENGTHS*/
for (i = 0;i < l;i++)
{
for (j = i + 1;j < l;j++)
{
if (len[i] < len[j])
{
temp = len[i];
strcpy(new, ar1[i]);
len[i] = len[j];
strcpy(ar1[i], ar1[j]);
len[j] = temp;
strcpy(ar1[j], new);
}
}
}
maxlen = len[0];
for (i = 0;i < l;i++)
{
if (len[i] == maxlen)
printf("\nThe longer repeating sequence of the given string is: %s", ar1[i]);
}
}
 ETP 
 
 C Program to Find the Frequency of Substring in the given String 
================================ EOPN
/*  * C Program to Find the Frequency of Substring in  * the given String 
================================ EOKW
--------------------------------
output:
Enter the string:
prrrogram is prrrogramming
Enter the substring to be matched:
rr
No of matches of substring in main string is: 4
 
Enter the string:
Sanfoundry C Programming
Enter the substring to be matched:
oun
No of matches of substring in main string is: 1
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int count = 0, i, j = 0, k;
char str[100], str1[20];

printf("Enter the string:\n");
scanf(" %[^\n]s", str);

printf("Enter the substring to be matched:\n");
scanf(" %[^\n]s", str1);

k = strlen(str1);

for (i = 0; str[i] != '\0'; i++)
{
while (str[i] == str[j])
{
j ++;
}

if (j == k)
{
count ++;
j = 0;
}
}
printf("No of matches of substring in main string is: %d\n", count);
}
 ETP 
 
 C Program to Find the Frequency of  Every Word in a given String 
================================ EOPN
/*  * C Program to Find the Frequency of  Every Word in a  * given String 
================================ EOKW
--------------------------------
output:
Enter the string:
Welcome to Sanfoundry Welcome to C Class
string length is 40
Welcome -> 2 times
to -> 2 times
Sanfoundry -> 1 times
C -> 1 times
Class -> 1 times
 
Enter the string:
Welcome to C Class, Java Class
string length is 30
Welcome -> 1 times
to -> 1 times
C -> 1 times
Class -> 2 times
 -> 1 times
Java -> 1 times
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int count = 0, c = 0, i, j = 0, k, space = 0;

char str[100], p[50][100], str1[20], ptr1[50][100];

char *ptr;

printf("Enter the string\n");
scanf(" %[^\n]s", str);

printf("string length is %d\n", strlen(str));

for (i = 0;i<strlen(str);i++)
{
if ((str[i] == ' ')||(str[i] == ',' && str[i+1] == ' ')||(str[i] == '.'))
{
space++;
}
}

for (i = 0, j = 0, k = 0;j < strlen(str);j++)
{
if ((str[j] == ' ')||(str[j] == 44)||(str[j] == 46))
{
p[i][k] = '\0';
i++;
k = 0;
}
else
p[i][k++] = str[j];
}

k = 0;

for (i = 0;i <= space;i++)
{
for (j = 0;j <= space;j++)
{
if (i == j)
{
strcpy(ptr1[k], p[i]);
k++;
count++;

break;
}
else
{
if (strcmp(ptr1[j], p[i]) != 0)
continue;
else
break;
}
}
}

for (i = 0;i < count;i++)
{
for (j = 0;j <= space;j++)
{
if (strcmp(ptr1[i], p[j]) == 0)
c++;
}
printf("%s -> %d times\n", ptr1[i], c);
c = 0;
}
}
 ETP 
 
 C Program to Find Highest Frequency Character in a String 
================================ EOPN
/*  * C Program To Find the Highest Frequency Character in a String 
================================ EOKW
--------------------------------
output:
$ cc string23.c
$ a.out
Enter a string : Welcome to Sanfoundry's C Programming Class !
 
Max repeated character in the string = o 
It occurs 4 times
--------------------------------
#include <stdio.h>
#include <string.h>

char string1[100], visited[100];
int count[100] = {0}, flag = 0;

void main()
{
int i, j = 0, k = 0, l, max, index;

printf("Enter a string : ");
scanf("%[^\n]s", string1);

l = strlen(string1);

for (i = 0; i < l; i++)
{
if (i == 0)
{
visited[j++] = string1[i];
count[j - 1]++;
}
else
{
for (k = 0; k  < j; k++)
{
if (string1[i] == visited[k])
{
count[k]++;
flag = 1;
}
}
if (flag == 0)
{
visited[j++] = string1[i];
count[j - 1]++;
}
flag = 0;
}
}

for (i = 0; i < j; i++)
{
if ((i == 0) && (visited[i] != ' '))
{
max = count[i];
continue;
}
if ((max < count[i]) && (visited[i] != ' '))
{
max = count[i];
index = i;
}
}

printf("\nMax repeated character in the string = %c ", visited[index]);
printf("\nIt occurs %d times", count[index]);
}
 ETP 
 
 C Program to Find the Length of the Longest Repeating Sequence in a String 
================================ EOPN
/* * C Program to Find the Length of the Longest Repeating Sequence in a String 
================================ EOKW
--------------------------------
output:
Enter the string:
Welcome to C Programming Class, Welcome Again to C Programming Class!
 
Length of Longest Repeating Sequence:3
 
Total number of words : 3
 The subsequence is :  to C Programming
The length of longest common subsequence is : 19
--------------------------------
#include <stdio.h>
#include <string.h>
char string[100], words[100][100];
int len = 0, word_cnt = 0;
int main()
{
int i, j = 0, k, mlen = 0, rlen = 0, s = 0, c = 0, m = 0;
printf("\nEnter the string:");
scanf(" %[^\n]s", string);
for (len = 0;string[len] != '\0';len++);
/*
* Storing the individual words in an array
*/
for (k = 0;k < len;k++)
{
if (string[k] != ' ')
{
words[s][j] = string[k];
j++;
}
if (string[k] == ' ')
{
words[s][j] = '\0';
j = 0;
s++;
word_cnt++;
}
}
word_cnt++;
/*
* Compare on Word basis if same word is repeated then check next word & so on
* Increment a counter when consecutive words are repeated
*/
for (i = 0;i <= word_cnt;i++)
{
len = 0;
for (j = i+1;j <= word_cnt-1;j++)
{
if (strcmp(words[i], words[j]) != 0)
{
continue;
}
else if (strcmp(words[i], words[j]) == 0)
{
len++;
for (k = i+1, m = j+1;k < j;k++, m++)
{
if (strcmp(words[k], words[m]) == 0)
{
len++;
continue;
}
else
{
break;
}
}
if (rlen < len)
{
rlen = len;
len = 0;
}
len = 0;
}
/*
* Finding length of Longest Repeated Sequence
*/
if (mlen < rlen)
{
s = i;
mlen = rlen;
}
}
}
printf("\nLength of Longest Repeating Sequence:%d\n", mlen);
printf ("\nTotal number of words : %d", mlen);
printf ("\n The subsequence is : ");
for (i = s, j = 0;j < mlen;i++, j++)
printf(" %s", words[i]);
char subseq[100];
// concat all the words
for (i = s, j = 0; j < mlen; i++, j++)
strcat (subseq, words[i]);
printf ("\nThe length of longest common subsequence is: %d", strlen(subseq)+1);
printf("\n");
}
 ETP 
 
 C Program to find the possible subsets of the String 
================================ EOPN
/* * C Program to find the possible subsets of the String 
================================ EOKW
--------------------------------
output:
$ cc string19.c
$ a.out
Enter the len of main set : 11
Enter the elements of main set : programming
The subsets are :
p
r
o
g
r
a
m
m
i
n
g
pr
po
pg
pr
pa
pm
pm
pi
pn
pg
ro
rg
rr
ra
rm
rm
ri
rn
rg
og
or
oa
om
om
oi
on
og
gr
ga
gm
gm
gi
gn
gg
ra
rm
rm
ri
rn
rg
am
am
ai
an
ag
mm
mi
mn
mg
mi
mn
mg
in
ig
ng
pro
prg
prr
pra
prm
prm
pri
prn
prg
rog
ror
roa
rom
rom
roi
ron
rog
ogr
oga
ogm
ogm
ogi
ogn
ogg
gra
grm
grm
gri
grn
grg
ram
ram
rai
ran
rag
amm
ami
amn
amg
mmi
mmn
mmg
min
mig
ing
prog
pror
proa
prom
prom
proi
pron
prog
rogr
roga
rogm
rogm
rogi
rogn
rogg
ogra
ogrm
ogrm
ogri
ogrn
ogrg
gram
gram
grai
gran
grag
ramm
rami
ramn
ramg
ammi
ammn
ammg
mmin
mmig
ming
progr
proga
progm
progm
progi
progn
progg
rogra
rogrm
rogrm
rogri
rogrn
rogrg
ogram
ogram
ograi
ogran
ograg
gramm
grami
gramn
gramg
rammi
rammn
rammg
ammin
ammig
mming
progra
progrm
progrm
progri
progrn
progrg
rogram
rogram
rograi
rogran
rograg
ogramm
ogrami
ogramn
ogramg
grammi
grammn
grammg
rammin
rammig
amming
program
program
prograi
progran
prograg
rogramm
rogrami
rogramn
rogramg
ogrammi
ogrammn
ogrammg
grammin
grammig
ramming
programm
programi
programn
programg
rogrammi
rogrammn
rogrammg
ogrammin
ogrammig
gramming
programmi
programmn
programmg
rogrammin
rogrammig
ogramming
programmin
programmig
rogramming
programming
--------------------------------
#include <stdio.h>

char string[50], n;
void subset(int, int, int);

int main()
{
int i, len;

printf("Enter the len of main set : ");
scanf("%d", &len);
printf("Enter the elements of main set : ");
scanf("%s", string);
n = len;
printf("The subsets are :\n");
for (i = 1;i <= n;i++)
subset(0, 0, i);
}

/*Function to find the number of subsets in the given string*/

void subset(int start, int index, int num_sub)
{
int i, j;
if (index - start + 1  ==  num_sub)
{
if (num_sub  ==  1)
{
for (i = 0;i < n;i++)
printf("%c\n", string[i]);
}
else
{
for (j = index;j < n;j++)
{
for (i = start;i < index;i++)
printf("%c", string[i]);
printf("%c\n", string[j]);
}
if (start != n - num_sub)
subset(start + 1, start + 1, num_sub);
}
}
else
{
subset(start, index + 1, num_sub);
}
}
 ETP 
 
C Program to Check whether two Strings are Anagrams
================================ EOPN
 /* * C Program to Check whether two Strings are Anagrams 
================================ EOKW
--------------------------------
output:
 
Enter the string
abll
Enter another string
ball
"abll" and "ball" are anagrams.
 
 
Enter the string
tall
Enter another string
all
"tall" and "all" are not anagrams.
--------------------------------
#include <stdio.h>

int find_anagram(char [], char []);

int main()
{
char array1[100], array2[100];
int flag;

printf("Enter the string\n");
gets(array1);
printf("Enter another string\n");
gets(array2);
flag = find_anagram(array1, array2);
if (flag == 1)
printf(""%s" and "%s" are anagrams.\n", array1, array2);
else
printf(""%s" and "%s" are not anagrams.\n", array1, array2);
return 0;
}

int find_anagram(char array1[], char array2[])
{
int num1[26] = {0}, num2[26] = {0}, i = 0;

while (array1[i] != '\0')
{
num1[array1[i] - 'a']++;
i++;
}
i = 0;
while (array2[i] != '\0')
{
num2[array2[i] -'a']++;
i++;
}
for (i = 0; i < 26; i++)
{
if (num1[i] != num2[i])
return 0;
}
return 1;
}
 ETP 
 
 C Program to Display every possible Combination of two Words or Strings from the input Strings without Repeated Combinations 
================================ EOPN
/*  * C Program to Display every possible Combination of two Words  * or Strings from the input Strings without Repeated Combinations 
================================ EOKW
--------------------------------
output:
$ cc string27.c
$ a.out
enter the string :welcome to sanfoundry's class
enter string:welcome to c programming class
 
welcomewelcome
welcometo
welcomec
welcomeprogramming
welcomeclass
towelcome
toto
toc
toprogramming
toclass
sanfoundry'swelcome
sanfoundry'sto
sanfoundry'sc
sanfoundry'sprogramming
sanfoundry'sclass
classwelcome
classto
classc
classprogramming
classclass
welcomesanfoundry's
tosanfoundry's
cwelcome
cto
csanfoundry's
cclass
programmingwelcome
programmingto
programmingsanfoundry's
programmingclass
classsanfoundry's
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int i, j = 0, k, k1 = 0, k2 = 0, row = 0;
char temp[50];
char str[100], str2[100], str1[5][20], str3[6][20], str4[60][40];

printf("enter the string :");
scanf(" %[^\n]s", &str);
printf("enter string:");
scanf(" %[^\n]s", &str2);

/* read strings into 2d character arrays */
for (i = 0;str[i] != '\0'; i++)
{
if (str[i] == ' ')
{
str1[k1][j] = '\0';
k1++;
j = 0;
}
else
{
str1[k1][j] = str[i];
j++;
}
}
str1[k1][j] = '\0';
j = 0;
for (i = 0;str2[i] != '\0';i++)
{
if (str2[i] == ' ')
{
str3[k2][j] = '\0';
k2++;
j = 0;
}
else
{
str3[k2][j] = str2[i];
j++;
}
}
str3[k2][j] = '\0';

/* concatenates string1 words with string2 and stores in 2d array */
row = 0;
for (i = 0;i <= k1;i++)
{
for (j = 0;j <= k2;j++)
{
strcpy(temp, str1[i]);
strcat(temp, str3[j]);
strcpy(str4[row], temp);
row++;
}
}
for (i = 0;i <= k2;i++)
{
for (j = 0;j <= k1;j++)
{
strcpy(temp, str3[i]);
strcat(temp, str1[j]);
strcpy(str4[row], temp);
row++;
}
}

/* eliminates repeated combinations */
for (i = 0;i < row;i++)
{
for (j = i + 1;j < row;j++)
{
if (strcmp(str4[i], str4[j]) == 0)
{
for (k = j;k <= row;k++)
{
strcpy(str4[k], str4[k + 1]);
}
row--;
}
}
}

/* displays the output */
for (i = 0;i < row;i++)
{
printf("\n%s", str4[i]);
}
}
 ETP 
 
 C Program to List All Lines containing a given String 
================================ EOPN
/* * C Program to List All Lines containing a given String 
================================ EOKW
--------------------------------
output:
$cat example
hi hello everyone
again hi to the late comers
welcome to the class
 
$ cc file6.c
$ ./a.out example hi
hi hello everyone
again hi to the late comers
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int search(FILE *, char *);

void main(int argc, char * argv[])
{
FILE *fp1;
int p;

fp1 = fopen(argv[1], "r+");
if (fp1 == NULL)
{
printf("cannot open the file ");
exit(0);
}
search(fp1, argv[2]);
fclose(fp1);
}

/* Searches the lines */
int search(FILE *fp, char * str)
{
FILE *fp1;
fp1 = fopen("fp1","w");
char s[10],c;
int len = strlen(str);
int i = 0;
int d;
int seek = fseek(fp, 0, 0);
c = fgetc(fp);
while (c != EOF)
{
if (c == ' ' || c == '\n')
{
s[i] = '\0';
i = 0;
if (strcmp(s, str) == 0)
{
while (c = fgetc(fp) != '\n')
{
fseek(fp, -2L, 1);
d = ftell(fp);
}
while ((c = fgetc(fp)) != '\n')
{
fputc(c, fp1);
}
}
}
else
{
s[i] = c;
i++;
}
c = fgetc(fp);
}
return 1;
}
 ETP 
 
 C Program to Print the Words Ending with Letter S 
================================ EOPN
 /*  * C Program to Print the Words Ending with Letter S 
================================ EOKW
--------------------------------
output:
 
Enter a string : Welcome to Sanfoundry's C Programming Class, Welcome Again to C Class !
Sanfoundry's
Class
--------------------------------
#include <stdio.h>
#include <string.h>

char str[100];

void main()
{
int i, t, j, len;

printf("Enter a string : ");
scanf("%[^\n]s", str);

len = strlen(str);

str[len] = ' ';

for (t = 0, i = 0; i < strlen(str); i++)
{
if ((str[i] == ' ') && (str[i - 1] == 's'))
{
for (j = t; j < i; j++)
printf("%c", str[j]);
t = i + 1;
printf("\n");
}
else
{
if (str[i] == ' ')
{
t = i + 1;
}
}
}
}
 ETP 
 
 C Program to Insert Character/Word in any Desired Location in a String 
================================ EOPN
/* * C Program to Insert Character/Word in any Desired Location  * in a String  
================================ EOKW
--------------------------------
output:
$ cc string10.c
$ a.out
enter the string:Welcome to Sanfoundry's C Programming Class,  Welcome Again to C Class!
enter the word to insert:Sanfoundry's
enter the position you like to insert:3
the string after modification is
 
Welcome to Sanfounsry's Sanfoundry's C Programming Class,  Welcome Again to C Class!
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int i, j, count = 0, pos, flag = 0;
char s1[100], s2[10], s3[100];
char *ptr1, *ptr2, *ptr3;

printf("\nenter the String:");
scanf(" %[^\n]s", s1);
printf("\nenter the string to be inserted:");
scanf(" %[^\n]s", s2);
printf("\nenter the position you like to insert:");
scanf("%d", &pos);

ptr1 = s1;
ptr3 = s3;
/*COPYING THE GIVEN STRING TO NEW ARRAY AND INSERTING THE STRING IN NEW ARRAY*/
for (i = 0, j = 0;*ptr1 != '\0'; ptr1++, i++, j++, ptr3++)
{
s3[j] = s1[i];
if (*ptr1 == ' ' && flag != 1)
++count;
if (flag != 1 && count == pos - 1)
{
flag = 1;
for(ptr2 = s2;*ptr2 != '\0'; ptr2++)
{
s3[++j] = *ptr2;
ptr3++;
}
s3[++j] = ' ';
ptr3++;
}
}
s3[j] = '\0';
printf("\nthe string after modification is\n\n %s\n", s3);
}
 ETP 
 
 C Program to Implement Regular Expression Matching 
================================ EOPN
/* * C Program to Implements Regular Expression Matching 
================================ EOKW
--------------------------------
output:
$gcc -o regex regular.c
$ ./regex
 
Enter the Regular Expression
C.*g
 
Enter the text
Cprogramming
 
The Text Matches The Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C*g
 
Enter the text
Cprogramming
 
The Text Doesn't match the Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C?.*g
 
Enter the text
Cprogramming
 
The Text Matches The Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C.?g
 
Enter the text
Cprogramming
 
The Text Doesn't match the Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C.+g
 
Enter the text
Cprogramming
 
The Text Matches The Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C+g
 
Enter the text
Cprogramming
 
The Text Doesn't match the Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
 
^C.*
 
Enter the text
Cprogramming
 
The Text Matches The Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
^p.*
 
Enter the text
Cprogramming
 
The Text Doesn't match the Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C.*g$
 
Enter the text
Cprogramming
 
The Text Matches The Regular Expression
Do you want to continue?(Y/N)y
 
Enter the Regular Expression
C.*n$
 
Enter the text
Cprogramming
 
The Text Doesn't match the Regular Expression
Do you want to continue?(Y/N)n
--------------------------------
#include <stdio.h>
#include <string.h>
#define MATCH printf("\nThe Text Matches The Regular Expression");
#define NOTMATCH printf("\nThe Text Doesn't match the Regular Expression");

char reg[20], text[20];

int main()
{
int i, rlen, tlen, f = 0;
char ans;

do {
printf("\nEnter the Regular Expression\n");
scanf(" %[^\n]s", reg);
for (rlen = 0; reg[rlen] != '\0';rlen++);
printf("\nEnter the text\n");
scanf(" %[^\n]s", text);
for (tlen = 0;text[tlen] != '\0' ; tlen++);
if (reg[0] == '*')
{
printf("\nInvalid regular expression");
}
/*
*If the regular expression starts with Alphabet
*/
if ((reg[0] >= 65 && reg[0] <= 90) || (reg[0] >= 97 && reg[0] <=122))
{
if (reg[0] == text [0])
{
switch (reg[1])
{
case '.' :
switch (reg[2])
{
case '*':
if (tlen != 1)
{
if (reg[3] == text[tlen-1])
{
MATCH;
}
else
{
NOTMATCH;
}
}
else
{
NOTMATCH;
}
break;
case '+':
if (text[1] != reg[3])
{
if (reg[3] == text[tlen - 1])
{
MATCH;
}
else
{
NOTMATCH;
}
}
break;
case '?':
if (text[1] == reg[3] || text[2] == reg[3])
{
if (text[1] == reg[3] || text[2] == reg[3])
{
MATCH;
}
else
{
NOTMATCH;
}
}
else
{
NOTMATCH;
}
break;
}
break;
case '*':
if (reg[rlen-1] == text[tlen-1])
{
for (i = 0;i <= tlen-2;i++)
{
if(text[i] == reg[0])
{
f = 1;
}
else
{
f = 0;
}
}
if ( f == 1)
{
MATCH;
}
else
{
NOTMATCH;
}
}
else
{
NOTMATCH;
}
break;
case '+' :
if (tlen <= 2)
{
NOTMATCH;
}
else if (reg[rlen-1] == text[tlen-1])
{
for (i = 0;i < tlen-2;i++)
{
if (text[i] == reg[0])
{
f = 1;
}
else
{
f = 0;
}
}

if (f == 1)
{
MATCH;
}
else
{
NOTMATCH;
}
}
break;
case '?':
if (reg[rlen -1] == text[tlen-1])
{
MATCH;
}
else
{
NOTMATCH;
}
break;
}

}
else
printf("Does not match");
}
/*
*If Regular Expression starts with '^'
*/
else if (reg[0] == '^')
{
if (reg[1] == text[0])
{
MATCH;
}
else
{
NOTMATCH;
}
}
/*
*If Regular Expression Ends with '$'
*/
else if (reg[rlen-1] == '$')
{
if (reg[rlen-2] == text[rlen-1])
{
MATCH;
}
else
{
NOTMATCH;
}
}

else
printf("Not Implemented");
printf("\nDo you want to continue?(Y/N)");
scanf(" %c", &ans);
} while (ans == 'Y' || ans == 'y');
}
 ETP 
 
 C Program to Implement  strpbrk() Function 
================================ EOPN
/* * C Program to Implement a strpbrk() Function 
================================ EOKW
--------------------------------
output:
$gcc string34.c
$ a.out
Enter the String:
C programming Class
 
Enter the Character Set:
mp
programming Class
--------------------------------
#include <stdio.h>

char* strpbrk(char *, char *);

int main()
{
char string1[50], string2[50];
char *pos;

printf("Enter the String:\n");
scanf(" %[^\n]s", string1);
printf("\nEnter the Character Set:\n");
scanf(" %[^\n]s", string2);
pos=strpbrk(string1, string2);
printf("%s", pos);
}

/* Locates First occurrence in string s1 of any character in string s2,
* If a character from string s2 is found ,
* a pointer to the character in string s1 is returned,
* otherwise,  a NULL pointer is returned.
*/
char* strpbrk(char *string1, char *string2)
{
int i, j, pos, flag = 0;
for (i = 0; string1[i] != '\0';i++);
pos = i;
for (i = 0;string2[i] != '\0';i++)
{
for (j = 0;string1[j] != '\0';j++)
{
if (string2[i] == string1[j])
{
if (j <= pos)
{
pos = j;
flag = 1;
}
}
}
}
if (flag == 1)
{
return &string1[pos];
}
else
{
return NULL;
}
}
 ETP 
 
 C Program to Implement the KMP Pattern Searching Algorithm 
================================ EOPN
/* * C Program to Implement the KMP Pattern Searching Algorithm   
================================ EOKW
--------------------------------
output:
$ gcc kmpstringmatch.c 
$ ./a.out 
Enter string: programming
Enter substring: gram
Match found from position 4 to 7.
--------------------------------
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main()
{
char string[100], matchcase[20], c;
int i = 0, j = 0, index;

/*Scanning string*/
printf("Enter string: ");
do
{
fflush(stdin);
c = getchar();
string[i++] = tolower(c);

} while (c != '\n');
string[i - 1] = '\0';
/*Scanning substring*/
printf("Enter substring: ");
i = 0;
do
{
fflush(stdin);
c = getchar();
matchcase[i++] = tolower(c);
} while (c != '\n');
matchcase[i - 1] = '\0';
for (i = 0; i < strlen(string) - strlen(matchcase) + 1; i++)
{
index = i;
if (string[i] == matchcase[j])
{
do
{
i++;
j++;
} while(j != strlen(matchcase) && string[i] == matchcase[j]);
if (j == strlen(matchcase))
{
printf("Match found from position %d to %d.\n", index + 1, i);
return 0;
}
else
{
i = index + 1;
j = 0;
}
}
}
printf("No substring match found in the string.\n");

return 0;
}
 ETP 
 
 C Program to Sort Word in String 
================================ EOPN
/* * C Program to Sort Word in String 
================================ EOKW
--------------------------------
output:
$ cc string18.c
$ a.out
Enter the string
welcome to sanfoundry's c programming class, welcome to c class again
After sorting string is
again c c class class programming sanfoundry's to to welcome welcome
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int count = 0, c = 0, i, j = 0, k, l, space = 0;
char str[100], p[50][100], str1[20], ptr1[50][100], cmp[50];

printf("Enter the string\n");
scanf(" %[^\n]s", str);
for (i = 0;i < strlen(str);i++)
{
if ((str[i] == ' ')||(str[i] == ', ')||(str[i] == '.'))
{
space++;
}
}
for (i = 0, j = 0, k = 0;j < strlen(str);j++)
{
if ((str[j] == ' ')||(str[j] == 44)||(str[j] == 46))
{
p[i][k] = '\0';
i++;
k = 0;
}
else
p[i][k++] = str[j];
}
for (i = 0;i < space;i++)    //loop for sorting
{
for (j = i + 1;j <= space;j++)
{
if ((strcmp(p[i], p[j]) > 0))
{
strcpy(cmp, p[i]);
strcpy(p[i], p[j]);
strcpy(p[j], cmp);
}
}
}
printf("After sorting string is \n");
for (i = 0;i <= space;i++)
{
printf("%s ", p[i]);
}
}
 ETP 
 
 C Program to Sort String Ignoring Whitespaces and Repeating Characters Only Once 
================================ EOPN
/* * C Program to sort string ignoring whitespaces and repeating characters only once 
================================ EOKW
--------------------------------
output:
$ cc string99.c
$ a.out
 
Enter a string:abcdel bcdl abcdefg
The sorted string is:abcdefgl
--------------------------------
#include <stdio.h>
#include <string.h>

#define SIZE 50

void main()
{
char string[SIZE], string1[SIZE], string2[SIZE];
int i, j = 0, a = 0, temp, len = 0, len1 = 0, k = 0;

printf("\nEnter a string:");
scanf("%[^\n]s", string1);

/* Code to remove whitespaces */
for (i = 0;string1[i] != '\0';i++)
{
if (string1[i] == ' ')
{
continue;
}
string[j++] = string1[i];
}

/* Code to sort the string */
for (i = 0;string[i] != '\0';i++)
{
for (j = i + 1;string[j] != '\0';j++)
{
if (string[i] > string[j])
{
temp = string[i];
string[i] = string[j];
string[j] = temp;
}
}
}
string[i] = '\0';
len = strlen(string);

/* Code to remove redundant characters */
for (i = 0;string[i] != '\0';i++)
{
if (string[i] == string[i + 1] && string[i + 1] != '\0')
{
k++;
continue;
}
string2[a++] = string[i];
string[a] = '\0';
}
len1 = len - k;
printf("The sorted string is:");
for (temp = 0;temp < len1;temp++)
{
printf("%c", string2[temp]);
}
}
 ETP 
 
 C Program to Sort the String and Repeated Characters should be present only Once 
================================ EOPN
/*  * C Program to Sort the String(ignore spaces) and Repeated   * Characters should be present only Once   
================================ EOKW
--------------------------------
output:
$ cc string15.c
$ a.out
enter the string:abcde| bcd! abcdefg??
!?abcdefg|
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int i, j = 0, k = 0;
char str[100], str1[10][20], temp, min;

printf("enter the string:");
scanf("%[^\n]s", str);

/* ignores spaces */
for (i = 0; str[i]!= '\0';i++)
{
if (str[i] == ' ')
{
for (j = i;str[j] != '\0'; j++)
{
str[j] = str[j + 1];
}
}
}

/* removes repeated characters */
for (i = 0;str[i]!= '\0';i++)
{
for (j = i + 1;str[j] != '\0';j++)
{
if (str[i] == str[j])
{
for (k = j; str[k] != '\0'; k++)
str[k] = str[k+1];
j--;
}
}
}

/* sorts the string */
for (i = 0; str[i] != '\0'; i++)
{
for (j = 0; str[j] != '\0';j++)
{
if (str[j] > str[i])
{
temp = str[i];
str[i] = str[j];
str[j] = temp;
}
}
}
printf("%s", str);
}
 ETP 
 
 C Program to Count the Number of Unique Words 
================================ EOPN
/* * C Program to Count the Number of Unique Words  
================================ EOKW
--------------------------------
output:
$ cc string7.c
$ a.out
Read a string:
Welcome to Sanfoundry's C-programming class,  Welcome again to C class!
The length of input string is:70
 
Number of unique words in Welcome to Sanfoundry's C-programming class,  Welcome again to C class! are:8
--------------------------------
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main()
{
int i = 0, e, j, d, k, space = 0;
char a[50], b[15][20], c[15][20];

printf("Read a string:\n");
fflush(stdin);
scanf("%[^\n]s", a);
for (i = 0;a[i] != '\0';i++)        //loop to count no of words
{
if (a[i] =  = ' ')
space++;
}
i = 0;
for (j = 0;j<(space + 1);i++, j++)    //loop to store each word into an 2D array
{
k = 0;
while (a[i] != '\0')
{
if (a[i] == ' ')
{
break;
}
else
{
b[j][k++] = a[i];
i++;
}
}
b[j][k] = '\0';
}
i = 0;
strcpy(c[i], b[i]);
for (e = 1;e <= j;e++)        //loop to check whether the string is already present in the 2D array or not
{
for (d = 0;d <= i;d++)
{
if (strcmp(c[i], b[e]) == 0)
break;
else
{
i++;
strcpy(c[i], b[e]);
break;
}
}
}
printf("\nNumber of unique words in %s are:%d", a, i);
return 0;
}
 ETP 
 
 C Program to Search a Word & Replace it with the Specified Word 
================================ EOPN
/*
 * C Program to Search a Word & Replace it with the Specified Word
 
================================ EOKW
--------------------------------
output:
 
$ cc string31.c
$ a.out
Enter a string along with characters to be rep_strd:
prrrogram C prrrogramming
Enter the character to be rep_strd:
rr
Enter the new character:
mmm
prrrogram C prrrogramming
pmmmrogram C pmmmrogramming
--------------------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
/*Function to replace a string with another string
 ETP 
 
 C Program to Display the Characters in Prime Position a given String 
================================ EOPN
/* * C Program to Display the Characters in Prime Position a given String 
================================ EOKW
--------------------------------
output:
enter string
welcome to sanfoundry c-programming class!
prime characters in a string are
e
l
o
e
 
a
u
d
c
r
m
c
s
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int i, j, k, count = 0;
char str[50];

printf("enter string\n");
scanf("%[^\n]s", str);
k = strlen(str);
printf("prime characters in a string are\n");
for (i = 2;i <= k;i++)
{
count = 0;
for (j = 2;j <= k;j++)
{
if (i % j == 0)
{
count++;
}
}
if (count == 1)
{
printf("%c\n", str[i - 1]);
}
}
}
 ETP 
 
 C Program to Count Number of Words in a given Text Or Sentence 
================================ EOPN
/* * C Program to Count Number of Words in a given Text Or Sentence 
================================ EOKW
--------------------------------
output:
Enter the string:
welcome to sanfoundry's c-programming class!
Number of words in given string are: 5
 
Enter the string:
Best Reference Books in C Programming
Number of words in given string are: 6
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char s[200];
int count = 0, i;

printf("Enter the string:\n");
scanf("%[^\n]s", s);
for (i = 0;s[i] != '\0';i++)
{
if (s[i] == ' ' && s[i+1] != ' ')
count++;
}
printf("Number of words in given string are: %d\n", count + 1);
}
 ETP 
 
 C Program to Print Combination of two Words of two given Strings without any Repetition 
================================ EOPN
/*
 * C Program to Print Combination of two Words of two 
 * given Strings without any Repetition
 
================================ EOKW
--------------------------------
output:
 
$ cc string3.c
$ a.out
Enter a string:welcome to sanfoundry's c programming class,  welcome again to c class
Enter the word to check its occurence:welcome
The number of occ is 2
 
$ cc string3.c
$ a.out
Enter a string:welcome to sanfoundry's c programming class,  welcome again to c class
Enter the word to check its occurence:c
The number of occ is 2
--------------------------------

#include <stdio.h>
#include <string.h>
 
void main()
{
    char string[100], str[10], c[10];
    int z, occ = 0, i = 0, j = 0, count = 0, len = 0;
 
    printf("Enter a string:");
    scanf("%[^\n]s", string);
    printf("Enter the word to check its occurence:");
    scanf("%s", str);
    len = strlen(str);
    for (i = 0;string[i] != '\0';i++)
    {
        count = 0;
        for (j = 0, z = i;j < len; j++, z++)
        {
            c[j] = string[z];
            if (c[j] == str[j])
            {
                count++; /* Incrementing the count if the characters of the main string match with the characters of the given word 
 ETP 
 
 C Program to Display Every Possible Combination of Two Words from the given 2 String without Displaying Repeated Combinations 
================================ EOPN
/* * C Program to Display Every Possible Combination of Two Words  * from the given 2 String without Displaying Repeated Combinations 
================================ EOKW
--------------------------------
output:
$ cc program27.c
$ a.out
Enter first string
welcome to sanfoundry's class
Enter second string
welcome to c programming class
welcomewelcome
welcometo
welcomec
welcomeprogramming
welcomeclass
towelcome
toto
toc
toprogramming
toclass
sanfoundry'swelcome
sanfoundry'sto
sanfoundry'sc
sanfoundry'sprogramming
sanfoundry'sclass
classwelcome
classto
classc
classprogramming
classclass
cwelcome
programmingwelcome
cto
programmingto
welcomesanfoundry's
tosanfoundry's
csanfoundry's
programmingsanfoundry's
cclass
programmingclass
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
char str1[50],  str2[50], str3[100][100], str4[100][100];
char str5[200][200], temp[200], str[200][200];
int i, j = 0, k = 0, l = 0, m = 0, index = 0, n = 0;
printf("Enter first string\n");
scanf("%[^\n]s", str1);
printf("Enter second string\n");
scanf(" %[^\n]s", str2);

/* code to convert string in 2-D array */
for (i = 0;str1[i] != '\0';i++)
{
if ((str1[i] =  = ' ')
{
str3[j][k] = '\0';
j++;
k = 0;
}
else
{
str3[j][k] = str1[i];
k++;
}
str3[j][k] = '\0';
}
k = 0;

for (i = 0;str2[i] != '\0';i++)
{
if ((str2[i] == ' ')
{
str4[l][k] = '\0';
l++;
k = 0;
}
else
{
str4[l][k] = str2[i];
k++;
}
str4[l][k] = '\0';
}
/* Code to make the first string words combination with second */
for (i = 0;i <= j;i++)
{
for (m = 0;m <= l;m++)
{
strcpy(temp, str3[i]);
strcat(temp, str4[m]);
strcpy(str5[index], temp);
index++;
}
}

/* Code to make the second string words combination with first */
for (i = 0;i <= l;i++)
{
for (m = 0;m <= j;m++)
{
strcpy(temp, str4[m]);
strcat(temp, str3[i]);
strcpy(str5[index], temp);
index++;
}
}

/* Code to remove the repetitions */
for (i = 0;i <= index;i++)
{
for (j = i + 1;j <= index;j++)
{
if ((strcmp(str5[i], str5[j]) == 0)
{
for (k = j;k <= index;k++)
{
strcpy(str5[k], str5[k + 1]);
}
index--;
}
}
}
for (i = 0;i <= index;i++)
{
printf("%s\n", str5[i]);
}
}
 ETP 
 
 C Program to Accept 2 String & check whether all Characters in first String is Present in second String & Print 
================================ EOPN
/*
 * C Program to Accept 2 String & check whether all Characters
 * in first String is Present in second String & Print 
 
================================ EOKW
--------------------------------
output:
 
$ cc allchar.c 
$ ./a.out
Enter string1: aspired
Enter string2: despair
All characters match in aspired and despair.
The characters that match are: a, d, e, i, p, r, s,
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#define CHAR_SIZE 26
 
void alphacheck(char *, int []);
void create(char *, int[]);
 
int main()
{
    char str1[50], str2[50];
    int a1[CHAR_SIZE] = {0}, a2[CHAR_SIZE] = {0}, i;
    char str1_alpha[CHAR_SIZE], str2_alpha[CHAR_SIZE];
 
    printf("Enter string1: ");
    scanf("%s", str1);
    printf("Enter string2: ");
    scanf("%s", str2);
    alphacheck(str1, a1);
    alphacheck(str2, a2);
    create(str1_alpha, a1);
    create(str2_alpha, a2);
    if (strcmp(str1_alpha, str2_alpha) == 0)
    {
        printf("All characters match in %s and %s.\n", str1, str2);
        printf("The characters that match are: ");
        for (i = 0; i < strlen(str1_alpha); i++)
        {
            printf("%c, ", str1_alpha[i]);
        }
        printf("\n");
    }
    else
    {
        printf("All characters do not match in %s and %s.\n", str1, str2);
    }
 
    return 0;
}
 
void alphacheck(char *str, int a[])
{
    int i, index;
 
    for (i = 0; i < strlen(str); i++)
    {
        str[i] = tolower(str[i]);
        index = str[i] - 'a';
        if (!a[index])
        {
            a[index] = 1;
        }
    }
}
 
void create(char *str, int a[])
{
    int i, j = 0;
 
    for (i = 0; i < CHAR_SIZE; i++)
    {
        if (a[i])
        {
            str[j++] = i + 'a';
        }
    }
    str[j] = '\0';
}
 ETP 
 
 C Program to Check whether a given Character is present in a String, Find Frequency & Position of Occurrence 
================================ EOPN
/* 
 * C Program to Check whether a given Character is present in a
 * String, Find Frequency & Position of Occurrence 
 
================================ EOKW
--------------------------------
output:
 
$ cc charfrequency.c
$ ./a.out
Enter character: r
Now enter the word: programming
Positions of 'r' in programming are: 2  5  
Character 'r' occured for 2 times.
--------------------------------

#include <stdio.h>
#include <string.h>
 
int main()
{
    char a, word[50];
    int i, freq = 0, flag = 0;
 
    printf("Enter character: ");
    scanf("%c", &a);
    printf("Now enter the word: ");
    scanf("%s", word);
    printf("Positions of '%c' in %s are: ", a, word);
    for (i = 0; i < strlen(word); i++)
    {
        if (word[i] == a)
        {
            flag = 1;
            printf("%d  ", i + 1);
            freq++;
        }
    }
    if (flag)
    {
        printf("\nCharacter '%c' occured for %d times.\n", a, freq);
    }
    else
    {
        printf("None\n");
    }
 
    return 0;
}
 ETP 
 
 C Program to Count the Number of Occurrence of each Character Ignoring the Case of Alphabets & Display them 
================================ EOPN
/* * C Program to Count the Number of Occurrence of * each Character Ignoring the Case of Alphabets * & Display them 
================================ EOKW
--------------------------------
output:
$ cc allcharfreq.c
$ ./a.out
Enter string: A quIck brOwn fox JumpEd over a lazy dOg
The string entered is: A quIck brOwn fox JumpEd over a lazy dOg
*************************
Character   Frequency
*************************
     a         3
     b         1
     c         1
     d         2
     e         2
     f         1
     g         1
     i         1
     j         1
     k         1
     l         1
     m         1
     n         1
     o         4
     p         1
     q         1
     r         2
     u         2
     v         1
     w         1
     x         1
     y         1
     z         1
--------------------------------
#include <stdio.h>
#include <string.h>
#include <ctype.h>

struct detail
{
char c;
int freq;
};

int main()
{
struct detail s[26];
char string[100], c;
int i = 0, index;

for (i = 0; i < 26; i++)
{
s[i].c = i + 'a';
s[i].freq = 0;
}
printf("Enter string: ");
i = 0;
do
{
fflush(stdin);
c = getchar();
string[i++] = c;
if (c == '\n')
{
break;
}
c = tolower(c);
index = c - 'a';
s[index].freq++;
} while (1);
string[i - 1] = '\0';
printf("The string entered is: %s\n", string);

printf("*************************\nCharacter\tFrequency\n*************************\n");
for (i = 0; i < 26; i++)
{
if (s[i].freq)
{
printf("     %c\t\t   %d\n", s[i].c, s[i].freq);
}
}

return 0;
}
 ETP 
 
 C Program to Count the Occurrences of each C Keyword using Array Structure 
================================ EOPN
/* * C Program to Count the Occurrences of each C Keyword * using Array Structure 
================================ EOKW
--------------------------------
output:
$ gcc keywordoccur.c 
$ ./a.out
Enter string: break, float and double are c keywords. float and double are primitive data types.  
The string entered is: break, float and double are c keywords. float and double are primitive data types.
***********************
   Keyword  Count
***********************
    break     1
    double    2
    float     2
--------------------------------
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define KEYMAX 32

struct keyword
{
char word[10];
int occur;
};

int binarysearch(char [], struct keyword[]);

int main()
{
int i = 0, j = 0, pos;
char string[100], unit[20], c;
struct keyword key[32] = {"auto", 0, "break", 0, "case", 0,
"char", 0, "const", 0, "continue", 0,
"default", 0, "do", 0, "double", 0,
"else", 0, "enum", 0, "extern", 0,
"float", 0, "for", 0, "goto", 0,
"if", 0, "int", 0, "long", 0,
"register", 0, "return", 0, "short", 0,
"signed", 0, "sizeof", 0, "static", 0,
"struct", 0, "switch", 0, "typedef", 0,
"union", 0, "unsigned", 0, "void", 0,
"volatile", 0, "while", 0,};

printf("Enter string: ");
do
{
fflush(stdin);
c = getchar();
string[i++] = c;

} while (c != '\n');
string[i - 1] = '\0';
printf("The string entered is: %s\n", string);
for (i = 0; i < strlen(string); i++)
{
while (i < strlen(string) && string[i] != ' ' && isalpha(string[i]))
{
unit[j++] = tolower(string[i++]);
}
if (j != 0)
{
unit[j] = '\0';
pos = binarysearch(unit, key);
j = 0;
if (pos != -1)
{
key[pos].occur++;
}
}
}
printf("***********************\n   Keyword\tCount\n***********************\n");
for (i = 0; i < KEYMAX; i++)
{
if (key[i].occur)
{
printf("    %s\t  %d\n", key[i].word, key[i].occur);
}
}

return 0;
}

int binarysearch(char *word, struct keyword key[])
{
int low, high, mid;

low = 0;
high = KEYMAX - 1;
while (low <= high)
{
mid = (low + high) / 2;
if (strcmp(word, key[mid].word) < 0)
{
high = mid - 1;
}
else if (strcmp(word, key[mid].word) > 0)
{
low = mid + 1;
}
else
{
return mid;
}
}

return -1;
}
 ETP 
 
 C Program to Find the First Occurence of the any Character of String2 in String1 
================================ EOPN
/
================================ EOKW
--------------------------------
output:
 
enter the string1:C Programming Class
 
enter the string2:rnp
 
first occurance of character of string2 in string1 is at position:3 and character is p
--------------------------------
#include <stdio.h>

void main()
{
char s1[50], s2[10];
int i, flag = 0;
char *ptr1, *ptr2;

printf("\nenter the string1:");
scanf(" %[^\n]s", s1);
printf("\nenter the string2:");
scanf(" %[^\n]s", s2);

/*COMPARING THE STRING1 CHARACTER BY CHARACTER WITH ALL CHARACTERS OF STRING1*/
for (i = 0, ptr1 = s1;*ptr1 !=  '\0';ptr1++)
{
i++;
for (ptr2 = s2; *ptr2 != '\0';ptr2++)
{
if (*ptr1  ==  *ptr2)
{
flag = 1;
break;
}
}
if (flag  ==  1)
break;
}

if (flag  ==  1)
printf("\nfirst occurance of character of string2 in string1 is at position:%d and character is %c", i, *ptr2);
else
printf("\nnone of the characters of string1 match with mone of characters of string2");
}
 ETP 
 
 C Program to find First and Last Occurrence of given Character in a String 
================================ EOPN
/*  * C Program to find First and Last Occurrence of given  * Character in a String 
================================ EOKW
--------------------------------
output:
enter the string
welcome to sanfoundry's c programming class!
enter character to be searched
m
6 
34
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int i, count = 0, pos1, pos2;
char str[50], key, a[10];

printf("enter the string\n");
scanf(" %[^\n]s", str);
printf("enter character to be searched\n");
scanf(" %c", &key);
for (i = 0;i <= strlen(str);i++)
{
if (key == str[i])
{
count++;
if (count  == 1)
{
pos1 = i;
pos2 = i;
printf("%d\n", pos1 + 1);
}
else
{
pos2 = i;
}
}
}
printf("%d\n", pos2 + 1);
}
 ETP 
 
 C Program to Find the Most/Least Repeated Character in the String 
================================ EOPN
/*
 *C Program to Find the Most/Least Repeated Character in the String
 
================================ EOKW
--------------------------------
output:
 
$ gcc minmaxchar.c 
$ ./a.out
Enter string: I love C programming
The string entered is: I love C programming
The most repeated characters are: g i m o r 
The least repeated characters are: a c e l n p v
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
 
struct detail
{
    char c;
    int freq;
};
 
int main()
{
    struct detail s[26];
    char string[100], c;
    int max[26] = {0}, min[26] = {0};
    int i = 0, index, maxcount = 1, mincount = 1000, j;
 
    for (i = 0; i < 26; i++)
    {
       s[i].c = i + 'a';
       s[i].freq = 0;
    }
    printf("Enter string: ");
    i = 0;
    do
    {
        fflush(stdin);
        c = getchar();
        string[i++] = c;
        if (c == '\n')
        {
            break;
        }
        else if (!isalpha(c))
        {
            continue;
        }
        c = tolower(c);
        index = c - 'a';
        s[index].freq++;
    } while (1);
    string[i - 1] = '\0';
    printf("The string entered is: %s\n", string);
    for (i = 0; i < 26; i++)
    {
        if (s[i].freq)
        {
            if (maxcount < s[i].freq)
            {
                for (j = 0; j < 26; j++)
                {
                    max[j] = 0;
                }
                max[i] = 1;
                maxcount = s[i].freq;
            }
            else if (maxcount == s[i].freq)
            {
                max[i] = 1;
            }
            if (mincount >= s[i].freq)
            {
                if (mincount == s[i].freq)
                {
                    min[i] = 1;
                }
                else
                {
                    for (j = 0; j < 26; j++)
                    {
                        min[j] = 0;
                    }
                    min[i] = 1;
                    mincount = s[i].freq;
                }
            }
        }
    }
    printf("The most repeated characters are: ");
    for (i = 0; i < 26; i++)
    {
        if (max[i])
        {
            printf("%c ", i + 'a');
        }
    }
    printf("\nThe least repeated characters are: ");
    for (i = 0; i < 26; i++)
    {
        if (min[i])
        {
            printf("%c ", i + 'a');
        }
    }
    printf("\n");
 
    return 0;
}
 ETP 
 
 C Program to Count the Occurence of a Substring in String 
================================ EOPN
/*  * C Program To Count the Occurrence of a Substring in String  
================================ EOKW
--------------------------------
output:
 
 
Enter a string : prrrogram c prrrogramming
 
Enter a substring : rr
rr occurs 2 times in prrrogram c prrrogramming
--------------------------------
#include <stdio.h>
#include <string.h>

char str[100], sub[100];
int count = 0, count1 = 0;

void main()
{
int i, j, l, l1, l2;

printf("\nEnter a string : ");
scanf("%[^\n]s", str);

l1 = strlen(str);

printf("\nEnter a substring : ");
scanf(" %[^\n]s", sub);

l2 = strlen(sub);

for (i = 0; i < l1;)
{
j = 0;
count = 0;
while ((str[i] == sub[j]))
{
count++;
i++;
j++;
}
if (count == l2)
{
count1++;
count = 0;
}
else
i++;
}
printf("%s occurs %d times in %s", sub, count1, str);
}
 ETP 
 
 C Program to Determine if One String is a Circular Permutation of Another String 
================================ EOPN
/* * C Program to Determine if One String is a Circular Permutation of * Another String  
================================ EOKW
--------------------------------
output:
$ gcc circularpermu.c 
$ ./a.out
Enter string 1: abcd
Enter string 2: dabc
abcd & dabc are circular permutation of each other.
--------------------------------
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#define CHAR_SIZE 26

void alphacheck(char *, int []);
void create(char [], char [], int[]);

int main()
{
char str1[50], str2[50];
int a1[CHAR_SIZE] = {0};
char str2_rem[50];

printf("Enter string1: ");
scanf("%s", str1);
printf("Enter string2: ");
scanf("%s", str2);
alphacheck(str1, a1);
create(str2_rem, str2, a1);
printf("On removing characters from second string we get: %s\n", str2_rem);

return 0;
}

void alphacheck(char *str, int a[])
{
int i, index;

for (i = 0; i < strlen(str); i++)
{
str[i] = tolower(str[i]);
index = str[i] - 'a';
if (!a[index])
{
a[index] = 1;
}
}
printf("\n");
}

void create(char str_rem[], char str[], int list[])
{
int i, j = 0, index;

for (i = 0; i < strlen(str); i++)
{
index = str[i] - 'a';
if (!list[index])
{
str_rem[j++] = str[i];
}
}
str_rem[j] = '\0';
}
 ETP 
 
 C Program to Find the Consecutive Occurrence of any Vowel in a String 
================================ EOPN
/* * C Program to Find the Consecutive Occurrence of any Vowel * in a String 
================================ EOKW
--------------------------------
output:
$ gcc consecutivevowel.c 
$ ./a.out
Enter string: Who will lead his team to victory
The string entered is: Who will lead his team to victory
**Words with consecutive vowel**
lead
team
--------------------------------
#include <stdio.h>
#include <string.h>
#include <ctype.h>

struct detail
{
char word[20];
};

int update(struct detail [], const char [], int);
int vowelcheck(char);

int main()
{
struct detail s[10];
char string[100], unit[20], c;
int i = 0, j = 0, count = 0;

printf("Enter string: ");
i = 0;
do
{
fflush(stdin);
c = getchar();
string[i++] = c;

} while (c != '\n');
string[i - 1] = '\0';
printf("The string entered is: %s\n", string);
for (i = 0; i < strlen(string); i++)
{
while (i < strlen(string) && string[i] != ' ' && isalnum(string[i]))
{
unit[j++] = string[i++];
}
if (j != 0)
{
unit[j] = '\0';
count = update(s, unit, count);
j = 0;
}
}

printf("**Words with consecutive vowel**\n");
for (i = 0; i < count; i++)
{
printf("%s\n", s[i].word);
}

return 0;
}

int update(struct detail s[], const char unit[], int count)
{
int i, j = 0;

for (i = 0; i < strlen(unit) - 1; i++)
{
if (vowelcheck(unit[i]))
{
if (vowelcheck(unit[i+ 1]))
{
/*To avoid duplicate strings*/
while (j < count && strcmp(s[j].word, unit))
{
j++;
}
if (j == count)
{
strcpy(s[j].word, unit);

return (count + 1);
}
}
}
}

return count;
}

int vowelcheck(char c)
{
char vowel[5] = {'a', 'e', 'i', 'o', 'u'};
int i;

c = tolower(c);
for (i = 0; i < 5; i++)
{
if (c == vowel[i])
{
return 1;
}
}

return 0;
}
 ETP 
 
 C Program to Input 2 Binary Strings and Print their Binary Sum 
================================ EOPN
/* * C Program to Input 2 Binary Strings and Print their Binary  * Sum  
================================ EOKW
--------------------------------
output:
$ gcc binarynum.c
$ ./a.out
Enter binary number 1: 0110 
Enter binary number 2: 1011
0110 + 1011 = 10001
--------------------------------
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int bin_verify(char []);
void sum(char [], char [], char []);

int main()
{
char bin1[33], bin2[33], result[33];
int len1, len2, check;

printf("Enter binary number 1: ");
scanf("%s", bin1);
printf("Enter binary number 2: ");
scanf("%s", bin2);
check = bin_verify(bin1);
if (check)
{
printf("Invalid binary number %s.\n", bin1);
exit(0);
}
check = bin_verify(bin2);
if (check)
{
printf("Invalid binary number %s.\n", bin2);
exit(0);
}
sum(bin1, bin2, result);
printf("%s + %s = %s\n", bin1, bin2, result);

return 0;
}

int bin_verify(char str[])
{
int i;

for (i = 0; i < strlen(str); i++)
{
if ((str[i] - '0' != 1 ) && (str[i] - '0' != 0))
{
return 1;
}
}

return 0;
}

void sum(char bin1[], char bin2[], char result[])
{
int i = strlen(bin1) - 1;
int j = strlen(bin2) - 1;
int carry = 0, temp, num1, num2;

while (i > -1 && j > -1)
{
num1 = bin1[i] - '0';
num2 = bin2[j] - '0';
temp = num1 + num2 + carry;
if (temp / 2 == 1)
{
carry = 1;
temp %= 2;
}
if (i > j)
{
result[i + 1] = temp + '0';
result[strlen(bin1) + 1] = '\0';
}
else
{
result[j +1] = temp + '0';
result[strlen(bin2) + 1] = '\0';
}
i--;
j--;
}
while (i > -1)
{
temp = bin1[i] + carry - '0';
if (temp / 2 == 1)
{
carry = 1;
temp %= 2;
}
result[i + 1] = temp + '0';
i--;
}
while (j > -1)
{
temp = bin2[j] + carry - '0';
if (temp / 2 == 1)
{
carry = 1;
temp %= 2;
}
result[j + 1] = temp + '0';
j--;
}
if (carry)
{
result[0] = '1';
}
else
{
result[0] = '0';
}
}
 ETP 
 
 C Program to Input a String with at least one Number, Print the Square of all the Numbers in a String 
================================ EOPN
/*
 * C Program to Input a String with atleast one Number, Print
 * the Square of all the Numbers in a String 
 
================================ EOKW
--------------------------------
output:
 
$ gcc numbersquare.c -lm
$ ./a.out
Enter string: 1 2 3 4 5
The string entered is: 1 2 3 4 5
*****************
Number  Square
*****************
1      1
2      4
3      9
4      16
5      25
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
 
struct detail
{
    int number;
    int square;
};
 
int update(struct detail [], int, int);
int toint(char []);
 
int main()
{
    struct detail s[10];
    char unit[20], string[100];
    char c;
    int num, i, j = 0, count = 0;
 
    printf("Enter string: ");
    i = 0;
    do
    {
        fflush(stdin);
        c = getchar();
        string[i++] = c;
 
    } while (c != '\n');
    string[i - 1] = '\0';
    printf("The string entered is: %s\n", string);
    for (i = 0; i < strlen(string); i++)
    {
        while (i < strlen(string) && !isspace(string[i]))
        {
            unit[j++] = string[i++];
        }
        if (j != 0)
        {
            unit[j] = '\0';
            num = toint(unit);
            count = update(s, num, count);
            j = 0;
        }
    }
    printf("*****************\nNumber\tSquare\n*****************\n");
    for (i = 0; i < count; i++)
    {
        printf("%d\t   %d\n", s[i].number, s[i].square);
    }
 
    return 0;
}
 
int update(struct detail s[], int num, int count)
{
    s[count].number = num;
    s[count].square = num * num;
 
    return (count + 1);
}
 
int toint(char str[])
{
    int len = strlen(str);
    int i, num = 0;
 
    for (i = 0; i < len; i++)
    {
        num = num + ((str[len - (i + 1)] - '0') * pow(10, i));
    }
 
   return num;
}
 ETP 
 
 C Program which Converts an Integer to String & vice-versa 
================================ EOPN
/*
 * C Program which Converts an Integer to String & vice-versa
 
================================ EOKW
--------------------------------
output:
 
$ gcc stringtoint.c -lm
$ ./a.out
Enter a number: 12345
Number converted to string: 12345
Number converted back to integer: 12345
--------------------------------

#include <stdio.h>
#include <string.h>
#include <math.h>
 
void tostring(char [], int);
int toint(char []);
 
int main()
{
    char str[10];
    int num, result;
 
    printf("Enter a number: ");
    scanf("%d", &num);
    tostring(str, num);
    printf("Number converted to string: %s\n", str);
    result = toint(str);
    printf("Number converted back to integer: %d\n", result);
 
    return 0;
}
 
void tostring(char str[], int num)
{
    int i, rem, len = 0, n;
 
    n = num;
    while (n != 0)
    {
        len++;
        n /= 10;
    }
    for (i = 0; i < len; i++)
    {
        rem = num % 10;
        num = num / 10;
        str[len - (i + 1)] = rem + '0';
    }
    str[len] = '\0';
}
 
int toint(char str[])
{
    int len = strlen(str);
    int i, num = 0;
 
    for (i = 0; i < len; i++)
    {
        num = num + ((str[len - (i + 1)] - '0') * pow(10, i));
    }
 
   return num;
}
 ETP 
 
 C program that takes input as 2323 and gives output as 2332. ie. the new number should be greater than the previous number but should have the same digits 
================================ EOPN
/* * C program that takes input as 2323 and gives output as 2332.  * ie.the new number should be greater than the previous number * but should have the same digits 
================================ EOKW
--------------------------------
output:
Enter a number: 56732   
The number greater than 56732 and made of same digits is 57632.
--------------------------------
#include <stdio.h>
#include <math.h>

int evaluate(int [], int);
int find(int);

int main()
{
int num, result;

printf("Enter a number: ");
scanf("%d", &num);
result = find(num);
if (result)
{
printf("The number greater than %d and made of same digits is %d.\n", num, result);
}
else
{
printf("No higher value possible. Either all numbers are same or the digits of the numbers entered are in decreasing order.\n");
}

return 0;
}

int find(int num)
{
int digit[20];
int i = 0, len = 0, n, temp;

n = num;
while (n != 0)
{
digit[i] = n % 10;
n = n / 10;
i++;
}
len = i;
for (i = 0; i < len - 1; i++)
{
if (digit[i] > digit[i + 1])
{
temp = digit[i];
digit[i] = digit[i + 1];
digit[i + 1] = temp;

return (evaluate(digit, len));
}
}

return 0;
}

int evaluate(int digit[], int len)
{
int i, num = 0;

for (i = 0; i < len; i++)
{
num += digit[i] * pow(10, i);
}

return num;
}
 ETP 
 
 C Program to Find the Sum of ASCII values of All Characters in a given String 
================================ EOPN
 /*  * C Program To Find the Sum of ASCII values of All Characters in a  * given String 
================================ EOKW
--------------------------------
output:
Enter the string : Welcome to Sanfoundry's C Programming Class, Welcome Again to C Class !
 
Sum of all characters : 6307
--------------------------------
#include <stdio.h>
#include <string.h>

void main()
{
int sum = 0, i, len;
char string1[100];

printf("Enter the string : ");
scanf("%[^\n]s", string1);
len = strlen(string1);
for (i = 0; i < len; i++)
{
sum = sum + string1[i];
}
printf("\nSum of all characters : %d ",sum);
}
 ETP 
 
  C Program to Check whether the given Integer has an Alternate Pattern 
================================ EOPN
/*
 * C Program to Check whether the given Integer has an Alternate 
 * Pattern 
 
================================ EOKW
--------------------------------
output:
$ gcc alternative.c -o alternative
$ ./alternative
 
Enter the number: 10
 
COUNT : 4
TRUE : ALTERNATIVE PATTERN DOES EXIST
--------------------------------

#include <stdio.h>
#include <stdlib.h>
int main ()
{
    int num = 0, n = 0, i =0;
    int count = 0;
    printf("Enter the number: ");
    scanf ("%d", &num);
    n = num;
    // first lets count the number of bits
    while (n)
    {
        count ++;
        n = n >> 1;
    }
    printf ("\n COUNT : %d", count);
 
    // now check for alternative
    for (i = 0; i <= count - 2; i++)
    {
        if (((num >> i) & 1) == ((num >> (i+2)) & 1))
        {
            continue;
        }
        else
        {
            printf ("\nFALSE : ALTERNATIVE PATTERN DOES NOT EXIST\n");
            exit (0);
        }
 
    }
    printf ("\nTRUE : ALTERNATIVE PATTERN DOES EXIST\n");
        return 0;
}
 ETP 
 
  C Program to round Floor of integer to next Lower Power of 2 
================================ EOPN
/*
 * C Program to round floor of integer to next lower power of 2
 
================================ EOKW
--------------------------------
output:
$ gcc next_pow.c -o next_pow
$ ./next_pow
 
Enter the number: 10
NEXT NUMBER LOWER TO THE POWER OF 2 : 16
--------------------------------

#include <stdio.h>
 
int main ()
{
    int num = 0;
    printf("\nEnter the number: ");
    scanf ("%d", &num);
    num --;
    num = num | (num >> 1);
    num = num | (num >> 2);
    num = num | (num >> 4);
    num = num | (num >> 8);
    num = num | (num >> 16);
    num ++;
    printf ("\n NEXT NUMBER LOWER TO THE POWER OF 2 : %d\n", num);
    return 0;
}
 ETP 
 
  C Program that uses Function to return MSB position of unsigned Integer 
================================ EOPN
/* * C Program that uses Function to return MSB position of unsigned Integer 
================================ EOKW
--------------------------------
output:
$ cc bit24.c
$ a.out
Enter a number : 127
 
Position of MSB bit = 6
 
Enter a number : 259
 
Position of MSB bit = 8
 
Enter a number : 5
 
Position of MSB bit = 2
--------------------------------
#include <stdio.h>
#define NUM_BITS_INT 32
int int_msb_position(int n);

void main()
{
int n, pos;

printf("Enter a number : ");
scanf("%d", &n);
pos = int_msb_position(n);
printf("\nPosition of MSB bit = %d\n", NUM_BITS_INT - (pos + 1));
}

/* Function to find the MSB bit position */
int int_msb_position(int n)
{
int i = 0, bit;
while (i < NUM_BITS_INT)
{
bit = n & 0x80000000;
if (bit == -0x80000000)
{
bit = 1;
}
if (bit == 1)
break;
n = n << 1;
i++;
}
return i;
}
 ETP 
 
  C Program to use Bitwise Operations to Round(floor of) an Integer to next Lower Multiple of 2 
================================ EOPN
/*  * C Program to use Bitwise Operations to Round(floor of) an Integer  * to next Lower Multiple of 2 
================================ EOKW
--------------------------------
output:
$ cc bit10.c
$ a.out
enter the number :9
8
$ a.out
enter the number :44
32
$ a.out
enter the number :-20
-32
$ a.out
enter the number :-84
-128
--------------------------------
#include <stdio.h>

void main()
{
int x = 1, i, n;

printf("enter the number :");
scanf("%d", &n);
/* for positive values */
if (n > 0)
{
for (; x <= n >> 1;)
{
x = x << 1;
}
n = x;
}
/* for negative values */
else
{
n = ~n;
n = n + 1;
for (; x <= n >> 1;)
{
x = x << 1;
}
x = x << 1;
x = ~x;
x = x + 1;
n = x;
}
printf("%d", n);
}
 ETP 
 
  C Program to Print the Range of Fundamental Data Types 
================================ EOPN
/* * C Program to Print the Range  
================================ EOKW
--------------------------------
output:
 
range of int
-2147483648 to 2147483647
range of unsigned int
0 to 4294967295
range of char
-128 to 127
range of unsigned char
0 to 255
range of short
-32768 to 32767
range of unsigned short
0 to 65535
--------------------------------
#include <stdio.h>
#define SIZE(x) sizeof(x)*8

void signed_one(int);
void unsigned_one(int);

void main()
{
printf("\nrange of int");
signed_one(SIZE(int));
printf("\nrange of unsigned int");
unsigned_one(SIZE(unsigned int));
printf("\nrange of char");
signed_one(SIZE(char));
printf("\nrange of unsigned char");
unsigned_one(SIZE(unsigned char));
printf("\nrange of short");
signed_one(SIZE(short));
printf("\nrange of unsigned short");
unsigned_one(SIZE(unsigned short));

}
/* RETURNS THE RANGE SIGNED*/
void signed_one(int count)
{
int min, max, pro;
pro = 1;
while (count != 1)
{
pro = pro << 1;
count--;
}
min = ~pro;
min = min + 1;
max = pro - 1;
printf("\n%d to %d", min, max);
}
/* RETURNS THE RANGE UNSIGNED */
void unsigned_one(int count)
{
unsigned int min, max, pro = 1;

while (count != 0)
{
pro = pro << 1;
count--;
}
min = 0;
max = pro - 1;
printf("\n%u to %u", min, max);
}
 ETP 
 
  C Program to Check if All the Bits of a given Integer is One(1) 
================================ EOPN
/*
 * C Program to check if all the bits of a given integer is one(1)
 
================================ EOKW
--------------------------------
output:
$ cc bit22.c
$ a.out
Enter the number : 0
 
FALSE : ALL BITS ARE NOT SET
--------------------------------
 
#include <stdio.h>
#include <stdlib.h>
int main ()
{
    int num = 0, count = 0, n = 0, i = 0;
 
    printf ("\nEnter the number : ");
    scanf ("%d", &num);
    n = num;
    if (num == 0)
    {
        printf ("\nFALSE : ALL BITS ARE NOT SET\n");
        exit (0);
    }
    while (n)
    {
        count ++;
        n = n >> 1;
    }
    for (i = 0; i < count; i++)
    {
        if (((num >> i) & 1) == 1)
        {
            continue;
        }
        else
        {
            printf ("\nFALSE : ALL BITS ARE NOT SET\n");
            exit (0);
        }
    }
    printf ("\nTRUE : ALL BITS ARE SET\n");
    return 0;
}
 ETP 
 
  C Program to find Next higher Value of N with same 1’s 
================================ EOPN
/*
 * C Program to next higher value of n with same 1's
 
================================ EOKW
--------------------------------
output:
 
$ cc bit18.c
$ a.out
Enter a number : 128
The next highest number is : 256 
Enter a number : 127
The next highest number is : 191
Enter a number : 6
The next highest number is : 9
Enter a number : 12
The next highest number is : 17
--------------------------------

#define NUM_BITS_INT 32
#include <stdio.h>
#include <stdlib.h>
int newcount(int);
void main()
{
    int count1 = 0, k = 0, j, t, n, bit, i = 1, count = 0;
    printf("Enter a number : ");
    scanf("%d", &n);
    t = n;
 
    if (t == 0)
    {
        printf ("\nThe next highest number is : 1\n");
        exit (0);
    }
 
    while(t != 0)
    {
        bit = t & 0x80000000;
        if (bit == -0x80000000) 
        {
            bit = 1;  
        }
        if (bit == 1) 
            count++;
        t = t << 1;
 
    }
    for (k = n + 1;;k++)
    {
        count1 = newcount(k);    
        if (count1 == count)
        {
            printf("The next highest number is : %d ", k);
            break;
        }
    }
}
 
/* To count the no. of 1's in the no. 
 ETP 
 
  C Program to Count the Number of Trailing Zeroes in Integer 
================================ EOPN
/*
 * C Program to Count the Number of Trailing Zeroes in Integer
 
================================ EOKW
--------------------------------
output:
 
$ cc bit4.c
$ ./a.out
enter the number:128
7
$ ./a.out
enter the number:-127
0
--------------------------------

#include <stdio.h>
 
void main()
{
    int j = 31, i, count = 0;
    unsigned int num;
    int b[32] = {0};
 
    printf("enter the number:");
    scanf("%d", &num);
    while (num != 0)
    {
        if (num & 1 == 1)
        {
            break;
        }
        else
        {
            count++;
            num = num >> 1;
 
        }
    }
    printf("\n%d", count);
}
 ETP 
 
  C Program to Use Bitwise Operations to Count the Number of Leading Zero’s in a Number x 
================================ EOPN
/*
 * C Program to Use Bitwise Operations to Count the Number of 
 * Leading Zero's in a Number x
 
================================ EOKW
--------------------------------
output:
gcc leading_zeros.c -o leading-zero
./leading-zero
 
Enter the digit: 16
Number of leading zero's is: 27
--------------------------------

#include <stdio.h>
#include <malloc.h>
 
int main()
{
    int lim = sizeof(int) * 8;
    // the mBit is 1000 0000 0000 0000 0000 0000 0000 0000
    int mBit = 1 << (lim - 1);
    int num = 0, count = 0;
    printf ("Enter the digit: ");
    scanf ("%d", &num); 
    while (!(num & mBit))
    {
        num = (num << 1);
        count ++;
    }
    printf ("\nNumber of leading zero's is: %d\n", count);
    return 0;
}
 ETP 
 
  C Program to find the Highest Bit Set for any given Integer 
================================ EOPN
/*
 * C Program to find the Highest Bit Set for any given Integer
 
================================ EOKW
--------------------------------
output:
 
$ cc bit17.c
$ a.out
enter the number:10000
000000000000000000010011100010000
the position of the highest bit set is 13
--------------------------------

#include <stdio.h>
#define NUM_BITS sizeof(int)*8
 
int highest_bit_set(int);
void display(int);
int i = NUM_BITS;
 
void main()
{
    int num, pos;
 
    printf("\nenter the number:");
    scanf("%d", &num);
 
    display(num);
    pos = highest_bit_set(num);
    printf("\nthe position of the highest bit set is %d", pos);
}
/* RETURNS THE POSITION 
 ETP 
 
  C Program to Count Number of bits set to 0 in an Integer 
================================ EOPN
/*
 * C Program to Count Number of bits set to 0 in a Integer x
 
================================ EOKW
--------------------------------
output:
$ gcc count_bits_unset.c -o bits_unset_count
$ ./bits_unset_count
 
Enter the number: 1
Number of bit's set to zero's are: 0
--------------------------------

#include <stdio.h>
 
int main ()
{
    int num = 0, i = 0, n = 0, count = 0, zCount = 0;
    printf ("Enter the number: ");
    scanf ("%d", &num);
    n = num;
    while (n)
    {
        count ++;
        n = n >> 1;
    }
    for (i = 0; i < count; i++)
    {
        if (((num >> i) & 1) == 0)
        {
            zCount ++;
        }
    }
    printf ("\nNumber of bit's set to zero's are: %d\n", zCount);
    return 0;
}
 ETP 
 
  C Program to Replace Bits in Integer from Specified Positions from Another Integer 
================================ EOPN
/*
 * C Program to Replace Bits in Integer from Specified Positions from 
 * Another Integer
 
================================ EOKW
--------------------------------
output:
$ gcc replace_bits.c -o replace
$ ./replace
 
Enter the first number: 10
 
Enter the second number: 10
 
Enter the i'th bit in num1 to replace with j'th bit in num2: 2
 
Enter the j'th bit in num2 to replace with i'th bit in num1: 1
 
Result = 14
--------------------------------

#include <stdio.h>
 
int main ()
{
    int num1 = 0, num2 = 0, i = 0, j = 0, xor = 0, res = 0;
    printf ("Enter the first number: ");
    scanf ("%d", &num1);
    printf ("\nEnter the second number: ");
    scanf ("%d", &num2);
    printf ("Enter the i'th bit in num1 to replace with j'th bit in num2: ");
    scanf ("%d", &i);
    printf ("\nEnter the j'th bit in num2 to replace with i'th bit in num1: ");
    scanf ("%d", &j);
    printf ("\n");
    if (num1 == num2 && i == j)
    {
        printf ("%d",num1);
        printf ("\n");
        return 0;
    }
    xor = ((num1 >> i) ^ (num2 >> j)) & 1;
    res = num1 ^ (xor << i) ^ (xor ^ j);
    printf ("\nResult = %d\n", res);
    return 0;
}
 ETP 
 
  C Program to Replace Bits in Integer x from Bit Position a to b from another Integer y 
================================ EOPN
/*
 * C Program to Replace Bits in Integer x from Bit Position a to b from another Integer y
 
================================ EOKW
--------------------------------
output:
 
$ cc bit13.c
$ a.out
**Replacing the bits in integer x from bit position a to b from another integer y**
read number 1
0x11223344
Read number 2:
0x55667788
Read LSB postion:
12
MSB should always be greater than LSB
Read MSB position:
19
the number num1 after shifting the bits is 0x11267344
--------------------------------

#include <stdio.h>
 
void changebits(int, int, int, int);
 
int main()
{
    int num1, num2, pos1, pos2;
 
    printf("**Replacing the bits in integer x from bit position a to b from another integer y**\n");
    printf("read number 1\n");
    scanf("%x", &num1);
    printf("Read number 2:\n");
    scanf("%x", &num2);
    printf("Read LSB postion:\n");
    scanf("%d", &pos1);
    printf("MSB should always be greater than LSB\n");
    printf("Read MSB position:\n");
    scanf("%d", &pos2);
    changebits(num1, num2, pos1, pos2);
    return 0;
}
 
/*Function to swap bits in given positions
 ETP 
 
  C Program takes Byte as Input and returns all the Bits between given Positions 
================================ EOPN
/*
 * C Program takes Byte as Input and returns all the Bits between 
 * given Positions
 
================================ EOKW
--------------------------------
output:
Enter the BYTE:
101
Enter a full 8-bit value.
--------------------------------

#include <stdio.h>
#include <string.h>
 
int main (int argc, char *argv[])
{
    int a = 0, b = 0, temp = 0, i = 0, countCast = 0;
 
    char BYTE_HERE[8];
    int FULL_BYTE[8];
 
    printf ("Enter the BYTE:  \n");
    gets(BYTE_HERE);
 
    if (strlen (BYTE_HERE) < 8) {
        printf ("Enter a full 8-bit value.\n");
        return 0;
    }
 
    printf ("\nEnter the positions a and b : \n");
    scanf ("%d %d", &a, &b);
 
    // copy from character array to integer array
    for (i = 0; i <  8; i++)
    {
            // convert the character to integer
            FULL_BYTE[i] = BYTE_HERE[i] - '0';
 
    }
 
    // just print the bits
    for (i = a; i <= b; i++)
    {
        printf ("%d ", FULL_BYTE[i]);
    }
    printf("\nBits between positions a and b are:\n");
 
    return 0;
}
 ETP 
 
  C Program to Swap the ith and jth Bits for a 32-Bit Integer 
================================ EOPN
/*
 * C Program to Swap the ith and jth Bits for a 32-Bit Integer
 
================================ EOKW
--------------------------------
output:
./a.out
Enter the number: 2
 
Enter position 1: 0
 
Enter position 2: 1
 
The result after swapping the respective bits are: 1
--------------------------------

#include <stdio.h>
#include <stdlib.h>
 
int main (int argc, char *argv[])
{
    int n = 0, num = 0, p = 0, q = 0;
 
    printf ("Enter the number: ");
    scanf ("%d", &n);
 
    printf ("\nEnter position 1: ");
    scanf ("%d", &p);
 
    printf ("\nEnter position 2: ");
    scanf ("%d", &q);
 
    num = n;
 
    // see if the bits are same. we use XOR operator to do so.
    if (((n & (1 << p)) >> p) ^ ((n & (1 << q)) >> q))
    {
        n ^= (1 << p);
        n ^= (1 << q);
    }
 
    printf ("\nThe result after swapping the respective bits are: %d\n", n);
 
    return 0;
}
 ETP 
 
  C Program to Check if a given Integer is Power of 2 using Bitwise Operators 
================================ EOPN
/*
 * C Program to Check if a given Integer is Power of 2 using Bitwise Operators
 
================================ EOKW
--------------------------------
output:
 
$ gcc bit25.c
$  a.out
Enter Number128
YES
$  a.out
Enter Number126
NO
--------------------------------

#include <stdio.h>
#define NUM_BITS_INT (8*sizeof(int))
 
int power_of_2(unsigned int);
 
int main()
{
    unsigned int num;
 
    printf("\nEnter Number");
    scanf("%d", &num);
    power_of_2(num);
}
 
/*
 * Finding the power of 2 using bit wise operators
 
 ETP 
 
  C Program to Swap two Integers without using Temporary Variables and Bitwise Operations 
================================ EOPN
/*
 * C Program to Swap two Integers without using Temporary Variables 
 * and Bitwise Operations
 
================================ EOKW
--------------------------------
output:
 
$ gcc bit28.c
$ a.out
Enter 2 nos:
4
7
 
You have entered x=4 y=7
Swapped . . . .
x=7 y=4
--------------------------------

#include <stdio.h>
 
// Function Prototype
void swap(int *, int *);
 
void main()
{
    int x, y;
    printf("Enter 2 nos: \n");
    scanf("%d %d", &x, &y);
    printf("\nYou have entered x = %d y = %d \n", x, y);
    swap(&x,&y);    // passing the 2 nos to the swap function
}
 
// function to swap the two numbers
void swap(int *a, int *b)
{
    *a = *a + *b;
    *b = *a - *b;
    *a = *a - *b;
    printf("Swapped . . . .\n"); // printing the swapped numbers
    printf("x = %d y = %d\n", *a, *b);
}
 ETP 
 
  C Program to Find the Position of String of 1-bits in a Number for a given Length 
================================ EOPN
/*
 * C Program to Find the Position of String of 1-bits in a Number 
 * for a given Length
 
================================ EOKW
--------------------------------
output:
 
$ cc bit7.c
$ a.out
**Finding the position of 1-bits in a number for given length**
enter a number
10000
enter the length
3
the position of 1 in the string : 10
$ a.out
enter a number
700
enter the length
4
the position of 1 in the string : 5
--------------------------------

#include <stdio.h>
 
void main()
{
    int n, len, pos = 0, i = 0, count = 0;
 
    printf("**Finding the position of 1-bits in a number for given length**\n");
    printf("enter a number\n");
    scanf("%d", &n);
    printf("enter the length\n");
    scanf("%d", &len);
    while (i <= 32)
    {
        if ((n & 1) ==  1)    //checking whether there is a 1-bit in the current position
        {
            count++;//counting the consecutive 1's in the integer
            pos = i;
            if (count ==  len)    //checking whether the length matches
            {
                break;
            }
        }
        if ((n & 1) ==  0)
        {
            count = 0;
        }
        n = n>>1;
        i++;
    }
    printf("the position of 1 in the string : %d\n", pos);
}
 ETP 
 
  C Program to Check if nth Bit in a 32-bit Integer is Set or not 
================================ EOPN
/*
 * C Program to Check if nth Bit in a 32-bit Integer is Set or not
 
================================ EOKW
--------------------------------
output:
 
$ cc bit32.c
$ a.out
Enter the unsigned integer:
101
enter position
4
NO
 
$ a.out
Enter the unsigned integer:
113
enter position
4
YES
--------------------------------

#include <stdio.h>
 
/* gloabal varaibles 
 ETP 
 
  C Program to Check if a given Bit Position is set to One or not 
================================ EOPN
/*
 * C Program to Check if a given Bit Position is set to One or not
 
================================ EOKW
--------------------------------
output:
 
$ cc bit14.c
$ a.out
Enter the unsigned integer:
128
enter position to be searched
7
TRUE
--------------------------------

#include <stdio.h>
 
void main()
{
    unsigned int number;
    int result, position;
 
    printf("Enter the unsigned integer:\n");
    scanf("%d", &number);
    printf("enter position to be searched\n");
    scanf("%d", &position);
    result = (number >> (position));
    if (result & 1)
        printf("TRUE\n");
    else
        printf("FALSE\n");    
}
 ETP 
 
  C Program to Perform Binary Addition of Strings and Print it 
================================ EOPN
/*
 *  C Program to Perform Binary Addition of Strings and Print it 
 
================================ EOKW
--------------------------------
output:
 
$ cc bit20.c
$ a.out
enter string1
00010001
enter string2
00010010
binary addition of number is
000100011
--------------------------------

#include <stdio.h>
#include <string.h>
 
/* global variables 
 ETP 
 
  C Program to Reverse all the Bits of an 32-bit Integer using Bitwise 
================================ EOPN
/*
 * C Program to Reverse all the Bits of an 32-bit Integer using 
 * Bitwise 
 
================================ EOKW
--------------------------------
output:
Enter the number: 2
 
The reversed resultant = 1
--------------------------------

#include <stdio.h>
 
int main ()
{
    int n = 0, num = 0, count = 0, rev_bits = 0;
    printf ("Enter the number: ");
    scanf ("%d", &n);
 
    while (n > 0)
    {
        // keep shifting each bit
        rev_bits = rev_bits << 1;
 
        // if the bit is 1 then we XOR with 1
        if (n & 1 == 1)
        {
            rev_bits = rev_bits ^ 1;
        }
 
        // right shift n
        n = n >> 1;
    }
 
    printf ("\nThe reversed resultant = %d\n", rev_bits);
 
    return 0;
}
 ETP 
 
  C Program to Count the Number of Bits needed to be Flipped to Integer X to Generate Integer Y 
================================ EOPN
/*
 * C Program to Count the Number of Bits needed to be Flipped 
 * to Integer X to Generate Integer Y
 
================================ EOKW
--------------------------------
output:
 
$ cc flip.c
$ a.out
Enter the number
127
Enter another number
125
flip count = 1
$ a.out
Enter the number
127
Enter another number
128
flip count = 8
$ a.out
Enter the number
42
Enter another number
21
flip count = 6
--------------------------------

#include <stdio.h>
#include <stdlib.h>
#define NUM_BITS_INT (sizeof(int)*8)
 
void main()
{
    int n, m, i, count = 0, a, b;
 
    printf("Enter the number\n");
    scanf("%d", &n);
    printf("Enter another number\n");
    scanf("%d", &m);
    for (i = NUM_BITS_INT-1;i >= 0;i--)
    {
        a = (n >> i)& 1;
        b = (m >> i)& 1;
        if (a != b)
            count++;
    }
    printf("flip count = %d\n", count);
}
 ETP 
 
  C Program to Count the Number of Bits set to One using Bitwise Operations 
================================ EOPN
/*
 * C Program to Count the Number of Bits set to One using 
 * Bitwise Operations
 
================================ EOKW
--------------------------------
output:
 
$ cc bit2.c
$ a.out
Enter the unsigned integer:
128
number of one's are :
1
 
$ a.out
Enter the unsigned integer:
-127
number of one's are :
26
--------------------------------

#include <stdio.h>
 
int main()
{
    unsigned int number;
    int count = 0;
 
    printf("Enter the unsigned integer:\n");
    scanf("%d", &number);
    while (number != 0)
    {
        if ((number & 1) == 1)
            count++;
        number = number >> 1;
    }
    printf("number of one's are :\n%d\n", count);
    return 0;
}
 ETP 
 
  C Program To Identify the Missing Number in an Integer Array of Size N-1 with Numbers[1,N] 
================================ EOPN
/*
 * C Program To Identify the Missing Number in an Integer 
 * Array of Size N-1 with Numbers[1,N]
 
================================ EOKW
--------------------------------
output:
 
$ cc bit29.c
$ a.out
enter the range of array
9
enter a[0]element into the array:1
enter a[1]element into the array:5
enter a[2]element into the array:2
enter a[3]element into the array:7
enter a[4]element into the array:3
enter a[5]element into the array:4
enter a[6]element into the array:10
enter a[7]element into the array:9
enter a[8]element into the array:6
The missing number -> 8
$ a.out
enter the range of array
4
enter a[0]element into the array:1
enter a[1]element into the array:5
enter a[2]element into the array:3
enter a[3]element into the array:2
The missing number -> 4
$ a.out
enter the range of array
4
enter a[0]element into the array:3
enter a[1]element into the array:2
enter a[2]element into the array:5
enter a[3]element into the array:4
The missing number -> 1
--------------------------------

#include <stdio.h>
#define MAX 15
int missing_number_array(int [],int);
 
int main()
{
    int a[MAX], num, i, n;
 
    printf("enter the range of array\n");
    scanf("%d", &n);
    for (i = 0;i < n;i++)
    {
        printf("enter a[%d]element into the array:", i);
        scanf("%d", &a[i]);
    }
    num = missing_number_array(a, n);
    printf("The missing number -> %d\n", num);
}
 
/* To find the missing number in array 
 ETP 
 
  C Program to Check whether the given Number is Palindrome or not using Bitwise Operator 
================================ EOPN
/*
 * C Program to Check whether the given Number is Palindrome 
 * or not using Bitwise Operator
 
================================ EOKW
--------------------------------
output:
 
$ cc bits21.c
$ a.out
Enter a number(max 255)153
The number 153 in binary is:10011001
NUMBER IS PALINDROME
 
$ a.out
Enter a number(max 255)24
The number 24 in binary is:00011000
NUMBER IS PALINDROME
--------------------------------

#include <stdio.h>
#include <string.h>
#define SIZE 8
/* Function Prototype 
 ETP 
 
  C Program to Swap two Numbers using Bitwise operators 
================================ EOPN
/* * C Program to Swap two Numbers using Bitwise operators 
================================ EOKW
--------------------------------
output:
$ cc bit27.c
$ a.out
 
Enter two numbers:45 76
The numbers before swapping are Number1= 45 Number2=76
The numbers after swapping are Number1= 76 Number2=45
--------------------------------
#include <stdio.h>
#include <string.h>

/* Function Prototype */
void swap(int*, int *);

void main()
{
int num1, num2;
printf("\nEnter two numbers:");
scanf("%d %d", &num1, &num2);
printf("\nThe numbers before swapping are Number1= %d Number2 = %d", num1, num2);
swap(&num1, &num2);        /* Call by Reference to function swap */
printf("\nThe numbers after swapping are Number1= %d Number2 = %d", num1, num2);
}

/* Code to swap two numbers using bitwise operator */
void swap(int *x, int *y)
{
*x = *x ^ *y;
*y = *x ^ *y;
*x = *x ^ *y;
}
 ETP 
 
 C Program to Create a Linked List & Display the Elements in the List 
================================ EOPN
/* * C program to create a linked list and display the elements in the list 
================================ EOKW
--------------------------------
output:
$ cc pgm98.c
$ a.out
Enter the data item
5
Do you want to continue(Type 0 or 1)?
0
 
status of the linked list is
5=>NULL
No. of nodes in the list = 1
 
$ a.out
Enter the data item
5
Do you want to continue(Type 0 or 1)?
1
Enter the data item
9
Do you want to continue(Type 0 or 1)?
1
Enter the data item
3
Do you want to continue(Type 0 or 1)?
0
 
status of the linked list is
5=>9=>3=>NULL
No. of nodes in the list = 3
--------------------------------
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main()
{
struct node
{
int num;
struct node *ptr;
};
typedef struct node NODE;

NODE *head, *first, *temp = 0;
int count = 0;
int choice = 1;
first = 0;

while (choice)
{
head  = (NODE *)malloc(sizeof(NODE));
printf("Enter the data item\n");
scanf("%d", &head-> num);
if (first != 0)
{
temp->ptr = head;
temp = head;
}
else
{
first = temp = head;
}
fflush(stdin);
printf("Do you want to continue(Type 0 or 1)?\n");
scanf("%d", &choice);

}
temp->ptr = 0;
/*  reset temp to the beginning */
temp = first;
printf("\n status of the linked list is\n");
while (temp != 0)
{
printf("%d=>", temp->num);
count++;
temp = temp -> ptr;
}
printf("NULL\n");
printf("No. of nodes in the list = %d\n", count);
}
 ETP 
 
 C Program to Read a Linked List in Reverse 
================================ EOPN
/* * C Program to Read a Linked List in Reverse  
================================ EOKW
--------------------------------
output:
$ cc readreverse.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Displaying the nodes in the list:
1   2   3   4   5   
Displaying the list in reverse:
5   4   3   2   1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void reversedisplay(struct node *);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
struct node_occur *head = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the nodes in the list:\n");
display(p);
printf("Displaying the list in reverse:\n");
reversedisplay(p);
release(&p);

return 0;
}

void reversedisplay(struct node *head)
{
if (head != NULL)
{
reversedisplay(head->next);
printf("%d\t", head->num);
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
C Program to Search for an Element in the Linked List using Recursion
================================ EOPN
/* * C program to search for an element in linked list 
================================ EOKW
--------------------------------
output:
$ cc pgm11.c
$ a.out
Enter the number of nodes: 6
1    4    3    1    5    1
Enter key to search: 1
Key found at Position: 6
Key found at Position: 4
Key found at Position: 1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **, int);
void search(struct node *, int, int);
void delete(struct node **);

int main()
{
struct node *head;
int key, num;

printf("Enter the number of nodes: ");
scanf("%d", &num);
generate(&head, num);
printf("\nEnter key to search: ");
scanf("%d", &key);
search(head, key, num);
delete(&head);
}

void generate(struct node **head, int num)
{
int i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = rand() % num;
printf("%d    ", temp->a);
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void search(struct node *head, int key, int index)
{
if (head->a == key)
{
printf("Key found at Position: %d\n", index);
}
if (head->next == NULL)
{
return;
}
search(head->next, key, index - 1);
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Search for an Element in the Linked List without using Recursion
================================ EOPN
/* * C Program to Search for an Element in the Linked List without  * using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc search_iter.c -o search_iter
$ a.out
Enter the number of nodes: 10
 
Displaying the list
3  6  7  5  3  5  6  2  9  1  
Enter key to search: 2
key found
--------------------------------

#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **, int);
void search(struct node *, int);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int key, num;

printf("Enter the number of nodes: ");
scanf("%d", &num);
printf("\nDisplaying the list\n");
generate(&head, num);
printf("\nEnter key to search: ");
scanf("%d", &key);
search(head, key);
delete(&head);

return 0;
}

void generate(struct node **head, int num)
{
int i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = rand() % num;
if (*head == NULL)
{
*head = temp;
temp->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
printf("%d  ", temp->a);
}
}

void search(struct node *head, int key)
{
while (head != NULL)
{
if (head->a == key)
{
printf("key found\n");
return;
}
head = head->next;
}
printf("Key not found\n");
}

void delete(struct node **head)
{
struct node *temp;

while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
/* * Recursive C program to reverse nodes of a linked list and display  * them 
================================ EOKW
--------------------------------
output:
$ cc pgm.c
$ a.out
LinkedList : 4 3 2 1 
LinkedList in reverse order : 1 2 3 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int data;
struct node *next;
};

void print_reverse_recursive (struct node *);
void print (struct node *);
void create_new_node (struct node *, int );

//Driver Function
int main ()
{
struct node *head = NULL;
insert_new_node (&head, 1);
insert_new_node (&head, 2);
insert_new_node (&head, 3);
insert_new_node (&head, 4);
printf ("LinkedList : ");
print (head);
printf ("\nLinkedList in reverse order : ");
print_reverse_recursive (head);
printf ("\n");
return 0;
}

//Recursive Reverse
void print_reverse_recursive (struct node *head)
{
if (head == NULL)
{
return;
}

//Recursive call first
print_reverse_recursive (head -> next);
//Print later
printf ("%d ", head -> data);
}

//Print the linkedlist normal
void print (struct node *head)
{
if (head == NULL)
{
return;
}
printf ("%d ", head -> data);
print (head -> next);
}

//New data added in the start
void insert_new_node (struct node ** head_ref, int new_data)
{
struct node * new_node = (struct node *) malloc (sizeof (struct node));
new_node -> data = new_data;
new_node -> next = (*head_ref);
(*head_ref) = new_node;
}
 ETP 
 
C Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
/* * Recursive C program to display members of a linked list 
================================ EOKW
--------------------------------
output:
$ cc pgm15.c
$ a.out
9    8    7    6    5    4    3    2    1    0
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node*);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
display(head);
delete(&head);
return 0;
}

void generate(struct node **head)
{
int num = 10, i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void display(struct node *head)
{
printf("%d    ", head->a);
if (head->next == NULL)
{
return;
}
display(head->next);
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Display all the Nodes in a Linked List without using Recursion
================================ EOPN
/* * C Program to Display all the Nodes in a Linked List without using  * Recursion 
================================ EOKW
--------------------------------
output:
$ gcc linkdisplay.c -o linkdisplay
$ a.out
9   8   7   6   5   4   3   2   1   0
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node*);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
display(head);
delete(&head);
return 0;
}

void generate(struct node **head)
{
int num = 10, i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void display(struct node *head)
{
while (head != NULL)
{
printf("%d   ", head->a);
head = head->next;
}
printf("\n");
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOPN
/* * C Program to Display the Nodes of a Linked List in Reverse without  * using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc revnode_iter.c -o revnode_iter
$ a.out
Enter length of list: 5
 
Printing the list in linear order
1  2  3  4  5  
 
Printing the list in reverse order
5  4  3  2  1
--------------------------------

#include <stdio.h>
#include <stdlib.h>

struct node
{
int visited;
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void linear(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nPrinting the list in linear order\n");
linear(head);
printf("\nPrinting the list in reverse order\n");
display(head);
delete(&head);

return 0;
}

void display(struct node *head)
{
struct node *temp = head, *prev = head;

while (temp->visited == 0)
{
while (temp->next != NULL && temp->next->visited == 0)
{
temp = temp->next;
}
printf("%d  ", temp->a);
temp->visited = 1;
temp = head;
}
}

void linear(struct node *head)
{
while (head != NULL)
{
printf("%d  ", head->a);
head = head->next;
}
printf("\n");
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
temp->visited = 0;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
/* * C program to find the number of occurences of a given number in a  * list 
================================ EOKW
--------------------------------
output:
$ cc pgm13.c
$ a.out
Enter the size of the list: 7
Printing the list:
1    4    2    5    1    3    3
Enter the key to find it's occurence: 3
3 occurs for 2 times.
--------------------------------
#include <stdio.h>

void occur(int [], int, int, int, int *);

int main()
{
int size, key, count = 0;
int list[20];
int i;

printf("Enter the size of the list: ");
scanf("%d", &size);
printf("Printing the list:\n");
for (i = 0; i < size; i++)
{
list[i] = rand() % size;
printf("%d    ", list[i]);
}
printf("\nEnter the key to find it's occurence: ");
scanf("%d", &key);
occur(list, size, 0, key, &count);
printf("%d occurs for %d times.\n", key, count);
return 0;
}

void occur(int list[], int size, int index, int key, int *count)
{
if (size == index)
{
return;
}
if (list[index] == key)
{
*count += 1;
}
occur(list, size, index + 1, key, count);
}
 ETP 
 
C Program Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
/* * C Program Count the Number of Occurrences of an Element in the Linked List  * without using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc occurnumber.c -o occurnumber
$ a.out
Enter the size of the list: 10
Printing the list:
3    6    7    5    3    5    6    2    9    1   
Enter the key to find it's occurence: 3
3 occurs for 2 times.
--------------------------------
#include <stdio.h>

int occur(int [], int, int);

int main()
{
int size, key, count;
int list[20];
int i;

printf("Enter the size of the list: ");
scanf("%d", &size);
printf("Printing the list:\n");
for (i = 0; i < size; i++)
{
list[i] = rand() % size;
printf("%d    ", list[i]);
}
printf("\nEnter the key to find it's occurence: ");
scanf("%d", &key);
count = occur(list, size, key);
printf("%d occurs for %d times.\n", key, count);
return 0;
}

int occur(int list[], int size, int key)
{
int i, count = 0;

for (i = 0; i < size; i++)
{
if (list[i] == key)
{
count += 1;
}
}
return count;
}
 ETP 
 
C Program find the Length of the Linked List using Recursion
================================ EOPN
/* * C program to find the length of a string 
================================ EOKW
--------------------------------
output:
$ cc pgm17.c
$ a.out
Enter a word to count it's length: 5
The number of characters in 5 are 1.
 
$ a.out
Enter a word to count it's length: sanfoundry
The number of characters in sanfoundry are 10.
--------------------------------
#include <stdio.h>

int length(char [], int);
int main()
{
char word[20];
int count;

printf("Enter a word to count it's length: ");
scanf("%s", word);
count = length(word, 0);
printf("The number of characters in %s are %d.\n", word, count);
return 0;
}

int length(char word[], int index)
{
if (word[index] == '\0')
{
return 0;
}
return (1 + length(word, index + 1));
}
 ETP 
 
C Program find the Length of the Linked List without using Recursion
================================ EOPN
/* * C Program find the Length of the Linked List without using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc numbernode.c -o numbernode
$ a.out
The number of nodes are: 10
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};


void generate(struct node **);
int length(struct node*);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int count;

generate(&head);
count = length(head);
printf("The number of nodes are: %d\n", count);
delete(&head);

return 0;
}

void generate(struct node **head)
{
/* for unknown number of nodes use num = rand() % 20; */
int num = 10, i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

int length(struct node *head)
{
int num = 0;
while (head != NULL)
{
num += 1;
head = head->next;
}
return num;
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
/* * C Program to Print the Alternate Nodes in a Linked List using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc alter_display.c -o alter_display
$ a.out
Enter length of list: 10
 
Displaying the alternate nodes
1  3  5  7  9
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nDisplaying the alternate nodes\n");
display(head);
delete(&head);

return 0;
}

void display(struct node *head)
{
static flag = 0;
if(head != NULL)
{
if (!(flag % 2))
{
printf("%d  ", head->a);
}
flag++;
display(head->next);
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
/* * C Program to Print the Alternate Nodes in a Linked List without  * using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc alter_iter.c -o alter_iter
$ a.out
Enter length of list: 20
 
Displaying the alternate nodes
1  3  5  7  9  11  13  15  17  19
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nDisplaying the alternate nodes\n");
display(head);
delete(&head);

return 0;
}

void display(struct node *head)
{
int flag = 0;

while(head != NULL)
{
if (!(flag % 2))
{
printf("%d  ", head->a);
}
flag++;
head = head->next;
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}}
 ETP 
 
C Program to Implement a Stack using Linked List 
================================ EOPN
/*
 * C Program to Implement a Stack using Linked List
 
================================ EOKW
--------------------------------
output:
$ cc pgm2.c
$ a.out
 
1 - Push
2 - Pop
3 - Top
4 - Empty
5 - Exit
6 - Dipslay
7 - Stack Count
8 - Destroy stack
Enter choice : 1
Enter data : 56
 
Enter choice : 1
Enter data : 80
 
Enter choice : 2
 
Popped value : 80
Enter choice : 3
 
Top element : 56
Enter choice : 1
Enter data : 78
 
Enter choice : 1
Enter data : 90
 
Enter choice : 6
90 78 56
Enter choice : 7
 
No. of elements in stack : 3
Enter choice : 8
 
All stack elements destroyed
Enter choice : 4
 
Stack is empty
Enter choice : 5
--------------------------------

#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int info;
    struct node *ptr;
}*top,*top1,*temp;
 
int topelement();
void push(int data);
void pop();
void empty();
void display();
void destroy();
void stack_count();
void create();
 
int count = 0;
 
void main()
{
    int no, ch, e;
 
    printf("\n 1 - Push");
    printf("\n 2 - Pop");
    printf("\n 3 - Top");
    printf("\n 4 - Empty");
    printf("\n 5 - Exit");
    printf("\n 6 - Dipslay");
    printf("\n 7 - Stack Count");
    printf("\n 8 - Destroy stack");
 
    create();
 
    while (1)
    {
        printf("\n Enter choice : ");
        scanf("%d", &ch);
 
        switch (ch)
        {
        case 1:
            printf("Enter data : ");
            scanf("%d", &no);
            push(no);
            break;
        case 2:
            pop();
            break;
        case 3:
            if (top == NULL)
                printf("No elements in stack");
            else
            {
                e = topelement();
                printf("\n Top element : %d", e);
            }
            break;
        case 4:
            empty();
            break;
        case 5:
            exit(0);
        case 6:
            display();
            break;
        case 7:
            stack_count();
            break;
        case 8:
            destroy();
            break;
        default :
            printf(" Wrong choice, Please enter correct choice  ");
            break;
        }
    }
}
 
/* Create empty stack 
 ETP 
 
C Program to Implement Queue Data Structure using Linked List 
================================ EOPN
/*
 * C Program to Implement Queue Data Structure using Linked List
 
================================ EOKW
--------------------------------
output:
$ cc pgm4.c
$ a.out
 
1 - Enque
2 - Deque
3 - Front element
4 - Empty
5 - Exit
6 - Display
7 - Queue size
Enter choice : 1
Enter data : 14
 
Enter choice : 1
Enter data : 85
 
Enter choice : 1
Enter data : 38
 
Enter choice : 3
Front element : 14
Enter choice : 6
14 85 38
Enter choice : 7
 
Queue size : 3
Enter choice : 2
 
Dequed value : 14
Enter choice : 6
85 38
Enter choice : 7
 
Queue size : 2
Enter choice : 4
Queue not empty
Enter choice : 5
--------------------------------

#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int info;
    struct node *ptr;
}*front,*rear,*temp,*front1;
 
int frontelement();
void enq(int data);
void deq();
void empty();
void display();
void create();
void queuesize();
 
int count = 0;
 
void main()
{
    int no, ch, e;
 
    printf("\n 1 - Enque");
    printf("\n 2 - Deque");
    printf("\n 3 - Front element");
    printf("\n 4 - Empty");
    printf("\n 5 - Exit");
    printf("\n 6 - Display");
    printf("\n 7 - Queue size");
    create();
    while (1)
    {
        printf("\n Enter choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:
            printf("Enter data : ");
            scanf("%d", &no);
            enq(no);
            break;
        case 2:
            deq();
            break;
        case 3:
            e = frontelement();
            if (e != 0)
                printf("Front element : %d", e);
            else
                printf("\n No front element in Queue as queue is empty");
            break;
        case 4:
            empty();
            break;
        case 5:
            exit(0);
        case 6:
            display();
            break;
        case 7:
            queuesize();
            break;
        default:
            printf("Wrong choice, Please enter correct choice  ");
            break;
        }
    }
}
 
/* Create an empty queue 
 ETP 
 
C Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations 
================================ EOPN
/*
 * C Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
 
================================ EOKW
--------------------------------
output:
$ cc pgm1.c
$ a.out
 
1 - Insert at beginning
2 - Insert at end
3 - Insert at position i
4 - Delete at i
5 - Display from beginning
6 - Display from end
7 - Search for element
8 - Sort the list
9 - Update an element
10 - Exit
Enter choice : 1
 
Enter value to node : 10
 
Enter choice : 2
 
Enter value to node : 50
 
Enter choice : 4
 
Enter position to be deleted : 1
 
Node deleted
Enter choice : 1
 
Enter value to node : 34
 
Enter choice : 3
 
Enter position to be inserted : 2
 
Enter value to node : 13
 
Enter choice : 4
 
Enter position to be deleted : 4
 
Error : Position out of range to delete
Enter choice : 1
 
Enter value to node : 15
 
Enter choice : 1
 
Enter value to node : 67
 
Enter choice : 3
 
Enter position to be inserted : 2
 
Enter value to node : 34
 
Enter choice : 4
 
Enter position to be deleted : 3
 
Node deleted
Enter choice : 7
 
Enter value to search : 15
 
Error : 15 not found in list
Enter choice : 8
 
Linked list elements from begining :  13  34  34  50  67
Enter choice : 9
 
Enter node data to be updated : 45
 
Enter new data : 89
 
Error : 45 not found in list to update
Enter choice : 9
 
Enter node data to be updated : 50
 
Enter new data : 90
Enter choice : 5
 
Linked list elements from begining :  13  34  34  90  67
Enter choice : 6
 
Reverse order of linked list is :  67  90  34  34  13
Enter choice : 7
 
Enter value to search : 90
 
Data found in 4 position
Enter choice : 8
 
Linked list elements from begining :  13  34  34  67  90
Enter choice : 7
 
Enter value to search : 90
 
Data found in 5 position
Enter choice : 9
 
Enter node data to be updated : 34
 
Enter new data : 56
 
Linked list elements from begining :  13  56  34  67  90
Enter choice : 10
--------------------------------

#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    struct node *prev;
    int n;
    struct node *next;
}*h,*temp,*temp1,*temp2,*temp4;
 
void insert1();
void insert2();
void insert3();
void traversebeg();
void traverseend(int);
void sort();
void search();
void update();
void delete();
 
int count = 0;
 
void main()
{
    int ch;
 
    h = NULL;
    temp = temp1 = NULL;
 
    printf("\n 1 - Insert at beginning");
    printf("\n 2 - Insert at end");
    printf("\n 3 - Insert at position i");
    printf("\n 4 - Delete at i");
    printf("\n 5 - Display from beginning");
    printf("\n 6 - Display from end");
    printf("\n 7 - Search for element");
    printf("\n 8 - Sort the list");
    printf("\n 9 - Update an element");
    printf("\n 10 - Exit");
 
    while (1)
    {
        printf("\n Enter choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:
            insert1();
            break;
        case 2:
            insert2();
            break;
        case 3:
            insert3();
            break;
        case 4:
            delete();
            break;
        case 5:
            traversebeg();
            break;
        case 6:
            temp2 = h;
            if (temp2 == NULL)
                printf("\n Error : List empty to display ");
            else
            {
                printf("\n Reverse order of linked list is : ");
                traverseend(temp2->n);
            }
            break;
        case 7:
            search();
            break;
        case 8:
            sort();
            break;
        case 9:
            update();
            break;
        case 10:
            exit(0);
        default:
            printf("\n Wrong choice menu");
        }
    }
}
 
/* TO create an empty node 
 ETP 
 
C Program to Implement Binary Tree using Linked List 
================================ EOPN
/* * C Program to Implement Binary Tree using Linked List 
================================ EOKW
--------------------------------
output:
$ cc pgm64.c
$ a.out
In-order Traversal:
D    B    H    E    A    F    C    G
--------------------------------
#include <stdio.h>
#include <malloc.h>

struct node {
struct node * left;
char data;
struct node * right;
};

struct node *constructTree( int );
void inorder(struct node *);

char array[ ] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', '\0', '\0', 'H' };
int leftcount[ ] = {  1,   3,   5,   -1,   9,  -1,  -1,   -1,   -1,  -1 };
int rightcount[ ] = {  2,   4,   6,   -1,  -1,  -1,  -1,   -1,   -1,  -1 };

void main() {
struct node *root;
root = constructTree( 0 );
printf("In-order Traversal: \n");
inorder(root);
}

struct node * constructTree( int index ) {
struct node *temp = NULL;
if (index != -1) {
temp = (struct node *)malloc( sizeof ( struct node ) );
temp->left = constructTree( leftcount[index] );
temp->data = array[index];
temp->right = constructTree( rightcount[index] );
}
return temp;
}

void inorder( struct node *root ) {
if (root != NULL) {
inorder(root->left);
printf("%c\t", root->data);
inorder(root->right);
}
}
 ETP 
 
 C Program to Implement Circular Doubly Linked List 
================================ EOPN
/* * C Program to Implement Circular Doubly Linked List                  
================================ EOKW
--------------------------------
output:
$ cc circular_doubly_ll.c
$ a.out
linked list
1.insert at beginning
2.insert at end
3.insert at position
4.sort linked list
5.delete node at position
6.updatenodevalue
7.search element
8.displaylist from beginning
9.display list from end
10.exit
 enter your choice:8
 
list is empty no elemnts to print
 enter your choice:5
 
 enter the position which u wanted to delete:2
 
 empty linked list you cant delete
 enter your choice:6
 
 enter the value old value:6
 
 enter the value new value:8
 
 list is empty no elemnts for updation
 enter your choice:7
 
enter the value to be searched:57
 
list is empty no elemnets in list to search
 enter your choice:1
 
enter the value to be inserted at first:11
 
initially it is empty linked list later insertion is done
 enter your choice:3
 
 enter the value that you would like to insert:5
 
 enter the position where you have to enter:5
 
 node cant be inserted as position is exceeding the linkedlist length
 enter your choice:1
 
enter the value to be inserted at first:56
 
 the value is inserted at begining
 enter your choice:1
 
enter the value to be inserted at first:89
 
 the value is inserted at begining
 enter your choice:2
 
enter the value that has to be inserted at last:89
 
enter your choice:2
 
enter the value that has to be inserted at last:45
 
enter your choice:
6 number of nodes are there
 89
 56
 11
 89
 45
 89
enter your choice:4
 
11
89
89
45
56
11
 enter your choice:10
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int val;
struct node *next;
struct node *prev;
};
typedef struct node n;

n* create_node(int);
void add_node();
void insert_at_first();
void insert_at_end();
void insert_at_position();
void delete_node_position();
void sort_list();
void update();
void search();
void display_from_beg();
void display_in_rev();

n *new, *ptr, *prev;
n *first = NULL, *last = NULL;
int number = 0;

void main()
{
int ch;

printf("\n linked list\n");
printf("1.insert at beginning \n 2.insert at end\n 3.insert at position\n4.sort linked list\n 5.delete node at position\n 6.updatenodevalue\n7.search element \n8.displaylist from beginning\n9.display list from end\n10.exit ");

while (1)
{

printf("\n enter your choice:");
scanf("%d", &ch);
switch (ch)
{
case 1 :
insert_at_first();
break;
case 2 :
insert_at_end();
break;
case 3 :
insert_at_position();
break;
case 4 :
sort_list();
break;
case 5 :
delete_node_position();
break;
case 6 :
update();
break;
case 7 :
search();
break;
case 8 :
display_from_beg();
break;
case 9 :
display_in_rev();
break;
case 10 :
exit(0);
case 11 :
add_node();
break;
default:
printf("\ninvalid choice");
}
}
}
/*
*MEMORY ALLOCATED FOR NODE DYNAMICALLY
*/
n* create_node(int info)
{
number++;
new = (n *)malloc(sizeof(n));
new->val = info;
new->next = NULL;
new->prev = NULL;
return new;
}
/*
*ADDS NEW NODE
*/
void add_node()
{

int info;

printf("\nenter the value you would like to add:");
scanf("%d", &info);
new = create_node(info);

if (first == last && first == NULL)
{

first = last = new;
first->next = last->next = NULL;
first->prev = last->prev = NULL;
}
else
{
last->next = new;
new->prev = last;
last = new;
last->next = first;
first->prev = last;
}
}
/*
*INSERTS ELEMENT AT FIRST
*/
void insert_at_first()
{

int info;

printf("\nenter the value to be inserted at first:");
scanf("%d",&info);
new = create_node(info);

if (first == last && first == NULL)
{
printf("\ninitially it is empty linked list later insertion is done");
first = last = new;
first->next = last->next = NULL;
first->prev = last->prev = NULL;
}
else
{
new->next = first;
first->prev = new;
first = new;
first->prev = last;
last->next = first;
printf("\n the value is inserted at begining");
}
}
/*
*INSERTS ELEMNET AT END
*/
void insert_at_end()
{

int info;

printf("\nenter the value that has to be inserted at last:");
scanf("%d", &info);
new = create_node(info);

if (first == last && first == NULL)
{
printf("\ninitially the list is empty and now new node is inserted but at first");
first = last = new;
first->next = last->next = NULL;
first->prev = last->prev = NULL;
}
else
{
last->next = new;
new->prev = last;
last = new;
first->prev = last;
last->next = first;
}
}
/*
*INSERTS THE ELEMENT AT GIVEN POSITION
*/
void insert_at_position()
{
int info, pos, len = 0, i;
n *prevnode;

printf("\n enter the value that you would like to insert:");
scanf("%d", &info);
printf("\n enter the position where you have to enter:");
scanf("%d", &pos);
new = create_node(info);

if (first == last && first == NULL)
{
if (pos == 1)
{
first = last = new;
first->next = last->next = NULL;
first->prev = last->prev = NULL;
}
else
printf("\n empty linked list you cant insert at that particular position");
}
else
{
if (number < pos)
printf("\n node cant be inserted as position is exceeding the linkedlist length");

else
{
for (ptr = first, i = 1;i <= number;i++)
{
prevnode = ptr;
ptr = ptr->next;
if (i == pos-1)
{
prevnode->next = new;
new->prev = prevnode;
new->next = ptr;
ptr->prev = new;
printf("\ninserted at position %d succesfully", pos);
break;
}
}
}
}
}
/*
*SORTING IS DONE OF ONLY NUMBERS NOT LINKS
*/
void sort_list()
{
n *temp;
int tempval, i, j;

if (first == last && first == NULL)
printf("\nlinked list is empty no elements to sort");
else
{
for (ptr = first,i = 0;i < number;ptr = ptr->next,i++)
{
for (temp = ptr->next,j=i;j<number;j++)
{
if (ptr->val > temp->val)
{
tempval = ptr->val;
ptr->val = temp->val;
temp->val = tempval;
}
}
}
for (ptr = first, i = 0;i < number;ptr = ptr->next,i++)
printf("\n%d", ptr->val);
}
}
/*
*DELETION IS DONE
*/
void delete_node_position()
{
int pos, count = 0, i;
n *temp, *prevnode;

printf("\n enter the position which u wanted to delete:");
scanf("%d", &pos);

if (first == last && first == NULL)
printf("\n empty linked list you cant delete");

else
{
if (number < pos)
printf("\n node cant be deleted at position as it is exceeding the linkedlist length");

else
{
for (ptr = first,i = 1;i <= number;i++)
{
prevnode = ptr;
ptr = ptr->next;
if (pos == 1)
{
number--;
last->next = prevnode->next;
ptr->prev = prevnode->prev;
first = ptr;
printf("%d is deleted", prevnode->val);
free(prevnode);
break;
}
else if (i == pos - 1)
{
number--;
prevnode->next = ptr->next;
ptr->next->prev = prevnode;
printf("%d is deleted", ptr->val);
free(ptr);
break;
}
}
}
}
}
/*
*UPDATION IS DONE FRO GIVEN OLD VAL
*/
void update()
{
int oldval, newval, i, f = 0;
printf("\n enter the value old value:");
scanf("%d", &oldval);
printf("\n enter the value new value:");
scanf("%d", &newval);
if (first == last && first == NULL)
printf("\n list is empty no elemnts for updation");
else
{
for (ptr = first, i = 0;i < number;ptr = ptr->next,i++)
{
if (ptr->val == oldval)
{
ptr->val = newval;
printf("value is updated to %d", ptr->val);
f = 1;
}
}
if (f == 0)
printf("\n no such old value to be get updated");
}
}
/*
*SEARCHING USING SINGLE KEY
*/
void search()
{
int count = 0, key, i, f = 0;

printf("\nenter the value to be searched:");
scanf("%d", &key);

if (first == last && first == NULL)
printf("\nlist is empty no elemnets in list to search");
else
{
for (ptr = first,i = 0;i < number;i++,ptr = ptr->next)
{
count++;
if (ptr->val == key)
{
printf("\n the value is found at position at %d", count);
f = 1;
}
}
if (f == 0)
printf("\n the value is not found in linkedlist");
}
}
/*
*DISPLAYING IN BEGINNING
*/
void display_from_beg()
{
int i;
if (first == last && first == NULL)
printf("\nlist is empty no elemnts to print");
else
{
printf("\n%d number of nodes are there", number);
for (ptr = first, i = 0;i < number;i++,ptr = ptr->next)
printf("\n %d", ptr->val);
}
}
/*
* DISPLAYING IN REVERSE
*/
void display_in_rev()
{
int i;
if (first == last && first == NULL)
printf("\nlist is empty there are no elments");
else
{
for (ptr = last, i = 0;i < number;i++,ptr = ptr->prev)
{
printf("\n%d", ptr->val);
}
}
}
 ETP 
 
 C Program to Illustrate the Operations of Singly Linked List 
================================ EOPN
/*
 * C program to illustrate the operations of singly linked list
 
================================ EOKW
--------------------------------
output:
$ cc pgm99.c
$ a.out
 
 Welcome to demonstration of singly linked list
---------------------------------------------
Press 1 to INSERT a node into the list
Press 2 to DELETE a node from the list
Press 3 to DISPLAY the list
Press 4 to SEARCH the list
Press 5 to EXIT
---------------------------------------------
 
 
>> Enter your choice: 1
 
Enter the Employee Number      : 12
Enter the Employee name        : ram
Enter the Employee Designation : HR
 
 
>> Enter your choice: 3
 
Employee Details...
 
Emp No       : 12
Name           : ram
Designation    : HR
-------------------------------------
 
 
>> Enter your choice:
Invalid choice.
 
>> Enter your choice: 4
 
 
Enter the employee number to be searched: 12
 
Key found:
Employee Details...
 
Emp No       : 12
Name           : ram
Designation    : HR
-------------------------------------
 
 
>> Enter your choice:
Invalid choice.
 
>> Enter your choice: 2
 
 
Enter the employee number to be deleted: 12
 
Node deleted:
Employee Details...
 
Emp No       : 12
Name           : ram
Designation    : HR
-------------------------------------
 
 
>> Enter your choice:
Invalid choice.
 
>> Enter your choice: 4
 
 
Enter the employee number to be searched: 1
 
Employee Number 1 not found
 
>> Enter your choice:
Invalid choice.
 
>> Enter your choice: 5
--------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 30
 
struct emp_data
{
    int  empno;
    char empName[MAX];
    char designation[MAX];
    struct emp_data *next;
};
 
/*   ***
 ETP 
 
 C Program to Implement Singly Linked List using Dynamic Memory Allocation 
================================ EOPN
/* * C Program to Implement Singly Linked List using Dynamic Memory Allocation 
================================ EOKW
--------------------------------
output:
$gcc linkedlist.c
a.out
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
 
EMPTY LIST::No nodes in the list to display
 
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice5
 
...Deleting Node from any Position...
 
EMPTY LIST::No node to delete
 
YOU WANT TO CONTINUE (Y/N)
y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice6
 
...Updating Node Value...
 
EMPTY LIST::No nodes in the list to update
 
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice
7
 
...Searching Element in the List...
 
EMPTY LIST::No nodes in the list
 
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice
3
 
...Inserting node at position...
 
Enter the value for the Node:1010
 
Enter the position 5
Position is out of range
YOU WANT TO CONTINUE (Y/N)
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice1
 
...Inserting node at first...
 
Enter the value for the node:100
 
----INSERTED----
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice1
 
...Inserting node at first...
 
Enter the value for the node:200
 
----INSERTED----
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
200     100
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice2
 
...Inserting node at last...
 
Enter the value for the Node:50
 
----INSERTED----
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice2
 
...Inserting node at last...
 
Enter the value for the Node:150
 
----INSERTED----
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
200     100     50      150
YOU WANT TO CONTINUE (Y/N)
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice3
 
...Inserting node at position...
 
Enter the value for the Node:1111
 
Enter the position 4
 
----INSERTED----
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
200     100     50      1111    150
YOU WANT TO CONTINUE (Y/N)
y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice3
 
...Inserting node at position...
 
Enter the value for the Node:1010
 
Enter the position 100
Position is out of range
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
200     100     50      1111    150
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice5
 
...Deleting Node from any Position...
 
Enter the position of value to be deleted:1
 
Element deleted
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
100     50      1111    150
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice5
 
...Deleting Node from any Position...
 
Enter the position of value to be deleted:4
 
Element deleted
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
100     50      1111
 
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice5
 
...Deleting Node from any Position...
 
Enter the position of value to be deleted:2
 
Element deleted
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
100     1111
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice6
 
...Updating Node Value...
 
Enter the value to be updated:100
 
Enter the newvalue:10101
 
Updated Successfully
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice8
 
...Displaying List From Beginning to End...
10101   1111
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice6
 
...Updating Node Value...
 
Enter the value to be updated:100
 
Enter the newvalue:200
 
Value not found in List
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice7
 
...Searching Element in the List...
 
Enter the value to search 1111
 
Element 1111 found at 2 position
 
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice7
 
...Searching Element in the List...
 
Enter the value to search200
 
Element 200 not found in list
 
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice4
 
...Sorted Linked List in Ascending Order...
 
---Sorted List---1111   10101
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice9
 
...Displaying List From End using Recursion...
 
EMPTY LIST::No nodes to display
10101   1111
YOU WANT TO CONTINUE (Y/N)y
 
---------------------------------
 
Operations on singly linked list
 
---------------------------------
 
1.Insert node at first
2.Insert node at last
3.Insert node at position
4.Sorted Linked List in Ascending Order
5.Delete Node from any Position
6.Update Node Value
7.Search Element in the linked list
8.Display List from Beginning to end
9.Display List from end using Recursion
10.Exit
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
Enter your choice10
 
...Exiting...
--------------------------------
#include <stdio.h>
#include <malloc.h>
#define ISEMPTY printf("\nEMPTY LIST:");
/*
* Node Declaration
*/
struct node
{
int value;
struct node *next;
};

snode* create_node(int);
void insert_node_first();
void insert_node_last();
void insert_node_pos();
void sorted_ascend();
void delete_pos();
void search();
void update_val();
void display();
void rev_display(snode *);

typedef struct node snode;
snode *newnode, *ptr, *prev, *temp;
snode *first = NULL, *last = NULL;

/*
* Main :contains menu
*/

int main()
{
int ch;
char ans = 'Y';

while (ans == 'Y'||ans == 'y')
{
printf("\n---------------------------------\n");
printf("\nOperations on singly linked list\n");
printf("\n---------------------------------\n");
printf("\n1.Insert node at first");
printf("\n2.Insert node at last");
printf("\n3.Insert node at position");
printf("\n4.Sorted Linked List in Ascending Order");
printf("\n5.Delete Node from any Position");
printf("\n6.Update Node Value");
printf("\n7.Search Element in the linked list");
printf("\n8.Display List from Beginning to end");
printf("\n9.Display List from end using Recursion");
printf("\n10.Exit\n");
printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
printf("\nEnter your choice");
scanf("%d", &ch);

switch (ch)
{
case 1:
printf("\n...Inserting node at first...\n");
insert_node_first();
break;
case 2:
printf("\n...Inserting node at last...\n");
insert_node_last();
break;
case 3:
printf("\n...Inserting node at position...\n");
insert_node_pos();
break;
case 4:
printf("\n...Sorted Linked List in Ascending Order...\n");
sorted_ascend();
break;
case 5:
printf("\n...Deleting Node from any Position...\n");
delete_pos();
break;
case 6:
printf("\n...Updating Node Value...\n");
update_val();
break;
case 7:
printf("\n...Searching Element in the List...\n");
search();
break;
case 8:
printf("\n...Displaying List From Beginning to End...\n");
display();
break;
case 9:
printf("\n...Displaying List From End using Recursion...\n");
rev_display(first);
break;
case 10:
printf("\n...Exiting...\n");
return 0;
break;
default:
printf("\n...Invalid Choice...\n");
break;
}
printf("\nYOU WANT TO CONTINUE (Y/N)");
scanf(" %c", &ans);
}
return 0;
}

/*
* Creating Node
*/
snode* create_node(int val)
{
newnode = (snode *)malloc(sizeof(snode));
if (newnode == NULL)
{
printf("\nMemory was not allocated");
return 0;
}
else
{
newnode->value = val;
newnode->next = NULL;
return newnode;
}
}

/*
* Inserting Node at First
*/
void insert_node_first()
{
int val;

printf("\nEnter the value for the node:");
scanf("%d", &val);
newnode = create_node(val);
if (first == last && first == NULL)
{
first = last = newnode;
first->next = NULL;
last->next = NULL;
}
else
{
temp = first;
first = newnode;
first->next = temp;
}
printf("\n----INSERTED----");
}

/*
* Inserting Node at Last
*/
void insert_node_last()
{
int val;

printf("\nEnter the value for the Node:");
scanf("%d", &val);
newnode = create_node(val);
if (first == last && last == NULL)
{
first = last = newnode;
first->next = NULL;
last->next = NULL;
}
else
{
last->next = newnode;
last = newnode;
last->next = NULL;
}
printf("\n----INSERTED----");
}

/*
* Inserting Node at position
*/
void insert_node_pos()
{
int pos, val, cnt = 0, i;

printf("\nEnter the value for the Node:");
scanf("%d", &val);
newnode = create_node(val);
printf("\nEnter the position ");
scanf("%d", &pos);
ptr = first;
while (ptr != NULL)
{
ptr = ptr->next;
cnt++;
}
if (pos == 1)
{
if (first == last && first == NULL)
{
first = last = newnode;
first->next = NULL;
last->next = NULL;
}
else
{
temp = first;
first = newnode;
first->next = temp;
}
printf("\nInserted");
}
else if (pos>1 && pos<=cnt)
{
ptr = first;
for (i = 1;i < pos;i++)
{
prev = ptr;
ptr = ptr->next;
}
prev->next = newnode;
newnode->next = ptr;
printf("\n----INSERTED----");
}
else
{
printf("Position is out of range");
}
}

/*
* Sorted Linked List
*/
void sorted_ascend()
{
snode *nxt;
int t;

if (first == NULL)
{
ISEMPTY;
printf(":No elements to sort\n");
}
else
{
for (ptr = first;ptr != NULL;ptr = ptr->next)
{
for (nxt = ptr->next;nxt != NULL;nxt = nxt->next)
{
if (ptr->value > nxt->value)
{
t = ptr->value;
ptr->value = nxt->value;
nxt->value = t;
}
}
}
printf("\n---Sorted List---");
for (ptr = first;ptr != NULL;ptr = ptr->next)
{
printf("%d\t", ptr->value);
}
}
}

/*
* Delete Node from specified position in a non-empty list
*/
void delete_pos()
{
int pos, cnt = 0, i;

if (first == NULL)
{
ISEMPTY;
printf(":No node to delete\n");
}
else
{
printf("\nEnter the position of value to be deleted:");
scanf(" %d", &pos);
ptr = first;
if (pos == 1)
{
first = ptr->next;
printf("\nElement deleted");
}
else
{
while (ptr != NULL)
{
ptr = ptr->next;
cnt = cnt + 1;
}
if (pos > 0 && pos <= cnt)
{
ptr = first;
for (i = 1;i < pos;i++)
{
prev = ptr;
ptr = ptr->next;
}
prev->next = ptr->next;
}
else
{
printf("Position is out of range");
}
free(ptr);
printf("\nElement deleted");
}
}
}
/*
* Updating Node value in a non-empty list
*/
void update_val()
{
int oldval, newval, flag = 0;

if (first == NULL)
{
ISEMPTY;
printf(":No nodes in the list to update\n");
}
else
{
printf("\nEnter the value to be updated:");
scanf("%d", &oldval);
printf("\nEnter the newvalue:");
scanf("%d", &newval);
for (ptr = first;ptr != NULL;ptr = ptr->next)
{
if (ptr->value == oldval)
{
ptr->value = newval;
flag = 1;
break;
}
}
if (flag == 1)
{
printf("\nUpdated Successfully");
}
else
{
printf("\nValue not found in List");
}
}
}

/*
* searching an element in a non-empty list
*/
void search()
{
int flag = 0, key, pos = 0;

if (first == NULL)
{
ISEMPTY;
printf(":No nodes in the list\n");
}
else
{
printf("\nEnter the value to search");
scanf("%d", &key);
for (ptr = first;ptr != NULL;ptr = ptr->next)
{
pos = pos + 1;
if (ptr->value == key)
{
flag = 1;
break;
}
}
if (flag == 1)
{
printf("\nElement %d found at %d position\n", key, pos);
}
else
{
printf("\nElement %d not found in list\n", key);
}
}
}
/*
* Displays non-empty List from Beginning to End
*/
void display()
{
if (first == NULL)
{
ISEMPTY;
printf(":No nodes in the list to display\n");
}
else
{
for (ptr = first;ptr != NULL;ptr = ptr->next)
{
printf("%d\t", ptr->value);
}
}
}

/*
* Display non-empty list in Reverse Order
*/
void rev_display(snode *ptr)
{
int val;

if (ptr == NULL)
{
ISEMPTY;
printf(":No nodes to display\n");
}
else
{
if (ptr != NULL)
{
val = ptr->value;
rev_display(ptr->next);
printf("%d\t", val);
}

}
}
 ETP 
 
 C Program to Implement Doubly Linked List using Singly Linked List 
================================ EOPN
/* * C Program to Implement Doubly Linked List using Singly Linked List  
================================ EOKW
--------------------------------
output:
$ cc singledouble.c 
$ ./a.out
Enter data into the list
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 6
Do you wish to continue [1/0]: 1
Enter number: 8
Do you wish to continue [1/0]: 1 
Enter number: 10
Do you wish to continue [1/0]: 0
 
Displaying list:
2   4   6   8   10  
 
Pointer at 2
Select option:
1. Move front
2. Move back
3. Exit
Your choice: 1
 
Pointer at 4
Select option:
1. Move front
2. Move back
3. Exit
Your choice: 1
 
Pointer at 6
Select option:
1. Move front
2. Move back
3. Exit
Your choice: 2
 
Pointer at 4
Select option:
1. Move front
2. Move back
3. Exit
Your choice: 2
 
Pointer at 2
Select option:
1. Move front
2. Move back
3. Exit
Your choice: 3
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void move (struct node *);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL, *q = NULL;
int result, count;

printf("Enter data into the list\n");
create(&p);
printf("Displaying list:\n");
display(p);
move(p);
release (&p);

return 0;
}

void move(struct node *head)
{
struct node *p, *q;
int ch;

p = q = head;
printf("\nPointer at %d\n", head->num);
do
{
printf("Select option:\n1. Move front\n2. Move back\n3. Exit\nYour choice: ");
scanf("%d", &ch);
switch(ch)
{
case 1: if(q->next != NULL)
{
q = q->next;
printf("\nPointer at %d\n", q->num);
}
else
{
printf("\nPointer at last node %d. Cannot move ahead.\n", q->num);
}
break;
case 2: while (p->next != q)
{
p = p->next;
}
if (p == q)
{
printf("\nPointer at first node %d. Cannot move behind.\n", q->num);
}
else
{
q = p;
p = head;
printf("\nPointer at %d\n", q->num);
}
break;
case 3: return;
default: printf("\nInvalid choice entered. Try again\n");
}
} while (1);
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *head)
{
while (head != NULL)
{
printf("%d\t", head->num);
head = head->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp;
while ((*head) != NULL)
{
temp = *head;
(*head) = (*head)->next;
free(temp);
}
}
 ETP 
 
 C Program to Demonstrate Circular Single Linked List 
================================ EOPN
/* * C Program to Demonstrate Circular Single Linked List 
================================ EOKW
--------------------------------
output:
$ cc circular_singly_ll.c
$ a.out
1.Creation
2.Insertion at beginning
3.Insertion at remaining
4.Deletion at beginning
5.Deletion at remaining
6.traverse
7.Search
8.sort
9.update
10.Exit
Enter your choice:6
List is empty
Enter your choice:5
List is empty
Enter your choice:9
empty list
Enter your choice:7
enter the element to search
12
List is empty nothing to search
Enter your choice:1
Enter the data:10
If you wish to continue press 1 otherwise 0:0
Enter your choice:3
Enter the data:20
Enter the position to be inserted:5
OUT OF BOUND
Enter your choice:2
Enter the data:12
Enter your choice:6
12->10
Enter your choice:3
Enter the data:13
Enter the position to be inserted:3
Enter your choice:3
Enter the data:14
Enter the position to be inserted:4
Enter your choice:6
12->10->13->14
Enter your choice:3
Enter the data:24
Enter the position to be inserted:4
Enter your choice:6
12->10->13->24->14
Enter your choice:3
Enter the data:10
Enter the position to be inserted:100
OUT OF BOUND
Enter your choice:4
Enter your choice:6
10->13->24->14
Enter your choice:5
Enter the position to be deleted:4
Enter your choice:6
10->13->24
Enter your choice:5
Enter the position to be deleted:2
Enter your choice:6
10->24
Enter your choice:9
enter the value to be edited
23
enter the value to be replace
24
update not successful
Enter your choice:9
enter the value to be edited
24
enter the value to be replace
26
UPdate sucessful
Enter your choice:6
10->26
Enter your choice:7
enter the element to search
26
element found at postion 1
element not found
Enter your choice:7
enter the element to search
27
element not found
Enter your choice:8
Enter your choice:6
10->26
Enter your choice:10
26 10
Enter your choice:11
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int data;
struct node *link;
};

struct node *head = NULL, *x, *y, *z;

void create();
void ins_at_beg();
void ins_at_pos();
void del_at_beg();
void del_at_pos();
void traverse();
void search();
void sort();
void update();
void rev_traverse(struct node *p);

void main()
{
int ch;

printf("\n 1.Creation \n 2.Insertion at beginning \n 3.Insertion at remaining");
printf("\n4.Deletion at beginning \n5.Deletion at remaining \n6.traverse");
printf("\n7.Search\n8.sort\n9.update\n10.Exit\n");
while (1)
{
printf("\n Enter your choice:");
scanf("%d", &ch);
switch(ch)
{
case 1:
create();
break;
case 2:
ins_at_beg();
break;
case 3:
ins_at_pos();
break;
case 4:
del_at_beg();
break;
case 5:
del_at_pos();
break;
case 6:
traverse();
break;
case 7:
search();
break;
case 8:
sort();
break;
case 9:
update();
break;
case 10:
rev_traverse(head);
break;
default:
exit(0);
}
}
}

/*Function to create a new circular linked list*/
void create()
{
int c;

x = (struct node*)malloc(sizeof(struct node));
printf("\n Enter the data:");
scanf("%d", &x->data);
x->link = x;
head = x;
printf("\n If you wish to continue press 1 otherwise 0:");
scanf("%d", &c);
while (c != 0)
{
y = (struct node*)malloc(sizeof(struct node));
printf("\n Enter the data:");
scanf("%d", &y->data);
x->link = y;
y->link = head;
x = y;
printf("\n If you wish to continue press 1 otherwise 0:");
scanf("%d", &c);
}
}

/*Function to insert an element at the begining of the list*/

void ins_at_beg()
{
x = head;
y = (struct node*)malloc(sizeof(struct node));
printf("\n Enter the data:");
scanf("%d", &y->data);
while (x->link != head)
{
x = x->link;
}
x->link = y;
y->link = head;
head = y;
}

/*Function to insert an element at any position the list*/

void ins_at_pos()
{
struct node *ptr;
int c = 1, pos, count = 1;

y = (struct node*)malloc(sizeof(struct node));
if (head == NULL)
{
printf("cannot enter an element at this place");
}
printf("\n Enter the data:");
scanf("%d", &y->data);
printf("\n Enter the position to be inserted:");
scanf("%d", &pos);
x = head;
ptr = head;
while (ptr->link != head)
{
count++;
ptr = ptr->link;
}
count++;
if (pos > count)
{
printf("OUT OF BOUND");
return;
}
while (c < pos)
{
z = x;
x = x->link;
c++;
}
y->link = x;
z->link = y;
}

/*Function to delete an element at any begining of the list*/

void del_at_beg()
{
if (head == NULL)
printf("\n List is empty");
else
{
x = head;
y = head;
while (x->link !=  head)
{
x = x->link;
}
head = y->link;
x->link = head;
free(y);
}
}

/*Function to delete an element at any position the list*/

void del_at_pos()
{
if (head == NULL)
printf("\n List is empty");
else
{
int c = 1, pos;
printf("\n Enter the position to be deleted:");
scanf("%d", &pos);
x = head;
while (c < pos)
{
y = x;
x = x->link;
c++;
}
y->link = x->link;
free(x);
}
}

/*Function to display the elements in the list*/

void traverse()
{
if (head == NULL)
printf("\n List is empty");
else
{
x = head;
while (x->link !=  head)
{
printf("%d->", x->data);
x = x->link;
}
printf("%d", x->data);
}
}

/*Function to search an element in the list*/

void search()
{
int search_val, count = 0, flag = 0;
printf("\nenter the element to search\n");
scanf("%d", &search_val);
if (head == NULL)
printf("\nList is empty nothing to search");
else
{
x = head;
while (x->link !=  head)
{
if (x->data == search_val)
{
printf("\nthe element is found at %d", count);
flag = 1;
break;
}
count++;
x = x->link;
}
if (x->data == search_val)
{
printf("element found at postion %d", count);
}
if (flag == 0)
{
printf("\nelement not found");
}

}
}

/*Function to sort the list in ascending order*/

void sort()
{
struct node *ptr, *nxt;
int temp;

if (head == NULL)
{
printf("empty linkedlist");
}
else
{
ptr = head;
while (ptr->link !=  head)
{
nxt = ptr->link;
while (nxt !=  head)
{
if (nxt !=  head)
{
if (ptr->data > nxt->data)
{
temp = ptr->data;
ptr->data = nxt->data;
nxt->data = temp;
}
}
else
{
break;
}
nxt = nxt->link;
}
ptr = ptr->link;
}
}
}

/*Function to update an element at any position the list*/
void update()
{
struct node *ptr;
int search_val;
int replace_val;
int flag = 0;

if (head == NULL)
{
printf("\n empty list");
}
else
{
printf("enter the value to be edited\n");
scanf("%d", &search_val);
fflush(stdin);
printf("enter the value to be replace\n");
scanf("%d", &replace_val);
ptr = head;
while (ptr->link !=  head)
{
if (ptr->data == search_val)
{
ptr->data = replace_val;
flag = 1;
break;
}
ptr = ptr->link;
}
if (ptr->data == search_val)
{
ptr->data = replace_val;
flag = 1;
}
if (flag == 1)
{
printf("\nUPdate sucessful");
}
else
{
printf("\n update not successful");
}
}
}

/*Function to display the elements of the list in reverse order*/

void rev_traverse(struct node *p)
{
int i = 0;

if (head == NULL)
{
printf("empty linked list");
}
else
{
if (p->link !=  head)
{
i = p->data;
rev_traverse(p->link);
printf(" %d", i);
}
if (p->link == head)
{
printf(" %d", p->data);
}
}
}
 ETP 
 
 C Program to Add Corresponding Positioned Elements of 2 Linked Lists 
================================ EOPN
/* * C Program to Add Corresponding Positioned Elements of 2 Linked Lists  
================================ EOKW
--------------------------------
output:
$ cc add2lists.c
$ ./a.out
Enter first number
12345
Enter second number
5678903
Displaying list1: 12345
Displaying list2: 5678903
Displaying the resulting list: 5691248
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

struct node
{
int num;
struct node *next;
};

int feednumber(struct node **);
struct node *addlist(struct node *, struct node *, int, int);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
struct node *q = NULL;
struct node *res = NULL;
int pcount = 0, qcount = 0;

printf("Enter first number\n");
pcount = feednumber(&p);
printf("Enter second number\n");
qcount = feednumber(&q);
printf("Displaying list1: ");
display(p);
printf("Displaying list2: ");
display(q);
res = addlist(p, q, pcount, qcount);
printf("Displaying the resulting list: ");
display(res);
release(&p);
release(&q);
release(&res);

return 0;
}

/*Function to create nodes of numbers*/
int feednumber(struct node **head)
{
char ch, dig;
int count = 0;
struct node *temp, *rear = NULL;

ch = getchar();
while (ch != '\n')
{
dig = atoi(&ch);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = dig;
temp->next = NULL;
count++;
if ((*head) == NULL)
{
*head = temp;
rear = temp;
}
else
{
rear->next = temp;
rear = rear->next;
}
ch = getchar();
}

return count;
}

/*Function to display the list of numbers*/
void display (struct node *head)
{
while (head != NULL)
{
printf("%d", head->num);
head = head->next;
}
printf("\n");
}

/*Function to free the allocated list of numbers*/
void release (struct node **head)
{
struct node *temp = *head;

while ((*head) != NULL)
{
(*head) = (*head)->next;
free(temp);
temp = *head;
}
}

/*Function to add the list of numbers and store them in 3rd list*/
struct node *addlist(struct node *p, struct node *q, int pcount, int qcount)
{
struct node *ptemp, *qtemp, *result = NULL, *temp;
int i, carry = 0;

while (pcount != 0 && qcount != 0)
{
ptemp = p;
qtemp = q;
for (i = 0; i < pcount - 1; i++)
{
ptemp = ptemp->next;
}
for (i = 0; i < qcount - 1; i++)
{
qtemp = qtemp->next;
}
temp = (struct node *) malloc (sizeof(struct node));
temp->num = ptemp->num + qtemp->num + carry;
carry = temp->num / 10;
temp->num = temp->num % 10;
temp->next = result;
result = temp;
pcount--;
qcount--;
}
/*both or one of the 2 lists have been read completely by now*/
while (pcount != 0)
{
ptemp = p;
for (i = 0; i < pcount - 1; i++)
{
ptemp = ptemp->next;
}
temp = (struct node *) malloc (sizeof(struct node));
temp->num = ptemp->num + carry;
carry = temp->num / 10;
temp->num = temp->num % 10;
temp->next = result;
result = temp;
pcount--;
}
while (qcount != 0)
{
qtemp = q;
for (i = 0; i < qcount - 1; i++)
{
qtemp = qtemp->next;
}
temp = (struct node *) malloc (sizeof(struct node));
temp->num = qtemp->num + carry;
carry = temp->num / 10;
temp->num = temp->num % 10;
temp->next = result;
result = temp;
qcount--;
}

return result;
}
 ETP 
 
 C Program to Check whether 2 Lists are Same 
================================ EOPN
/* * C Program to Check whether 2 Lists are Same  
================================ EOKW
--------------------------------
output:
$ cc checklinklist.c 
$ ./a.out
Enter data into first list
Enter number: 12
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 28
Do you wish to continue [1/0]: 1
Enter number: 9
Do you wish to continue [1/0]: 0
 
Enter data into second list
Enter number: 12
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 28
Do you wish to continue [1/0]: 1
Enter number: 9
Do you wish to continue [1/0]: 0
 
The 2 list are equal.
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void feedmember(struct node **);
int compare (struct node *, struct node *);
void release(struct node **);

int main()
{
struct node *p = NULL;
struct node *q = NULL;
int result;

printf("Enter data into first list\n");
feedmember(&p);
printf("Enter data into second list\n");
feedmember(&q);
result = compare(p, q);
if (result == 1)
{
printf("The 2 list are equal.\n");
}
else
{
printf("The 2 lists are unequal.\n");
}
release (&p);
release (&q);

return 0;
}

int compare (struct node *p, struct node *q)
{
while (p != NULL && q != NULL)
{
if (p->num != q-> num)
{
return 0;
}
else
{
p = p->next;
q = q->next;
}
}
if (p != NULL || q != NULL)
{
return 0;
}
else
{
return 1;
}
}

void feedmember (struct node **head)
{
int c, ch;
struct node *temp;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = *head;
*head = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
}while (ch != 0);
printf("\n");
}

void release (struct node **head)
{
struct node *temp = *head;

while ((*head) != NULL)
{
(*head) = (*head)->next;
free(temp);
temp = *head;
}
}
 ETP 
 
 C Program to Check whether a Singly Linked List is a Palindrome 
================================ EOPN
/* * C Program to Check whether a Singly Linked List is a Palindrome  
================================ EOKW
--------------------------------
output:
$ cc linklistpalin.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3 
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 1
Do you wish to continue [1/0]: 0
 
The linked list is a palindrome.
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

int create(struct node **);
int palin_check (struct node *, int);
void release(struct node **);

int main()
{
struct node *p = NULL;
int result, count;

printf("Enter data into the list\n");
count = create(&p);
result = palin_check(p, count);
if (result == 1)
{
printf("The linked list is a palindrome.\n");
}
else
{
printf("The linked list is not a palindrome.\n");
}
release (&p);

return 0;
}

int palin_check (struct node *p, int count)
{
int i = 0, j;
struct node *front, *rear;

while (i != count / 2)
{
front = rear = p;
for (j = 0; j < i; j++)
{
front = front->next;
}
for (j = 0; j < count - (i + 1); j++)
{
rear = rear->next;
}
if (front->num != rear->num)
{
return 0;
}
else
{
i++;
}
}

return 1;
}

int create (struct node **head)
{
int c, ch, count = 0;
struct node *temp;

do
{
printf("Enter number: ");
scanf("%d", &c);
count++;
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = *head;
*head = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
}while (ch != 0);
printf("\n");

return count;
}

void release (struct node **head)
{
struct node *temp = *head;

while ((*head) != NULL)
{
(*head) = (*head)->next;
free(temp);
temp = *head;
}
}
 ETP 
 
 C Program to Detect the Cycle in a Linked List 
================================ EOPN
/* * C Program to Detect the Cycle in a Linked List  
================================ EOKW
--------------------------------
output:
$ cc detectcycle.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 1
Enter number: 6
Do you wish to continue [1/0]: 1
Enter number: 7
Do you wish to continue [1/0]: 0
 
Identifying if a cycle exists.
Cycle detected in the linked list..
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void makecycle(struct node **);
void release(struct node **);
int detectcycle(struct node *);

int main()
{
struct node *p = NULL;
int result;

printf("Enter data into the list\n");
create(&p);
makecycle(&p); //comment it to avoid cycle creation
printf("Identifying if a cycle exists.\n");
result = detectcycle(p);
if (result)
{
printf("Cycle detected in the linked list.\n");
}
else
{
printf("No cycle detected in the linked list.\n");
}
release (&p);

return 0;
}

void makecycle(struct node **p)
{
struct node *rear, *front;
int n, count = 0, i;

front = rear = *p;
while (rear->next != NULL)
{
rear = rear->next;
count++;
}
if (count)
{
n = rand() % count;
}
else
{
n = 1;
}
for (i = 0; i < n - 1; i++)
{
front = front->next;
}
rear->next = front;
/*At this point a cycle is generated in the list*/
}

int detectcycle(struct node *head)
{
int flag = 1, count = 1, i;
struct node *p, *q;

p = q = head;
q = q->next;
while (1)
{
q = q->next;
if (flag)
{
p = p->next;
}
if (q == p)
{
/*Deleting the loop to deallocate the list*/
q = q->next;
while (q != p)
{
count++;
q = q->next;
}
q = p = head;
for (i = 0; i < count; i++)
{
q = q->next;
}
while (p != q)
{
p = p->next;
q = q->next;
}
q->next = NULL;

return 1;
}
else if (q->next == NULL)
{
return 0;
}
flag = !flag;
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
temp = temp->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Find Number of Occurences of All Elements in a Linked List 
================================ EOPN
/* * C Program to Find Number of Occurences of All Elements in a Linked List  
================================ EOKW
--------------------------------
output:
$ cc occurence.c 
$ ./a.out 
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 6
Do you wish to continue [1/0]: 1
Enter number: 1
Do you wish to continue [1/0]: 0
 
Displaying the occurence of each node in the list:
1   2   3   2   4   2   6   1   
***************************
  Number    Occurence
***************************
    1       2
    2       3
    3       1
    4       1
    6       1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

struct node_occur
{
int num;
int times;
struct node_occur *next;
};

void create(struct node **);
void occur(struct node *, struct node_occur **);
void release(struct node **);
void release_2(struct node_occur **);
void display(struct node *);
void disp_occur(struct node_occur *);

int main()
{
struct node *p = NULL;
struct node_occur *head = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the occurence of each node in the list:\n");
display(p);
occur(p, &head);
disp_occur(head);
release(&p);
release_2(&head);

return 0;
}

void occur(struct node *head, struct node_occur **result)
{
struct node *p;
struct node_occur *temp, *prev;

p = head;
while (p != NULL)
{
temp = *result;
while (temp != NULL && temp->num != p->num)
{
prev = temp;
temp = temp->next;
}
if (temp == NULL)
{
temp = (struct node_occur *)malloc(sizeof(struct node_occur));
temp->num = p->num;
temp->times = 1;
temp->next = NULL;
if (*result != NULL)
{
prev->next = temp;
}
else
{
*result = temp;
}
}
else
{
temp->times += 1;
}
p = p->next;
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void disp_occur(struct node_occur *p)
{
printf("***************************\n  Number\tOccurence\n***************************\n");
while (p != NULL)
{
printf("    %d\t\t%d\n", p->num, p->times);
p = p->next;
}
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}

void release_2(struct node_occur **head)
{
struct node_occur *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Find the first Common Element between the 2 given Linked Lists 
================================ EOPN
/* * C Program to Find the first Common Element between the 2 given Linked Lists  
================================ EOKW
--------------------------------
output:
$ cc firstcommon.c 
$ ./a.out
Enter data into the list1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 8
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 1
Enter number: 6
Do you wish to continue [1/0]: 0
 
Enter data into the list2
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 1
Enter number: 9
Do you wish to continue [1/0]: 0
 
Displaying list1:
2   8   5   6   
Displaying list2:
3   5   9   
The first matched element is 5.
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
int find(struct node *, struct node *);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL, *q = NULL;
int result;

printf("Enter data into the list\n");
create(&p);
printf("Enter data into the list\n");
create(&q);
printf("Displaying list1:\n");
display(p);
printf("Displaying list2:\n");
display(q);
result = find(p, q);
if (result)
{
printf("The first matched element is %d.\n", result);
}
else
{
printf("No matching element found.\n");
}
release (&p);

return 0;
}

int find(struct node *p, struct node *q)
{
struct node *temp;

while (p != NULL)
{
temp = q;
while (temp != NULL)
{
if (temp->num == p->num)
{
return p->num;
}
temp = temp->next;
}
p = p->next;
}

/*Assuming 0 is not used in the list*/
return 0;
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *head)
{
while (head != NULL)
{
printf("%d\t", head->num);
head = head->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp;
while ((*head) != NULL)
{
temp = *head;
(*head) = (*head)->next;
free(temp);
}
}
 ETP 
 
 C Program to Find the Largest Element in a Doubly Linked List 
================================ EOPN
/* * C Program to Find the Largest Element in a Doubly Linked List  
================================ EOKW
--------------------------------
output:
$ cc largestdoubly.c 
$ ./a.out
Enter data into the list
Enter number: 12
Do you wish to continue [1/0]: 1
Enter number: 7
Do you wish to continue [1/0]: 1
Enter number: 23
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 16
Do you wish to continue [1/0]: 0
 
The maximum number entered in the list is 23.
--------------------------------

#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
struct node *prev;
};

void create(struct node **);
int max(struct node *);
void release(struct node **);

int main()
{
struct node *p = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
n = max(p);
printf("The maximum number entered in the list is %d.\n", n);
release (&p);

return 0;
}

int max(struct node *head)
{
struct node *max, *q;

q = max = head;
while (q != NULL)
{
if (q->num > max->num)
{
max = q;
}
q = q->next;
}

return (max->num);
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
temp->prev = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
temp->prev = rear;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Print Middle most Node of a Linked List 
================================ EOPN
/* * C Program to Print Middle most Node of a Linked List  
================================ EOKW
--------------------------------
output:
$ cc middlenode.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
The middle node of the list is: 3
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void middlenode(struct node *);
void release(struct node **);

int main()
{
struct node *p = NULL;

printf("Enter data into the list\n");
create(&p);
middlenode(p);
release (&p);

return 0;
}

void middlenode(struct node *head)
{
struct node *p, *q;
int flag = 0;

q = p = head;
/*for every two hops of q, one hop for p*/
while (q->next != NULL)
{
q = q->next;
if (flag)
{
p = p->next;
}
flag = !flag;
}
if (flag)
{
printf("List contains even number of nodes\nThe middle two node's values are: %d  %d\n", p->next->num, p->num);
}
else
{
printf("The middle node of the list is: %d\n", p->num);
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = *head;
*head = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Read a Linked List in Reverse 
================================ EOPN
/* * C Program to Read a Linked List in Reverse  
================================ EOKW
--------------------------------
output:
$ cc readreverse.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Displaying the nodes in the list:
1   2   3   4   5   
Displaying the list in reverse:
5   4   3   2   1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void reversedisplay(struct node *);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
struct node_occur *head = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the nodes in the list:\n");
display(p);
printf("Displaying the list in reverse:\n");
reversedisplay(p);
release(&p);

return 0;
}

void reversedisplay(struct node *head)
{
if (head != NULL)
{
reversedisplay(head->next);
printf("%d\t", head->num);
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Remove Duplicates from a Linked List 
================================ EOPN
/* * C Program to Remove Duplicates from a Linked List  
================================ EOKW
--------------------------------
output:
$ cc duplicate.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 0
 
Displaying the nodes in the list:
1   2   1   3   2   4   
Deleting duplicate elements in the list...
Displaying non-deleted nodes in the list:
1   2   3   4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void dup_delete(struct node **);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
struct node_occur *head = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the nodes in the list:\n");
display(p);
printf("Deleting duplicate elements in the list...\n");
dup_delete(&p);
printf("Displaying non-deleted nodes in the list:\n");
display(p);
release(&p);

return 0;
}

void dup_delete(struct node **head)
{
struct node *p, *q, *prev, *temp;

p = q = prev = *head;
q = q->next;
while (p != NULL)
{
while (q != NULL && q->num != p->num)
{
prev = q;
q = q->next;
}
if (q == NULL)
{
p = p->next;
if (p != NULL)
{
q = p->next;
}
}
else if (q->num == p->num)
{
prev->next = q->next;
temp = q;
q = q->next;
free(temp);
}
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Reverse a Linked List 
================================ EOPN
/* * C Program to Reverse a Linked List  
================================ EOKW
--------------------------------
output:
$ cc duplicate.c
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Displaying the nodes in the list:
1   2   3   4   5   
Reversing the list...
Displaying the reversed list:
5   4   3   2   1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void reverse(struct node **);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the nodes in the list:\n");
display(p);
printf("Reversing the list...\n");
reverse(&p);
printf("Displaying the reversed list:\n");
display(p);
release(&p);

return 0;
}

void reverse(struct node **head)
{
struct node *p, *q, *r;

p = q = r = *head;
p = p->next->next;
q = q->next;
r->next = NULL;
q->next = r;

while (p != NULL)
{
r = q;
q = p;
p = p->next;
q->next = r;
}
*head = q;
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Reverse only First N Elements of a Linked List 
================================ EOPN
/* * C Program to Reverse only First N Elements of a Linked List  
================================ EOKW
--------------------------------
output:
$ cc nreverse.c 
$ ./a.out 
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 1
Enter number: 6
Do you wish to continue [1/0]: 1
Enter number: 7
Do you wish to continue [1/0]: 0
 
Displaying the nodes in the list:
1   2   3   4   5   6   7   
Enter the number N to reverse first N node: 4
Reversing the list...
Displaying the reversed list:
4   3   2   1   5   6   7
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void reverse(struct node **, int);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the nodes in the list:\n");
display(p);
printf("Enter the number N to reverse first N node: ");
scanf("%d", &n);
printf("Reversing the list...\n");
if (n > 1)
{
reverse(&p, n - 2);
}
printf("Displaying the reversed list:\n");
display(p);
release(&p);

return 0;
}

void reverse(struct node **head, int n)
{
struct node *p, *q, *r, *rear;

p = q = r = *head;
if (n == 0)
{
q = q->next;
p->next = q->next;
q->next = p;
*head = q;
}
else
{
p = p->next->next;
q = q->next;
r->next = NULL;
rear = r;
q->next = r;

while (n > 0 && p != NULL)
{
r = q;
q = p;
p = p->next;
q->next = r;
n--;
}
*head = q;
rear->next = p;
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program that takes an Ordered Binary tree & Rearranges the Internal Pointers to make a Circular Doubly Linked List out of the Tree Nodes 
================================ EOPN
/* * C Program that takes an Ordered Binary tree & Rearranges the  * Internal Pointers to make a Circular Doubly Linked List out  * of the Tree Nodes  
================================ EOKW
--------------------------------
output:
$ gcc treetocircular.c 
$ ./a.out
Creating binary tree:
Enter a number in the tree: 5
Do you want to add more numbers? [1/0]
1
Enter a number in the tree: 3
Do you want to add more numbers? [1/0]
1
Enter a number in the tree: 4
Do you want to add more numbers? [1/0]
1
Enter a number in the tree: 2
Do you want to add more numbers? [1/0]
1
Enter a number in the tree: 7
Do you want to add more numbers? [1/0]
1
Enter a number in the tree: 6
Do you want to add more numbers? [1/0]
1
Enter a number in the tree: 8
Do you want to add more numbers? [1/0]
0
Displaying binary tree:
8   7   6   5   4   3   2  
Displaying circular linked list:
8   7   6   5   4   3   2
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *left;
struct node *right;
int used;
};

void create(struct node **);
void release(struct node **);
void display(struct node *, int);
struct node * transformdet(struct node *);
struct node * transform(struct node *);

int main()
{
struct node *root = NULL, *head;

printf("Creating binary tree:\n");
create (&root);
printf("Displaying binary tree:\n");
display(root, 0);
head = transform(root);
printf("\nDisplaying circular linked list:\n");
display(head, 1);
root->left->right = NULL;
release(&root);

return 0;
}

struct node * transformdet(struct node *root)
{
struct node *left, *right;

if (root == NULL)
{
return root;
}
if (root->left != NULL)
{
left = transformdet(root->left);
while (left->right != NULL)
{
left = left->right;
}
left->right = root;
root->left = left;
}
if (root->right != NULL)
{
right = transformdet(root->right);
while (right->left != NULL)
{
right = right->left;
}
right->left = root;
root->right = right;
}

return root;
}

struct node * transform(struct node *root)
{
struct node *rear;
if (root == NULL)
{
return root;
}
root = transformdet(root);
rear = root;
while (root->left != NULL)
{
root = root->left;
}
while (rear->right != NULL)
{
rear = rear->right;
}
root->left = rear;
rear->right = root;

return (root);
}

void create(struct node **root)
{
struct node *temp, *p, *q;
int a, ch;

do
{
p = *root;
printf("Enter a number in the tree: ");
scanf("%d", &a);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = a;
temp->used = 0;
temp->left = temp->right = NULL;
if (*root == NULL)
{
*root = temp;
}
else
{
while (p != NULL)
{
q = p;
if (p->num >= temp->num)
{
p = p->right;
}
else
{
p = p->left;
}
}
if (q->num >= temp->num)
{
q->right = temp;
}
else
{
q->left = temp;
}
}
printf("Do you want to add more numbers? [1/0]\n");
scanf("%d", &ch);
} while (ch != 0);
}

void display(struct node *root, int n)
{
struct node *temp;

if (root != NULL && !n)
{
display(root->left, 0);
printf("%d   ", root->num);
display(root->right, 0);
}
else if (root != NULL && n)
{
temp = root;
printf("%d   ", temp->num);
temp = temp->right;
while (temp != root)
{
printf("%d   ", temp->num);
temp = temp->right;
}
printf("\n");
}
}

void release(struct node **root)
{
if (*root != NULL)
{
release(&(*root)->right);
free(*root);
}
}
 ETP 
 
 C Program to Construct a Balanced Binary Search Tree which has same data members as the given Doubly Linked List  
================================ EOPN
/* * C Program to Construct a Balanced Binary Search Tree * which has same data members as the given Doubly Linked List   
================================ EOKW
--------------------------------
output:
$ gcc doublytotree.c
$ ./a.out 
Enter a number: 1
Do you wish to continue [1/0] ?: 1
Enter a number: 2
Do you wish to continue [1/0] ?: 1
Enter a number: 3
Do you wish to continue [1/0] ?: 1
Enter a number: 4
Do you wish to continue [1/0] ?: 1
Enter a number: 5
Do you wish to continue [1/0] ?: 1
Enter a number: 6
Do you wish to continue [1/0] ?: 0
Displaying the doubly linked list:
1  2  3  4  5  6  
Displaying the tree: (Inorder)
1  2  3  4  5  6
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *left;
struct node *right;
};

void create(struct node **);
void treemaker(struct node **, int);
void display(struct node *);
void displayTree(struct node *);
void delete(struct node **);

int main()
{
struct node *headList = NULL, *rootTree, *p;
int count = 1, flag = 0;

create(&headList);
printf("Displaying the doubly linked list:\n");
display(headList);
rootTree = p = headList;
while (p->right != NULL)
{
p = p->right;
count = count + 1;
if (flag)
{
rootTree = rootTree->right;
}
flag = !flag;
}
treemaker(&rootTree, count / 2);
printf("Displaying the tree: (Inorder)\n");
displayTree(rootTree);
printf("\n");

return 0;
}

void create(struct node **head)
{
struct node *rear, *temp;
int a, ch;

do
{
printf("Enter a number: ");
scanf("%d", &a);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = a;
temp->right = NULL;
temp->left = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->right = temp;
temp->left = rear;
}
rear = temp;
printf("Do you wish to continue [1/0] ?: ");
scanf("%d", &ch);
} while (ch != 0);
}

void treemaker(struct node **root, int count)
{
struct node *quarter, *thirdquarter;
int n = count, i = 0;

if ((*root)->left != NULL)
{
quarter = (*root)->left;
for (i = 1; (i < count / 2) && (quarter->left != NULL); i++)
{
quarter = quarter->left;
}
(*root)->left->right = NULL;
(*root)->left = quarter;
/*
* Uncomment the following line to see when the pointer changes
*/
//printf("%d's left child is now %d\n", (*root)->num, quarter->num);
if (quarter != NULL)
{
treemaker(&quarter, count / 2);
}
}
if ((*root)->right != NULL)
{
thirdquarter = (*root)->right;
for (i = 1; (i < count / 2) && (thirdquarter->right != NULL); i++)
{
thirdquarter = thirdquarter->right;
}
(*root)->right->left = NULL;
(*root)->right = thirdquarter;
/*
* Uncomment the following line to see when the pointer changes
*/
//printf("%d's right child is now %d\n", (*root)->num, thirdquarter->num);
if (thirdquarter != NULL)
{
treemaker(&thirdquarter, count / 2);
}
}
}

void display(struct node *head)
{
while (head != NULL)
{
printf("%d  ", head->num);
head = head->right;
}
printf("\n");
}

/*DisplayTree performs inorder traversal*/
void displayTree(struct node *root)
{
if (root != NULL)
{
displayTree(root->left);
printf("%d  ", root->num);
displayTree(root->right);
}
}

void delete(struct node **root)
{
if (*root != NULL)
{
displayTree((*root)->left);
displayTree((*root)->right);
free(*root);
}
}
 ETP 
 
 C Program to Convert a Binary Tree into a Singly Linked List by Traversing Level by Level 
================================ EOPN
/* * C Program to Convert a Binary Tree into a Singly Linked List by Traversing Level by Level  
================================ EOKW
--------------------------------
output:
$ gcc treetolistbfs.c 
$ ./a.out
Enter a number for a node: 4
Do you want to continue? [1/0]: 1
Enter a number for a node: 2
Do you want to continue? [1/0]: 1
Enter a number for a node: 3
Do you want to continue? [1/0]: 1
Enter a number for a node: 1
Do you want to continue? [1/0]: 1
Enter a number for a node: 6
Do you want to continue? [1/0]: 1
Enter a number for a node: 5
Do you want to continue? [1/0]: 1
Enter a number for a node: 8
Do you want to continue? [1/0]: 1
Enter a number for a node: 7
Do you want to continue? [1/0]: 1
Enter a number for a node: 9
Do you want to continue? [1/0]: 0
Displaying the list generated at node by node level of the tree: 4  2  6  1  3  5  8  7  9
--------------------------------
<pre>
#include <stdio.h>
#include <stdlib.h>

/*structure type to create a tree*/
struct node
{
int num;
struct node *left;
struct node *right;
};
/*
* structure type to point to the nodes of a tree
* and also create self-referential list used for
* queueing.
*/
struct queue
{
struct node *nodeptr;
struct queue *next;
};
/* resulting singly linked list */
struct list
{
int num;
struct list *next;
};

void createTree(struct node **);
void createlistbfs(struct node *, struct list **);
void delete(struct node **);
void display(struct list *);
void deleteList(struct list **);

int main()
{
struct node *root = NULL;
struct list *head = NULL;

createTree(&root);
createlistbfs(root, &head);
printf("Displaying the list generated at node by node level of the tree: ");
display(head);
deleteList(&head);
delete(&root);

return 0;
}

void createTree(struct node **root)
{
struct node *temp, *p, *q;
int a, ch;

do
{
printf("Enter a number for a node: ");
scanf("%d", &a);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = a;
temp->left = NULL;
temp->right = NULL;
p = q = *root;
if (*root == NULL)
{
*root = temp;
}
else
{
while (1)
{
q = p;
if (p->num >= temp->num)
{
p = p->left;
}
else
{
p = p->right;
}
if (p == NULL)
{
break;
}
}
if (q->num >= temp->num)
q->left = temp;
else
q->right = temp;
}
printf("Do you want to continue? [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
}

void createlistbfs(struct node *root, struct list **head)
{
struct queue *qhead, *qrear, *qtemp, *qrelease;
struct list *temp, *rear;

if (root == NULL)
{
return;
}
qhead = (struct queue *)malloc(sizeof(struct queue));
qhead->nodeptr = root;
qhead->next = NULL;
qrear = qhead;
while (qhead != NULL)
{

temp = (struct list *)malloc(sizeof(struct list));
temp->num = qhead->nodeptr->num;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
if (qhead->nodeptr->left != NULL)
{
qtemp = (struct queue *)malloc(sizeof(struct queue));
qtemp->nodeptr = qhead->nodeptr->left;
qtemp->next = NULL;
qrear->next = qtemp;
qrear = qtemp;
}
if (qhead->nodeptr->right != NULL)
{
qtemp = (struct queue *)malloc(sizeof(struct queue));
qtemp->nodeptr = qhead->nodeptr->right;
qtemp->next = NULL;
qrear->next = qtemp;
qrear = qtemp;
}
qrelease = qhead;
qhead = qhead->next;
free(qrelease);
}
}

void delete(struct node **root)
{
if (*root == NULL)
{
return;
}
else
{
if ((*root)->left != NULL)
{
delete(&((*root)->left));
}
if ((*root)->right != NULL)
{
delete(&((*root)->right));
}
}
}

void display(struct list *head)
{
while (head != NULL)
{
printf("%d  ", head->num);
head = head->next;
}
}

void deleteList(struct list **head)
{
struct list *temp;

temp = *head;
while (temp != NULL)
{
*head = (*head)->next;
free(temp);
temp = *head;
}
}
 ETP 
 
 C Program to Convert a given Singly Linked List to a Circular List 
================================ EOPN
/* * C Program to Convert a given Singly Linked List to a Circular List  
================================ EOKW
--------------------------------
output:
$ cc single2circular.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Circular list generated
Displaying the list elements
5   4   3   2   1   and back to 5   4 ..
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void tocircular(struct node **);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
int result, count;

printf("Enter data into the list\n");
create(&p);
tocircular(&p);
printf("Circular list generated\n");
display(p);
release (&p);

return 0;
}

void tocircular(struct node **p)
{
struct node *rear;

rear = *p;
while (rear->next != NULL)
{
rear = rear->next;
}
rear->next = *p;
/*After this the singly linked list is now circular*/
}

void create(struct node **head)
{
int c, ch;
struct node *temp;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = *head;
*head = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *head)
{
struct node *temp = head;
printf("Displaying the list elements\n");
printf("%d\t", temp->num);
temp = temp->next;
while (head != temp)
{
printf("%d\t", temp->num);
temp = temp->next;
}
printf("and back to %d\t%d ..\n", temp->num, temp->next->num);
}

void release(struct node **head)
{
struct node *temp = *head;
temp = temp->next;
(*head)->next = NULL;
(*head) = temp->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Find Intersection & Union of 2 Linked Lists 
================================ EOPN
/* * C Program to Find Intersection & Union of 2 Linked Lists  
================================ EOKW
--------------------------------
output:
$ gcc unionandintersect.c 
$ ./a.out
Enter elements in the list 1
Enter a number: 1
Do you want to continue [1/0] ? 1
Enter a number: 2
Do you want to continue [1/0] ? 1
Enter a number: 5
Do you want to continue [1/0] ? 1
Enter a number: 6
Do you want to continue [1/0] ? 1
Enter a number: 8
Do you want to continue [1/0] ? 1
Enter a number: 9
Do you want to continue [1/0] ? 0
 
Enter elements in the list 2
Enter a number: 1
Do you want to continue [1/0] ? 1
Enter a number: 3
Do you want to continue [1/0] ? 1
Enter a number: 5
Do you want to continue [1/0] ? 1
Enter a number: 7
Do you want to continue [1/0] ? 1
Enter a number: 9
Do you want to continue [1/0] ? 0
 
Displaying list 1:
1   2   5   6   8   9   
Displaying list 2:
1   3   5   7   9   
Displaying the union of the 2 lists:
1   2   5   6   8   9   3   7   
Displaying the intersection of the 2 lists:
1   5   9
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void findunion(struct node *, struct node *, struct node **);
void findintersect(struct node *, struct node *, struct node **);
void display(struct node *);
void release(struct node **);

int main()
{
struct node *phead, *qhead, *intersect, *unionlist;

phead = qhead = intersect = unionlist = NULL;
printf("Enter elements in the list 1\n");
create(&phead);
printf("\nEnter elements in the list 2\n");
create(&qhead);
findunion(phead, qhead, &unionlist);
findintersect(phead, qhead, &intersect);
printf("\nDisplaying list 1:\n");
display(phead);
printf("Displaying list 2:\n");
display(qhead);
printf("Displaying the union of the 2 lists:\n");
display(unionlist);
printf("Displaying the intersection of the 2 lists:\n");
if (intersect == NULL)
{
printf("Null\n");
}
else
{
display(intersect);
}
release(&phead);
release(&qhead);
release(&unionlist);
release(&intersect);

return 0;
}

void findintersect(struct node *p, struct node *q, struct node **intersect)
{
struct node *ptemp, *qtemp, *itemp, *irear, *ifront;

ptemp = p;
while (ptemp != NULL)
{
qtemp = q;
ifront = *intersect;
while (qtemp != NULL && ptemp->num != qtemp->num)
{
qtemp = qtemp->next;
}
if (qtemp != NULL)
{
if (ifront != NULL)
{
if (ifront->num == qtemp->num)
{
ptemp = ptemp->next;
continue;
}
ifront = ifront->next;
}
itemp = (struct node *)malloc(sizeof(struct node));
itemp->num = qtemp->num;
itemp->next = NULL;
if (*intersect == NULL)
{
*intersect = itemp;
}
else
{
irear->next = itemp;
}
irear = itemp;
}
ptemp = ptemp->next;
}
}

void findunion(struct node *p, struct node *q, struct node **unionlist)
{
struct node *utemp, *ufront, *urear;
int flag = 0;

while (p != NULL)
{
ufront = *unionlist;
while (ufront != NULL)
{
if (ufront->num == p->num)
{
flag = 1;
}
ufront = ufront->next;
}
if (flag)
{
flag = 0;
}
else
{
utemp = (struct node *)malloc(sizeof(struct node));
utemp->num = p->num;
utemp->next = NULL;
if (*unionlist == NULL)
{
*unionlist = utemp;
}
else
{
urear->next = utemp;
}
urear = utemp;
}
p = p->next;
}
while (q != NULL)
{
ufront = *unionlist;
while (ufront != NULL)
{
if (ufront->num == q->num)
{
flag = 1;
}
ufront = ufront->next;
}
if (flag)
{
flag = 0;
}
else
{
utemp = (struct node *)malloc(sizeof(struct node));
utemp->num = q->num;
utemp->next = NULL;
if (*unionlist == NULL)
{
*unionlist = utemp;
}
else
{
urear->next = utemp;
}
urear = utemp;
}
q = q->next;
}
}

void create(struct node **head)
{
struct node *temp, *rear;
int ch, a;

do
{
printf("Enter a number: ");
scanf("%d", &a);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = a;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you want to continue [1/0] ? ");
scanf("%d", &ch);
} while (ch != 0);
}

void display(struct node *head)
{
while (head != NULL)
{
printf("%d   ", head->num);
head = head->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
while ((*head) != NULL)
{
(*head) = (*head)->next;
free (temp);
temp = *head;
}
}
 ETP 
 
 C Program to Interchange the two Adjacent Nodes given a circular Linked List 
================================ EOPN
/* * C Program to Interchange the two Adjacent Nodes given a circular * Linked List  
================================ EOKW
--------------------------------
output:
$ gcc interchangenode.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Circular list generated
Displaying the list elements
1   2   3   4   5   
Enter node position to interchange with it's adjacent: 2
After interchanging, Displaying the list elements
1   3   2   4   5
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void tocircular(struct node **);
void release(struct node **);
void change(struct node **, int);
void display(struct node *);

int main()
{
struct node *p = NULL;
int num;

printf("Enter data into the list\n");
create(&p);
tocircular(&p);
printf("Circular list generated\n");
display(p);
printf("Enter node position to interchange with it's adjacent: ");
scanf("%d", &num);
change(&p, num - 2);
printf("After interchanging, ");
display(p);
release (&p);

return 0;
}

void tocircular(struct node **p)
{
struct node *rear;

rear = *p;
while (rear->next != NULL)
{
rear = rear->next;
}
rear->next = *p;
/*After this the singly linked list is now circular*/
}

void change(struct node **head, int num)
{
struct node *p, *q, *r;

p = q = r = *head;
p = p->next->next;
q = q->next;
while (num != 0)
{
r = q;
q = p;
p = p->next;
num--;
}
r->next = p;
q->next = p->next;
p->next = q;
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *head)
{
struct node *temp = head;
printf("Displaying the list elements\n");
printf("%d\t", temp->num);
temp = temp->next;
while (head != temp)
{
printf("%d\t", temp->num);
temp = temp->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
temp = temp->next;
(*head)->next = NULL;
(*head) = temp->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Interchange two Elements of the List without touching the Key Field  
================================ EOPN
/* * C Program to Interchange two Elements of the List without * touching the Key Field   
================================ EOKW
--------------------------------
output:
$ gcc exchangenodelist.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Circular list generated
Displaying the list elements
1   2   3   4   5   
Enter node position: 2
Enter node position to exchange with: 4
After interchanging, Displaying the list elements
1   4   3   2   5
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void release(struct node **);
void change(struct node **, int, int);
void display(struct node *);

int main()
{
struct node *p = NULL;
int num1, num2;

printf("Enter data into the list\n");
create(&p);
printf("Circular list generated\n");
display(p);
printf("Enter node position: ");
scanf("%d", &num1);
printf("Enter node position to exchange with: ");
scanf("%d", &num2);
change(&p, num1 - 2, num2 - 2);
printf("After interchanging, ");
display(p);
release (&p);

return 0;
}

void change(struct node **head, int num1, int num2)
{
struct node *p1, *q1, *r1;
struct node *p2, *q2, *r2;

p1 = q1 = r1 = *head;
p2 = q2 = r2 = *head;
if (num1 == num2)
{
return;
}
else if ((p1->next == NULL && num1 > 0) || (p1->next->next == NULL && num1 > 1))
{
printf("List smaller than entered node position.\n");
}
else if ((p2->next == NULL && num2 > 0) || (p2->next->next == NULL && num2 > 1))
{
printf("List smaller than entered node position.\n");
}
else
{
if (num1 >=0 && num2 >= 0)
{
p1 = p1->next->next;
q1 = q1->next;
while (num1 > 0)
{
r1 = q1;
q1 = p1;
p1 = p1->next;
num1--;
}
p2 = p2->next->next;
q2 = q2->next;
while (num2 > 0)
{
r2 = q2;
q2 = p2;
p2 = p2->next;
num2--;
}
r2->next = q1;
q2->next = p1;
r1->next = q2;
q1->next = p2;
}
else if (num1 == -1)
{
p2 = p2->next->next;
q2 = q2->next;
while (num2 > 0)
{
r2 = q2;
q2 = p2;
p2 = p2->next;
num2--;
}
if (p1->next != q2)
{
q2->next = p1->next;
p1->next = p2;
r2->next = p1;
}
else
{
p1->next = q2->next;
q2->next = p1;
}
*head = q2;
}
else if (num2 == -1)
{
p1 = p1->next->next;
q1 = q1->next;
while (num1 > 0)
{
r1 = q1;
q1 = p1;
p1 = p1->next;
num1--;
}
if (p2->next != q1)
{
q1->next = p2->next;
p2->next = p1;
r1->next = p2;
}
else
{
p2->next = q1->next;
q1->next = p2;
}
*head = q1;
}
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *head)
{
struct node *temp = head;
printf("Displaying the list elements\n");
while (temp != NULL)
{
printf("%d\t", temp->num);
temp = temp->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List 
================================ EOPN
/* * C Program to Modify the Linked List such that All Even Numbers * appear before all the Odd Numbers in the Modified Linked List  
================================ EOKW
--------------------------------
output:
$ gcc evenodd.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 1
Enter number: 6
Do you wish to continue [1/0]: 0
 
Displaying the nodes in the list:
1   2   3   4   5   6   
Displaying the list with even and then odd:
2   4   6   1   3   5
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void generate_evenodd(struct node *, struct node**);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL, *q = NULL;
int key, result;

printf("Enter data into the list\n");
create(&p);
printf("Displaying the nodes in the list:\n");
display(p);
generate_evenodd(p, &q);
printf("Displaying the list with even and then odd:\n");
display(q);
release(&p);

return 0;
}

void generate_evenodd(struct node *list, struct node **head)
{
struct node *even = NULL, *odd = NULL, *temp;
struct node *reven, *rodd;
while (list != NULL)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->num = list->num;
temp->next = NULL;
if (list->num % 2 == 0)
{
if (even == NULL)
{
even = temp;
}
else
{
reven->next = temp;
}
reven = temp;
}
else
{
if (odd == NULL)
{
odd = temp;
}
else
{
rodd->next = temp;
}
rodd = temp;
}
list = list->next;
}
reven->next = odd;
*head = even;
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void display(struct node *p)
{
while (p != NULL)
{
printf("%d\t", p->num);
p = p->next;
}
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Print Nth Node from the last of a Linked List 
================================ EOPN
/* * C Program to Print Nth Node from the last of a Linked List  
================================ EOKW
--------------------------------
output:
$ cc nthnode.c 
$ ./a.out
Enter data into the list
Enter number: 1
Do you wish to continue [1/0]: 1
Enter number: 2
Do you wish to continue [1/0]: 1
Enter number: 3
Do you wish to continue [1/0]: 1
Enter number: 4
Do you wish to continue [1/0]: 1
Enter number: 5
Do you wish to continue [1/0]: 0
 
Enter the value n to find nth position from the last node: 2
3 is 2 nodes from the last node.
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void nthnode(struct node *, int);
void release(struct node **);

int main()
{
struct node *p = NULL;
int n;

printf("Enter data into the list\n");
create(&p);
printf("Enter the value n to find nth position from the last node: ");
scanf("%d", &n);
nthnode(p, n);
release (&p);

return 0;
}

void nthnode(struct node *head, int n)
{
struct node *p, *q;
int i;

q = p = head;

for (i = 0; i < n && q != NULL; i++)
{
q = q->next;
}
if (i < n)
{
printf("Entered n = %d is larger than the number of elements = %d in list. Please try again.\n", n, i);
}
else
{
while (q->next != NULL)
{
q = q->next;
p = p->next;
}
printf("%d is %d nodes from the last node.\n", p->num, n);
}
}

void create(struct node **head)
{
int c, ch;
struct node *temp, *rear;

do
{
printf("Enter number: ");
scanf("%d", &c);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = c;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you wish to continue [1/0]: ");
scanf("%d", &ch);
} while (ch != 0);
printf("\n");
}

void release(struct node **head)
{
struct node *temp = *head;
*head = (*head)->next;
while ((*head) != NULL)
{
free(temp);
temp = *head;
(*head) = (*head)->next;
}
}
 ETP 
 
 C Program to Solve Josephus Problem using Linked List 
================================ EOPN
/* * C Program to Solve Josephus Problem using Linked List  
================================ EOKW
--------------------------------
output:
$ gcc josephus.c 
$ ./a.out
Enter a number: 1
Do you want to add a number [1/0]? 1
Enter a number: 2
Do you want to add a number [1/0]? 1
Enter a number: 3
Do you want to add a number [1/0]? 1
Enter a number: 4
Do you want to add a number [1/0]? 1
Enter a number: 5
Do you want to add a number [1/0]? 1
Enter a number: 6
Do you want to add a number [1/0]? 1
Enter a number: 7
Do you want to add a number [1/0]? 0
The persons in circular list are:
1   2   3   4   5   6   7   
Enter the number of persons to be skipped: 3
3 has been killed.
6 has been killed.
2 has been killed.
7 has been killed.
5 has been killed.
1 has been killed.
The person to survive is : 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int num;
struct node *next;
};

void create(struct node **);
void display(struct node *);
int survivor(struct node **, int);

int main()
{
struct node *head = NULL;
int survive, skip;

create(&head);
printf("The persons in circular list are:\n");
display(head);
printf("Enter the number of persons to be skipped: ");
scanf("%d", &skip);
survive = survivor(&head, skip);
printf("The person to survive is : %d\n", survive);
free(head);

return 0;
}

int survivor(struct node **head, int k)
{
struct node *p, *q;
int i;

q = p = *head;
while (p->next != p)
{
for (i = 0; i < k - 1; i++)
{
q = p;
p = p->next;
}
q->next = p->next;
printf("%d has been killed.\n", p->num);
free(p);
p = q->next;
}
*head = p;

return (p->num);
}

void create (struct node **head)
{
struct node *temp, *rear;
int a, ch;

do
{
printf("Enter a number: ");
scanf("%d", &a);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = a;
temp->next = NULL;
if (*head == NULL)
{
*head = temp;
}
else
{
rear->next = temp;
}
rear = temp;
printf("Do you want to add a number [1/0]? ");
scanf("%d", &ch);
} while (ch != 0);
rear->next = *head;
}

void display(struct node *head)
{
struct node *temp;

temp = head;
printf("%d   ", temp->num);
temp = temp->next;
while (head != temp)
{
printf("%d   ", temp->num);
temp = temp->next;
}
printf("\n");
}
 ETP 
 
 C Program to Support Infinite Precision Arithmetic & Store a Number as a List of Digits  
================================ EOPN
/* * C Program to Support Infinite Precision Arithmetic & Store a * Number as a List of Digits   
================================ EOKW
--------------------------------
output:
$ gcc infinitedigits.c 
$ ./a.out 
Enter number of any length
932429842394820948234948098391830283192193818310398291830131209
Number of integers entered are: 63
Displaying the number entered:
932429842394820948234948098391830283192193818310398291830131209
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

struct node
{
int num;
struct node *next;
};

int feednumber(struct node **);
void release(struct node **);
void display(struct node *);

int main()
{
struct node *p = NULL;
int pcount = 0, qcount = 0;

printf("Enter number of any length\n");
pcount = feednumber(&p);
printf("Number of integers entered are: %d\n", pcount);
printf("Displaying the number entered:\n");
display(p);
release(&p);

return 0;
}

/*Function to create nodes of numbers*/
int feednumber(struct node **head)
{
char ch, dig;
int count = 0;
struct node *temp, *rear = NULL;

ch = getchar();
while (ch != '\n')
{
dig = atoi(&ch);
temp = (struct node *)malloc(sizeof(struct node));
temp->num = dig;
temp->next = NULL;
count++;
if ((*head) == NULL)
{
*head = temp;
rear = temp;
}
else
{
rear->next = temp;
rear = rear->next;
}
ch = getchar();
}

return count;
}

/*Function to display the list of numbers*/
void display (struct node *head)
{
while (head != NULL)
{
printf("%d", head->num);
head = head->next;
}
printf("\n");
}

/*Function to free the allocated list of numbers*/
void release (struct node **head)
{
struct node *temp = *head;

while ((*head) != NULL)
{
(*head) = (*head)->next;
free(temp);
temp = *head;
}
}
 ETP 
 
 C Program to Implement a Stack  
================================ EOPN
/* * C program to implement stack. Stack is a LIFO data structure. * Stack operations: PUSH(insert operation), POP(Delete operation) * and Display stack. 
================================ EOKW
--------------------------------
output:
STACK OPERATION
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
1
Enter the element to be pushed
34
Do you want to continue(Type 0 or 1)?
0
$ a.out
STACK OPERATION
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
1
Enter the element to be pushed
34
Do you want to continue(Type 0 or 1)?
1
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
2
poped element is = 34
Do you want to continue(Type 0 or 1)?
1
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
3
Stack is empty
Do you want to continue(Type 0 or 1)?
1
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
1
Enter the element to be pushed
50
Do you want to continue(Type 0 or 1)?
1
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
1
Enter the element to be pushed
60
Do you want to continue(Type 0 or 1)?
1
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
3
 
The status of the stack is
60
50
 
Do you want to continue(Type 0 or 1)?
1
------------------------------------------
      1    -->    PUSH
      2    -->    POP
      3    -->    DISPLAY
      4    -->    EXIT
------------------------------------------
Enter your choice
4
--------------------------------
#include <stdio.h>
#define MAXSIZE 5

struct stack
{
int stk[MAXSIZE];
int top;
};
typedef struct stack STACK;
STACK s;

void push(void);
int  pop(void);
void display(void);

void main ()
{
int choice;
int option = 1;
s.top = -1;

printf ("STACK OPERATION\n");
while (option)
{
printf ("------------------------------------------\n");
printf ("      1    -->    PUSH               \n");
printf ("      2    -->    POP               \n");
printf ("      3    -->    DISPLAY               \n");
printf ("      4    -->    EXIT           \n");
printf ("------------------------------------------\n");

printf ("Enter your choice\n");
scanf    ("%d", &choice);
switch (choice)
{
case 1:
push();
break;
case 2:
pop();
break;
case 3:
display();
break;
case 4:
return;
}
fflush (stdin);
printf ("Do you want to continue(Type 0 or 1)?\n");
scanf    ("%d", &option);
}
}
/*  Function to add an element to the stack */
void push ()
{
int num;
if (s.top == (MAXSIZE - 1))
{
printf ("Stack is Full\n");
return;
}
else
{
printf ("Enter the element to be pushed\n");
scanf ("%d", &num);
s.top = s.top + 1;
s.stk[s.top] = num;
}
return;
}
/*  Function to delete an element from the stack */
int pop ()
{
int num;
if (s.top == - 1)
{
printf ("Stack is Empty\n");
return (s.top);
}
else
{
num = s.stk[s.top];
printf ("poped element is = %dn", s.stk[s.top]);
s.top = s.top - 1;
}
return(num);
}
/*  Function to display the status of the stack */
void display ()
{
int i;
if (s.top == -1)
{
printf ("Stack is empty\n");
return;
}
else
{
printf ("\n The status of the stack is \n");
for (i = s.top; i >= 0; i--)
{
printf ("%d\n", s.stk[i]);
}
}
printf ("\n");
}
 ETP 
 
C Program to Reverse a Stack using Recursion
================================ EOPN
/* * C Program to Reverse a Stack using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm40.c
$ a.out
Enter length of list: 10
 
The sequence of contents in stack
1  2  3  4  5  6  7  8  9  10  
Inversing the contents of the stack
 
The contents in stack after reversal
10  9  8  7  6  5  4  3  2  1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void stack_reverse(struct node **, struct node **);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nThe sequence of contents in stack\n");
display(head);
printf("\nInversing the contents of the stack\n");
if (head != NULL)
{
stack_reverse(&head, &(head->next));
}
printf("\nThe contents in stack after reversal\n");
display(head);
delete(&head);

return 0;
}

void stack_reverse(struct node **head, struct node **head_next)
{
struct node *temp;

if (*head_next != NULL)
{
temp = (*head_next)->next;
(*head_next)->next = (*head);
*head = *head_next;
*head_next = temp;
stack_reverse(head, head_next);
}
}

void display(struct node *head)
{
if (head != NULL)
{
printf("%d  ", head->a);
display(head->next);
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Reverse a Stack without using Recursion
================================ EOPN
/* * C Program to Reverse a Stack without using Recursion 
================================ EOKW
--------------------------------
output:
$ cc revstack_iter.c -o revstack_iter
$ a.out
Enter length of list: 8
 
The sequence of contents in stack
1  2  3  4  5  6  7  8  
Inversing the contents of the stack
 
The contents in stack after reversal
8  7  6  5  4  3  2  1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void stack_reverse(struct node **);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nThe sequence of contents in stack\n");
display(head);
printf("\nInversing the contents of the stack\n");
stack_reverse(&head);
printf("\nThe contents in stack after reversal\n");
display(head);
delete(&head);
return 0;
}

void stack_reverse(struct node **head)
{
struct node *temp, *prev;

if (*head == NULL)
{
printf("Stack does not exist\n");
}
else if ((*head)->next == NULL)
{
printf("Single node stack reversal brings no difference\n");
}
else if ((*head)->next->next == NULL)
{
(*head)->next->next = *head;
*head = (*head)->next;
(*head)->next->next = NULL;
}
else
{
prev = *head;
temp = (*head)->next;
*head = (*head)->next->next;
prev->next = NULL;
while ((*head)->next != NULL)
{
temp->next = prev;
prev = temp;
temp = *head;
*head = (*head)->next;
}
temp->next = prev;
(*head)->next = temp;
}
}

void display(struct node *head)
{
if (head != NULL)
{
printf("%d  ", head->a);
display(head->next);
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Implement two Stacks using a Single Array & Check for Overflow & Underflow
================================ EOPN
//This is a C Program to Implement two Stacks using a Single Array & Check for Overflow & Underflow#include <stdio.h>#define SIZE 10  int ar[SIZE];int top1 = -1;int top2 = SIZE; //Functions to push datavoid push_stack1 (int data){  if (top1 < top2 - 1)  {    ar[++top1] = data;  }  else  {    printf ("Stack Full! Cannot Push\n");  }}void push_stack2 (int data){  if (top1 < top2 - 1)  {    ar[--top2] = data;   }  else  {    printf ("Stack Full! Cannot Push\n");  }} //Functions to pop datavoid pop_stack1 (){  if (top1 >= 0)  {    int popped_value = ar[top1--];    printf ("%d is being popped from Stack 1\n", popped_value);  }  else  {    printf ("Stack Empty! Cannot Pop\n");  }}void pop_stack2 (){  if (top2 < SIZE)  {    int popped_value = ar[top2++];    printf ("%d is being popped from Stack 2\n", popped_value);  }  else  {    printf ("Stack Empty! Cannot Pop\n");  }} //Functions to Print Stack 1 and Stack 2void print_stack1 (){  int i;  for (i = top1; i >= 0; --i)  {    printf ("%d ", ar[i]);  }  printf ("\n");}void print_stack2 (){  int i;  for (i = top2; i < SIZE; ++i)  {    printf ("%d ", ar[i]);  }  printf ("\n");} int main(){  int ar[SIZE];  int i;  int num_of_ele;   printf ("We can push a total of 10 values\n");   //Number of elements pushed in stack 1 is 6  //Number of elements pushed in stack 2 is 4   for (i = 1; i <= 6; ++i)  {    push_stack1 (i);    printf ("Value Pushed in Stack 1 is %d\n", i);  }  for (i = 1; i <= 4; ++i)  {    push_stack2 (i);    printf ("Value Pushed in Stack 2 is %d\n", i);  }   //Print Both Stacks  print_stack1 ();  print_stack2 ();   //Pushing on Stack Full  printf ("Pushing Value in Stack 1 is %d\n", 11);  push_stack1 (11);   //Popping All Elements From Stack 1  num_of_ele = top1 + 1;  while (num_of_ele)  {    pop_stack1 ();    --num_of_ele;  }   //Trying to Pop From Empty Stack  pop_stack1 ();   return 0;}
================================ EOKW
--------------------------------
output:
gcc TwoStacksSingleArray.c
./a.out
We can push a total of 10 values
Value Pushed in Stack 1 is 1
Value Pushed in Stack 1 is 2
Value Pushed in Stack 1 is 3
Value Pushed in Stack 1 is 4
Value Pushed in Stack 1 is 5
Value Pushed in Stack 1 is 6
Value Pushed in Stack 2 is 1
Value Pushed in Stack 2 is 2
Value Pushed in Stack 2 is 3
Value Pushed in Stack 2 is 4
6 5 4 3 2 1 
4 3 2 1 
Pushing Value in Stack 1 is 11
Stack Full! Cannot Push
6 is being popped from Stack 1
5 is being popped from Stack 1
4 is being popped from Stack 1
3 is being popped from Stack 1
2 is being popped from Stack 1
1 is being popped from Stack 1
Stack Empty! Cannot Pop
--------------------------------
 ETP 
 
C Program to Implement a Stack using Linked List 
================================ EOPN
/*
 * C Program to Implement a Stack using Linked List
 
================================ EOKW
--------------------------------
output:
$ cc pgm2.c
$ a.out
 
1 - Push
2 - Pop
3 - Top
4 - Empty
5 - Exit
6 - Dipslay
7 - Stack Count
8 - Destroy stack
Enter choice : 1
Enter data : 56
 
Enter choice : 1
Enter data : 80
 
Enter choice : 2
 
Popped value : 80
Enter choice : 3
 
Top element : 56
Enter choice : 1
Enter data : 78
 
Enter choice : 1
Enter data : 90
 
Enter choice : 6
90 78 56
Enter choice : 7
 
No. of elements in stack : 3
Enter choice : 8
 
All stack elements destroyed
Enter choice : 4
 
Stack is empty
Enter choice : 5
--------------------------------

#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int info;
    struct node *ptr;
}*top,*top1,*temp;
 
int topelement();
void push(int data);
void pop();
void empty();
void display();
void destroy();
void stack_count();
void create();
 
int count = 0;
 
void main()
{
    int no, ch, e;
 
    printf("\n 1 - Push");
    printf("\n 2 - Pop");
    printf("\n 3 - Top");
    printf("\n 4 - Empty");
    printf("\n 5 - Exit");
    printf("\n 6 - Dipslay");
    printf("\n 7 - Stack Count");
    printf("\n 8 - Destroy stack");
 
    create();
 
    while (1)
    {
        printf("\n Enter choice : ");
        scanf("%d", &ch);
 
        switch (ch)
        {
        case 1:
            printf("Enter data : ");
            scanf("%d", &no);
            push(no);
            break;
        case 2:
            pop();
            break;
        case 3:
            if (top == NULL)
                printf("No elements in stack");
            else
            {
                e = topelement();
                printf("\n Top element : %d", e);
            }
            break;
        case 4:
            empty();
            break;
        case 5:
            exit(0);
        case 6:
            display();
            break;
        case 7:
            stack_count();
            break;
        case 8:
            destroy();
            break;
        default :
            printf(" Wrong choice, Please enter correct choice  ");
            break;
        }
    }
}
 
/* Create empty stack 
 ETP 
 
C Program to Implement a Queue using an Array
================================ EOPN
/* * C Program to Implement a Queue using an Array 
================================ EOKW
--------------------------------
output:
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 10
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 15
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 20
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 1
Inset the element in queue : 30
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 2
Element deleted from queue is : 10
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 3
Queue is :
15 20 30
1.Insert element to queue
2.Delete element from queue
3.Display all elements of queue
4.Quit
Enter your choice : 4
--------------------------------
#include <stdio.h>

#define MAX 50

void insert();
void delete();
void display();
int queue_array[MAX];
int rear = - 1;
int front = - 1;
main()
{
int choice;
while (1)
{
printf("1.Insert element to queue \n");
printf("2.Delete element from queue \n");
printf("3.Display all elements of queue \n");
printf("4.Quit \n");
printf("Enter your choice : ");
scanf("%d", &choice);
switch (choice)
{
case 1:
insert();
break;
case 2:
delete();
break;
case 3:
display();
break;
case 4:
exit(1);
default:
printf("Wrong choice \n");
} /* End of switch */
} /* End of while */
} /* End of main() */

void insert()
{
int add_item;
if (rear == MAX - 1)
printf("Queue Overflow \n");
else
{
if (front == - 1)
/*If queue is initially empty */
front = 0;
printf("Inset the element in queue : ");
scanf("%d", &add_item);
rear = rear + 1;
queue_array[rear] = add_item;
}
} /* End of insert() */

void delete()
{
if (front == - 1 || front > rear)
{
printf("Queue Underflow \n");
return ;
}
else
{
printf("Element deleted from queue is : %d\n", queue_array[front]);
front = front + 1;
}
} /* End of delete() */

void display()
{
int i;
if (front == - 1)
printf("Queue is empty \n");
else
{
printf("Queue is : \n");
for (i = front; i <= rear; i++)
printf("%d ", queue_array[i]);
printf("\n");
}
} /* End of display() */
 ETP 
 
C Program to Implement Queue Data Structure using Linked List 
================================ EOPN
/*
 * C Program to Implement Queue Data Structure using Linked List
 
================================ EOKW
--------------------------------
output:
$ cc pgm4.c
$ a.out
 
1 - Enque
2 - Deque
3 - Front element
4 - Empty
5 - Exit
6 - Display
7 - Queue size
Enter choice : 1
Enter data : 14
 
Enter choice : 1
Enter data : 85
 
Enter choice : 1
Enter data : 38
 
Enter choice : 3
Front element : 14
Enter choice : 6
14 85 38
Enter choice : 7
 
Queue size : 3
Enter choice : 2
 
Dequed value : 14
Enter choice : 6
85 38
Enter choice : 7
 
Queue size : 2
Enter choice : 4
Queue not empty
Enter choice : 5
--------------------------------

#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int info;
    struct node *ptr;
}*front,*rear,*temp,*front1;
 
int frontelement();
void enq(int data);
void deq();
void empty();
void display();
void create();
void queuesize();
 
int count = 0;
 
void main()
{
    int no, ch, e;
 
    printf("\n 1 - Enque");
    printf("\n 2 - Deque");
    printf("\n 3 - Front element");
    printf("\n 4 - Empty");
    printf("\n 5 - Exit");
    printf("\n 6 - Display");
    printf("\n 7 - Queue size");
    create();
    while (1)
    {
        printf("\n Enter choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:
            printf("Enter data : ");
            scanf("%d", &no);
            enq(no);
            break;
        case 2:
            deq();
            break;
        case 3:
            e = frontelement();
            if (e != 0)
                printf("Front element : %d", e);
            else
                printf("\n No front element in Queue as queue is empty");
            break;
        case 4:
            empty();
            break;
        case 5:
            exit(0);
        case 6:
            display();
            break;
        case 7:
            queuesize();
            break;
        default:
            printf("Wrong choice, Please enter correct choice  ");
            break;
        }
    }
}
 
/* Create an empty queue 
 ETP 
 
 C Program to Implement Priority Queue to Add and Delete Elements 
================================ EOPN
/*  * C Program to Implement Priority Queue to Add and Delete Elements 
================================ EOKW
--------------------------------
output:
1 - Insert an element into queue
2 - Delete an element from queue
3 - Display queue elements
4 - Exit
Enter your choice : 1
 
Enter value to be inserted : 20
 
Enter your choice : 1
 
Enter value to be inserted : 45
 
Enter your choice : 1
 
Enter value to be inserted : 89
 
Enter your choice : 3
 89  45  20 
Enter your choice : 1
 
Enter value to be inserted : 56
 
Enter your choice : 3
 89  56  45  20 
Enter your choice : 2
 
Enter value to delete : 45
 
Enter your choice : 3
 89  56  20 
Enter your choice : 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

#define MAX 5

void insert_by_priority(int);
void delete_by_priority(int);
void create();
void check(int);
void display_pqueue();

int pri_que[MAX];
int front, rear;

void main()
{
int n, ch;

printf("\n1 - Insert an element into queue");
printf("\n2 - Delete an element from queue");
printf("\n3 - Display queue elements");
printf("\n4 - Exit");

create();

while (1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);

switch (ch)
{
case 1:
printf("\nEnter value to be inserted : ");
scanf("%d",&n);
insert_by_priority(n);
break;
case 2:
printf("\nEnter value to delete : ");
scanf("%d",&n);
delete_by_priority(n);
break;
case 3:
display_pqueue();
break;
case 4:
exit(0);
default:
printf("\nChoice is incorrect, Enter a correct choice");
}
}
}

/* Function to create an empty priority queue */
void create()
{
front = rear = -1;
}

/* Function to insert value into priority queue */
void insert_by_priority(int data)
{
if (rear >= MAX - 1)
{
printf("\nQueue overflow no more elements can be inserted");
return;
}
if ((front == -1) && (rear == -1))
{
front++;
rear++;
pri_que[rear] = data;
return;
}
else
check(data);
rear++;
}

/* Function to check priority and place element */
void check(int data)
{
int i,j;

for (i = 0; i <= rear; i++)
{
if (data >= pri_que[i])
{
for (j = rear + 1; j > i; j--)
{
pri_que[j] = pri_que[j - 1];
}
pri_que[i] = data;
return;
}
}
pri_que[i] = data;
}

/* Function to delete an element from queue */
void delete_by_priority(int data)
{
int i;

if ((front==-1) && (rear==-1))
{
printf("\nQueue is empty no elements to delete");
return;
}

for (i = 0; i <= rear; i++)
{
if (data == pri_que[i])
{
for (; i < rear; i++)
{
pri_que[i] = pri_que[i + 1];
}

pri_que[i] = -99;
rear--;

if (rear == -1)
front = -1;
return;
}
}
printf("\n%d not found in queue to delete", data);
}

/* Function to display queue elements */
void display_pqueue()
{
if ((front == -1) && (rear == -1))
{
printf("\nQueue is empty");
return;
}

for (; front <= rear; front++)
{
printf(" %d ", pri_que[front]);
}

front = 0;
}
 ETP 
 
 C Program to Check String is Palindrome using Stack 
================================ EOPN
/* * C Program to Identify whether the String is Palindrome or not using Stack 
================================ EOKW
--------------------------------
output:
1-enter string
2-exit
enter your choice
1
Enter the String
madam
madam is palindrome
1-enter string
2-exit
enter your choice
1
Enter the String
ugesh
ugesh is not a palindrome
1-enter string
2-exit
enter your choice
1
Enter the String
abccba
abccba is palindrome
1-enter string
2-exit
enter your choice
1
Enter the String
abdbca
abdbca is not a palindrome
1-enter string
2-exit
enter your choice
2
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 50

int top = -1, front = 0;
int stack[MAX];
void push(char);
void pop();

void main()
{
int i, choice;
char s[MAX], b;
while (1)
{
printf("1-enter string\n2-exit\n");
printf("enter your choice\n");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("Enter the String\n");
scanf("%s", s);
for (i = 0;s[i] != '\0';i++)
{
b = s[i];
push(b);
}
for (i = 0;i < (strlen(s) / 2);i++)
{
if (stack[top] == stack[front])
{
pop();
front++;
}
else
{
printf("%s is not a palindrome\n", s);
break;
}
}
if ((strlen(s) / 2)  =  =  front)
printf("%s is palindrome\n",  s);
front  =  0;
top  =  -1;
break;
case 2:
exit(0);
default:
printf("enter correct choice\n");
}
}
}

/* to push a character into stack */
void push(char a)
{
top++;
stack[top]  =  a;
}

/* to delete an element in stack */
void pop()
{
top--;
}
 ETP 
 
 C Program to Check if Expression is correctly Parenthesized 
================================ EOPN
/* * C Program to Check if Expression is correctly Parenthesized   
================================ EOKW
--------------------------------
output:
enter expression
(a+b)
expression is valid
 
 
enter expression
(a+b))
expression is invalid
 
 
enter expression
((a+b)
expression is invalid
 
 
enter expression
((a+b)*(c+d))
expression is valid
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int top = -1;
char stack[100];

// function prototypes
void push(char);
void pop();
void find_top();

void main()
{
int i;
char a[100];
printf("enter expression\n");
scanf("%s", &a);
for (i = 0; a[i] != '\0';i++)
{
if (a[i] == '(')
{
push(a[i]);
}
else if (a[i] == ')')
{
pop();
}
}
find_top();
}

// to push elements in stack
void push(char a)
{
stack[top] = a;
top++;
}

// to pop elements from stack
void pop()
{
if (top == -1)
{
printf("expression is invalid\n");
exit(0);
}
else
{
top--;
}
}

// to find top element of stack
void find_top()
{
if (top == -1)
printf("\nexpression is valid\n");
else
printf("\nexpression is invalid\n");
}
 ETP 
 
 C Program to Identify whether the String is Palindrome or not using Stack 
================================ EOPN
/* * C Program to Identify whether the String is Palindrome or not using Stack 
================================ EOKW
--------------------------------
output:
1-enter string
2-exit
enter your choice
1
Enter the String
madam
madam is palindrome
1-enter string
2-exit
enter your choice
1
Enter the String
ugesh
ugesh is not a palindrome
1-enter string
2-exit
enter your choice
1
Enter the String
abccba
abccba is palindrome
1-enter string
2-exit
enter your choice
1
Enter the String
abdbca
abdbca is not a palindrome
1-enter string
2-exit
enter your choice
2
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 50

int top = -1, front = 0;
int stack[MAX];
void push(char);
void pop();

void main()
{
int i, choice;
char s[MAX], b;
while (1)
{
printf("1-enter string\n2-exit\n");
printf("enter your choice\n");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("Enter the String\n");
scanf("%s", s);
for (i = 0;s[i] != '\0';i++)
{
b = s[i];
push(b);
}
for (i = 0;i < (strlen(s) / 2);i++)
{
if (stack[top] == stack[front])
{
pop();
front++;
}
else
{
printf("%s is not a palindrome\n", s);
break;
}
}
if ((strlen(s) / 2)  =  =  front)
printf("%s is palindrome\n",  s);
front  =  0;
top  =  -1;
break;
case 2:
exit(0);
default:
printf("enter correct choice\n");
}
}
}

/* to push a character into stack */
void push(char a)
{
top++;
stack[top]  =  a;
}

/* to delete an element in stack */
void pop()
{
top--;
}
 ETP 
 
 C Program to Implement various Queue Functions using Dynamic Memory Allocation 
================================ EOPN
/* * C Program to Implement various Queue Functions using Dynamic Memory Allocation 
================================ EOKW
--------------------------------
output:
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
6
 
**************Size is 0 ************
 
enter your choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
3
queue is empty
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
4
queue is empty
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
5
****************The queue is empty****************
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
2
enter value to insert
45
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
2
enter value to insert
56
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
2
enter value to insert
67
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
2
enter value to insert
78
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
2
enter value to insert
89
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
6
- 45 -- 56 -- 67 -- 78 -- 89 -
**************Size is 5 ************
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
5
****************The front element is 45 ***********
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
3
******45 has been removed******
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
3
******56 has been removed******
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
3
******67 has been removed******
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
6
- 78 -- 89 -
**************Size is 2 ************
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
3
******78 has been removed******
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
3
******89 has been removed******
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
6
 
**************Size is 0 ************
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
2
enter value to insert
34
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
6
- 34 -
**************Size is 1 ************
 
enter the choice
1 : create an empty queue
2 : Insert element
3 : Dequeue an element
4 : Check if empty
5 : Get the first element of the queue
6 : Get the number of entries in the queue
7 : Exit
7
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#define MAX 10

struct node
{
int data;
struct node *link;
}*front, *rear;

// function protypes
void insert();
void delete();
void queue_size();
void check();
void first_element();

void main()
{
int choice, value;

while(1)
{
printf("enter the choice \n");
printf("1 : create an empty queue \n2 : Insert element\n");
printf("3 : Dequeue an element \n4 : Check if empty\n");
printf("5. Get the first element of the queue\n");
printf("6. Get the number of entries in the queue\n");
printf("7. Exit\n");
scanf("%d", &choice);
switch (choice)    // menu driven program
{
case 1:
printf("Empty queue is created with a capacity of %d\n", MAX);
break;
case 2:
insert();
break;
case 3:
delete();
break;
case 4:
check();
break;
case 5:
first_element();
break;
case 6:
queue_size();
break;
case 7:
exit(0);
default:
printf("wrong choice\n");
break;
}
}
}

// to insert elements in queue
void insert()
{
struct node *temp;

temp = (struct node*)malloc(sizeof(struct node));
printf("Enter value to be inserted \n");
scanf("%d", &temp->data);
temp->link = NULL;
if (rear  ==  NULL)
{
front = rear = temp;
}
else
{
rear->link = temp;
rear = temp;
}
}

// delete elements from queue
void delete()
{
struct node *temp;

temp = front;
if (front == NULL)
{
printf("queue is empty \n");
front = rear = NULL;
}
else
{
printf("deleted element is %d\n", front->data);
front = front->link;
free(temp);
}
}

// check if queue is empty or not
void check()
{
if (front == NULL)
printf("\nQueue is empty\n");
else
printf("*************** Elements are present in the queue **************\n");
}

// returns first element of queue
void first_element()
{
if (front == NULL)
{
printf("**************** The queue is empty ****************\n");
}
else
printf("**************** The front element is %d ***********\n", front->data);
}

// returns number of entries and displays the elements in queue
void queue_size()
{
struct node *temp;

temp = front;
int cnt = 0;
if (front  ==  NULL)
{
printf(" queue empty \n");
}
while (temp)
{
printf("%d  ", temp->data);
temp = temp->link;
cnt++;
}
printf("********* size of queue is %d ******** \n", cnt);
}
 ETP 
 
 C Program to Implement Queue Functions Using Arrays and Macros 
================================ EOPN
/* * C Program to Implement Queue Functions Using Arrays and Macros 
================================ EOKW
--------------------------------
output:
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:3
QUEUE EMPTY
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:2
QUEUE EMPTY
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:4
QUEUE EMPTY
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:5
QUEUE EMPTY
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:1
 
Enter the value you want to insert in the queue:67
 
Element successfully inserted in the queue
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:1
 
Enter the value you want to insert in the queue:45
 
Element successfully inserted in the queue
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:3
67->45->
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:6
 
the queue size is: 2
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:5
The first element of the queue is: 67
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:2
 
The deleted element is: 67
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:3
45->
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:7
 
 
QUEUE DESTROYED
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:1
 
Enter the value you want to insert in the queue:45
 
Element successfully inserted in the queue
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:3
45->
Do you want to continue:y
MENU
Enter 1 to INSERT an element in the queue
Enter 2 to DELETE an element in the queue
Enter 3 to DISPLAY the elements of the queue
Enter 4 to CHECK if the queue is EMPTY
Enter 5 to KNOW the FIRST element of the queue
Enter 6 to KNOW the queue SIZE
Enter 7 to Destroy the Queue
Enter 8 to EXIT the program
Enter your Choice:8
--------------------------------
#include <stdio.h>
#include<stdlib.h>

/* Macro  Definition */
#define MAX 10
#define EMPTY "QUEUE EMPTY"
#define ISFULL rear >=  MAX - 1
#define FULL "QUEUE FULL"
#define ISEMPTY rear == -1

/* Global Variable Declaration */
int queue[MAX], front = 0, rear = -1;

/* Fucntion Prototypes */
void insert_rear();
void delete_front();
void display_queue();
void empty_queue();
void front_ele();
int queue_size();
void destroy();

void main()
{
int choice, n, flag = 0;
char ch;

do
{
printf("MENU\n");
printf("Enter 1 to INSERT an element in the queue\n");
printf("Enter 2 to DELETE an element in the queue\n");
printf("Enter 3 to DISPLAY the elements of the queue\n");
printf("Enter 4 to CHECK if the queue is EMPTY\n");
printf("Enter 5 to KNOW the FIRST element of the queue\n");
printf("Enter 6 to KNOW the queue SIZE\n");
printf("Enter 7 to Destroy the Queue\n");
printf("Enter 8 to EXIT the program\n");
printf("Enter your Choice:");
scanf("%d", &choice);
switch(choice)
{
case 1:
insert_rear();
break;
case 2:
delete_front();
break;
case 3:
display_queue();
break;
case 4:
empty_queue();
break;
case 5:
front_ele();
break;
case 6:
n = queue_size();
printf("\nthe queue size is: %d", n);
break;
case 7:
destroy();
flag = 1;
break;
case 8:
exit(0);
break;
default:
printf("WRONG CHOICE\n");
}
printf("\nDo you want to continue:");
scanf(" %c", &ch);
} while(ch == 'y' || ch == 'Y');
if (flag == 0)
{
destroy();
}
}

/* Code to Insert the element in Queue */
void insert_rear()
{
int val;

if (ISFULL)
{
printf(FULL);
}
else
{
printf("\nEnter the value you want to insert in the queue:");
scanf("%d", &val);
rear++;
queue[rear] = val;
printf("\nElement successfully inserted in the queue");
}
}

/* Code to Delete the element in Queue */
void delete_front()
{
if (ISEMPTY)
{
printf(EMPTY);
}
else
{
printf("\nThe deleted element is: %d", queue[front]);
front++;
}
}

/* Code to Display the Elements of Queue */
void display_queue()
{
int i;

if (ISEMPTY)
{
printf(EMPTY);
}
else
{
for (i = front;i <= rear;i++)
{
printf("%d->", queue[i]);
}
}
}

/* Code to Check the Queue is Empty or Not */
void empty_queue()
{
if (ISEMPTY)
{
printf(EMPTY);
}
else
{
printf("\nTHE QUEUE has elements\n");
}
}


/* Code to Check the First element of Queue */
void front_ele()
{
if (ISEMPTY)
{
printf(EMPTY);
}
else
{
printf("The first element of the queue is: %d", queue[front]);
}
}

/* Code to Check the Size of Queue */
int queue_size()
{
int i = 0, count = 0;

if (ISEMPTY)
{
printf(EMPTY);
}
else
{
for (i = front;i <= rear;i++)
{
count++;
}
}
return count;
}

/* Code to destroy the queue */
void destroy()
{
int size, i;

if (ISEMPTY)
{
printf("EMPTY QUEUE CANNOT BE DESTROYED");
}
else
{
size = queue_size();

for (i = 0;i < size;i++)
{
front++;
}
front = 0;
rear = -1;
printf("\n\nQUEUE DESTROYED");
}
}
 ETP 
 
 C Program to Implement Queues using Stacks 
================================ EOPN
/* * C Program to Implement Queues using Stacks 
================================ EOKW
--------------------------------
output:
1 - Enqueue element into queue
2 - Dequeu element from queue
3 - Display from queue
4 - Exit
Enter choice1
Enter data into queue10
 
Enter choice1
Enter data into queue20
 
Enter choice1
Enter data into queue30
 
Enter choice1
Enter data into queue40
 
Enter choice3
 10  20  30  40
Enter choice2
 
Enter choice3
 20  30  40
Enter choice4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

void push1(int);
void push2(int);
int pop1();
int pop2();
void enqueue();
void dequeue();
void display();
void create();

int st1[100], st2[100];
int top1 = -1, top2 = -1;
int count = 0;

void main()
{
int ch;

printf("\n1 - Enqueue element into queue");
printf("\n2 - Dequeu element from queue");
printf("\n3 - Display from queue");
printf("\n4 - Exit");
create();
while (1)
{
printf("\nEnter choice");
scanf("%d", &ch);
switch (ch)
{
case 1:
enqueue();
break;
case 2:
dequeue();
break;
case 3:
display();
break;
case 4:
exit(0);
default:
printf("Wrong choice");
}
}
}

/*Function to create a queue*/
void create()
{
top1 = top2 = -1;
}

/*Function to push the element on to the stack*/
void push1(int data)
{
st1[++top1] = data;
}

/*Function to pop the element from the stack*/
int pop1()
{
return(st1[top1--]);
}

/*Function to push an element on to stack*/
void push2(int data)
{
st2[++top2] = data;
}

/*Function to pop an element from th stack*/

int pop2()
{
return(st2[top2--]);
}

/*Function to add an element into the queue using stack*/
void enqueue()
{
int data, i;

printf("Enter data into queue");
scanf("%d", &data);
push1(data);
count++;
}

/*Function to delete an element from the queue using stack*/

void dequeue()
{
int i;

for (i = 0;i <= count;i++)
{
push2(pop1());
}
pop2();
count--;
for (i = 0;i <= count;i++)
{
push1(pop2());
}
}

/*Function to display the elements in the stack*/

void display()
{
int i;

for (i = 0;i <= top1;i++)
{
printf(" %d ", st1[i]);
}
}
 ETP 
 
 C Program to Illustrate Stack Operations using MACROS 
================================ EOPN
/* * C Program to Illustrate Stack Operations using MACROS 
================================ EOKW
--------------------------------
output:
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT3
Stack is EmptyEnter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT2
Stack is EmptyEnter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT1
enter the value to be pushed on to the stack1
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT1
enter the value to be pushed on to the stack2
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT1
enter the value to be pushed on to the stack3
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT1
enter the value to be pushed on to the stack4
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT1
enter the value to be pushed on to the stack5
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT3
5
4
3
2
1
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT4
the size of the stack is 5
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT6
5
4
3
2
1
Stack is fullEnter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT2
the popped element is 5Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT2
the popped element is 4Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT2
the popped element is 3Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT3
2
1
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT5
the popped element is 2the popped element is 1Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT1
enter the value to be pushed on to the stack12
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT3
12
Enter Your choice:
1.PUSH
2.POP
3.DISPLAY
4.STACKSIZE
5.DESTROY
6.SATCKFULL CHECK
7.EXIT
--------------------------------
#include <stdio.h>
#include <stdlib.h>

#define MAX 5
#define EMPTY "Stack is Empty"
#define OVERFLOW "Stack Overflow"
#define ISOVERFLOW top >= MAX - 1 /*Macro to find whether the stack is full*/
#define ISEMPTY top == -1    /*Macro to find whether the stack is empty*/

void push(int);
void pop();
void display();
void stacksize();
void destroy();
void stackfull();

int top = -1;
int stack[MAX];

void main()
{
int choice, value;

while (1)
{
printf("Enter Your choice:\n");
printf("1.PUSH\n2.POP\n3.DISPLAY\n4.STACKSIZE\n5.DESTROY\n6.SATCKFULL CHECK\n7.EXIT");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("enter the value to be pushed on to the stack");
scanf("%d", &value);
push(value);
continue;
case 2:
pop();
continue;
case 3:
display();
continue;
case 4:
stacksize();
continue;
case 5:
destroy();
continue;
case 6:
stackfull();
continue;
case 7:
exit(0);
default:
printf("YOU HAVE ENTERD A WRONG CHOICE");
}
}
}

/*Function to add an element into the stack*/
void push(int value)
{
if (ISOVERFLOW)
{
printf(OVERFLOW);
return;
}
top++;
stack[top] = value;
}

/*Function to delete an element from the stack*/
void pop()
{
if (ISEMPTY)
{
printf(EMPTY);
return;
}
printf("the popped element is %d", stack[top]);
top--;
}

/*Function to display all the elements in the stack*/

void display()
{
int temp = top;

if (ISEMPTY)
{
printf(EMPTY);
return;
}
while (temp + 1)
{
printf("%d\n", stack[temp]);
temp--;
}
}

/* Function to check whether the stack is full using macro */
void stackfull()
{
int temp = top, count = 0;

if (ISEMPTY)
{
printf(EMPTY);
return;
}
while (temp + 1)
{
printf("%d\n", stack[temp]);
temp--;
count++;
}
if (count >= MAX)
{
printf("Stack is full");
}
else
{
printf("there are %d more spaces in the stack", (MAX-count));
}
}

/* Function to return the size of the stack */
void stacksize()
{
int temp = top, count = 0;
if (ISEMPTY)
{
printf(EMPTY);
return;
}
while (temp + 1)
{
temp--;
count++;
}
printf("the size of the stack is %d\n", count);
}

/* Function to delete all the elements in the stack */

void destroy()
{
if (ISEMPTY)
{
printf("nothing is there to destroy");
}
while (top != -1)
{
pop();
}
}
 ETP 
 
 C Program to Implement Stack Operations using Dynamic Memory Allocation 
================================ EOPN
/* * C Program to Implement Stack Operations using Dynamic Memory  * Allocation 
================================ EOKW
--------------------------------
output:
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
5
size of stack is 0
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
2
**Stack is empty**
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
3
STACK IS EMPTY
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
7
 
**Top is not available for an EMPTY stack**
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
1
 
Enter value which you want to push into the stack :
10
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
1
 
Enter value which you want to push into the stack :
20
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
1
 
Enter value which you want to push into the stack :
30
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
1
 
Enter value which you want to push into the stack :
40
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
1
 
Enter value which you want to push into the stack :
50
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
5
 50
 40
 30
 20
 10
size of stack is 5
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
4
stack is full
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
2
Value popped out is 50
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
2
Value popped out is 40
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
2
Value popped out is 30
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
6
Value popped out is 20
Value popped out is 10
stack destroyed
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
1
 
Enter value which you want to push into the stack :
25
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
5
 25
size of stack is 1
1. push an element
2. pop an element
3. check if stack is empty
4. check if stack is full
5. count/display elements present in stack
6. empty and destroy stack
7. Print top of the stack
8. exit
Enter your choice
8
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int data;
struct node *link;
}*top = NULL;

#define MAX 5

// function prototypes
void push();
void pop();
void empty();
void stack_full();
void stack_count();
void destroy();
void print_top();

void main()
{
int choice;

while (1)
{
printf("1. push an element \n");
printf("2. pop an element \n");
printf("3. check if stack is empty \n");
printf("4. check if stack is full \n");
printf("5. count/display elements present in stack \n");
printf("6. empty and destroy stack \n");
printf("7. Print top of the stack \n");
printf("8. exit \n");
printf("Enter your choice \n");
scanf("%d",&choice);
switch (choice)
{
case 1:
push();
break;
case 2:
pop();
break;
case 3:
empty();
break;
case 4:
stack_full();
break;
case 5:
stack_count();
break;
case 6:
destroy();
break;
case 7:
print_top();
break;
case 8:
exit(0);
default:
printf("wrong choice\n");
}
}
}

// to insert elements in stack
void push()
{
int val,count;
struct node *temp;
temp = (struct node*)malloc(sizeof(struct node));

count = st_count();
if (count <= MAX - 1)
{
printf("\nEnter value which you want to push into the stack :\n");
scanf("%d",&val);
temp->data = val;
temp->link = top;
top = temp;
}
else
printf("WARNING: STACK FULL\n");
}

// to delete elements from stack
void pop()
{
struct node *temp;
if (top =  = NULL)
printf("**Stack is empty**\n");
else
{
temp = top;
printf("Value popped out is %d \n",temp->data);
top = top->link;
free(temp);
}
}

// to check if stack is empty
void empty()
{
if (top == NULL)
printf("STACK IS EMPTY\n");
else
printf("elements are present, stack is not empty \n");
}

// to check if stack is full
void stack_full()
{
int count;

count = st_count();
if (count =  = MAX)
{
printf("stack is full\n");
}
else
printf("stack is not full \n");
}

// to count the number of elements
void stack_count()
{
int count = 0;
struct node *temp;

temp = top;
while (temp! = NULL)
{
printf(" %d\n",temp->data);
temp = temp->link;
count++;
}
printf("size of stack is %d \n",count);
}

int st_count()
{
int count = 0;
struct node *temp;
temp = top;
while (temp! = NULL)
{
temp = temp->link;
count++;
}
return count;
}

// to empty and destroy the stack
void destroy()
{
struct node *temp;
temp = top;
while (temp! = NULL)
{
pop();
temp = temp->link;
}
printf("stack destroyed\n");
}

// to print top element of stack
void print_top()
{
if (top == NULL)
printf("\n**Top is not available for an EMPTY stack**\n");
else
printf("\nTop of the stack is %d \n",top->data);
}
 ETP 
 
C Program to Sort N Numbers in Ascending Order using Bubble Sort
================================ EOPN
/* * C program to sort N numbers in ascending order using Bubble sort * and print both the given and the sorted array 
================================ EOKW
--------------------------------
output:
 
$ cc pgm21.c
$ a.out
Enter the value of num
6
Enter the elements one by one
23
45
67
89
12
34
Input array is
23
45
67
89
12
34
Sorted array is...
12
23
34
45
67
89
--------------------------------
#include <stdio.h>
#define MAXSIZE 10

void main()
{
int array[MAXSIZE];
int i, j, num, temp;

printf("Enter the value of num \n");
scanf("%d", &num);
printf("Enter the elements one by one \n");
for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}
printf("Input array is \n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
/*   Bubble sorting begins */
for (i = 0; i < num; i++)
{
for (j = 0; j < (num - i - 1); j++)
{
if (array[j] > array[j + 1])
{
temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
}
}
}
printf("Sorted array is...\n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
}
 ETP 
 
C Program to Sort the Array in an Ascending Order 
================================ EOPN
     /*     * C program to accept N numbers and arrange them in an ascending order     
================================ EOKW
--------------------------------
output:
 
Enter the value of N
6
Enter the numbers
3
78
90
456
780
200
The numbers arranged in ascending order are given below
3
78
90
200
456
780
--------------------------------

#include <stdio.h>
void main()
{

int i, j, a, n, number[30];
printf("Enter the value of N \n");
scanf("%d", &n);

printf("Enter the numbers \n");
for (i = 0; i < n; ++i)
scanf("%d", &number[i]);

for (i = 0; i < n; ++i)
{

for (j = i + 1; j < n; ++j)
{

if (number[i] > number[j])
{

a =  number[i];
number[i] = number[j];
number[j] = a;

}

}

}

printf("The numbers arranged in ascending order are given below \n");
for (i = 0; i < n; ++i)
printf("%d\n", number[i]);

}
 ETP 
 
 C Program to Sort the N Names in an Alphabetical Order
================================ EOPN
    /*     * C program to read N names, store them in the form of an array     * and sort them in alphabetical order. Output the given names and     * the sorted names in two columns side by side.     
================================ EOKW
--------------------------------
output:
Enter the value of n
7
Enter 7 names
heap
stack
queue
object
class
program
project
 
----------------------------------------
Input Names    Sorted names
------------------------------------------
heap           class
stack          heap
queue          object
object         program
class          project
program        queue
project        stack
------------------------------------------
--------------------------------

#include <stdio.h>
#include <string.h>
void main()
{

char name[10][8], tname[10][8], temp[8];
int i, j, n;

printf("Enter the value of n \n");
scanf("%d", &n);
printf("Enter %d names n \n", n);

for (i = 0; i < n; i++)
{
scanf("%s", name[i]);
strcpy(tname[i], name[i]);
}

for (i = 0; i < n - 1 ; i++)
{
for (j = i + 1; j < n; j++)
{
if (strcmp(name[i], name[j]) > 0)
{
strcpy(temp, name[i]);
strcpy(name[i], name[j]);
strcpy(name[j], temp);
}
}
}

printf("\n----------------------------------------\n");
printf("Input NamestSorted names\n");
printf("------------------------------------------\n");

for (i = 0; i < n; i++)
{
printf("%s\t\t%s\n", tname[i], name[i]);
}

printf("------------------------------------------\n");

}
 ETP 
 
C Program to Implement Selection Sort Recursively
================================ EOPN
/* * C Program to Implement Selection Sort Recursively 
================================ EOKW
--------------------------------
output:
$ cc pgm18.c
$ a.out
Enter the size of the list: 5
Enter the elements in list:
23
45
64
12
34
The sorted list in ascending order is
12  23  34  45  64
--------------------------------
#include <stdio.h>

void selection(int [], int, int, int, int);

int main()
{
int list[30], size, temp, i, j;

printf("Enter the size of the list: ");
scanf("%d", &size);
printf("Enter the elements in list:\n");
for (i = 0; i < size; i++)
{
scanf("%d", &list[i]);
}
selection(list, 0, 0, size, 1);
printf("The sorted list in ascending order is\n");
for (i = 0; i < size; i++)
{
printf("%d  ", list[i]);
}

return 0;
}

void selection(int list[], int i, int j, int size, int flag)
{
int temp;

if (i < size - 1)
{
if (flag)
{
j = i + 1;
}
if (j < size)
{
if (list[i] > list[j])
{
temp = list[i];
list[i] = list[j];
list[j] = temp;
}
selection(list, i, j + 1, size, 0);
}
selection(list, i + 1, 0, size, 1);
}
}
 ETP 
 
C Program to Implement Selection Sort Method using Functions 
================================ EOPN
/* * C program for SELECTION sort which uses following functions * a) To find maximum of elements * b) To swap two elements 
================================ EOKW
--------------------------------
output:
$ cc pgm33.c
$ a.out
Enter the value of n
4
Enter the elements one by one
57
90
34
78
Input array elements
57
90
34
78
Sorted array is...
34
57
78
90
--------------------------------
#include <stdio.h>

int findmax(int b[10], int k);
void exchang(int b[10], int k);
void main()
{
int array[10];
int i, j, n, temp;

printf("Enter the value of n \n");
scanf("%d", &n);
printf("Enter the elements one by one \n");
for (i = 0; i < n; i++)
{
scanf("%d", &array[i]);
}
printf("Input array elements \n");
for (i = 0; i < n ; i++)
{
printf("%d\n", array[i]);
}
/*  Selection sorting begins */
exchang(array, n);
printf("Sorted array is...\n");
for (i = 0; i < n; i++)
{
printf("%d\n", array[i]);
}
}
/*  function to find the maximum value */
int findmax(int b[10], int k)
{
int max = 0, j;
for (j = 1; j <= k; j++)
{
if (b[j] > b[max])
{
max = j;
}
}
return(max);
}
void exchang(int b[10], int k)
{
int  temp, big, j;
for (j = k - 1; j >= 1; j--)
{
big = findmax(b, j);
temp = b[big];
b[big] = b[j];
b[j] = temp;
}
return;
}
 ETP 
 
C Program to Input Few Numbers & Perform Merge Sort on them using Recursion
================================ EOPN
/* * C Program to Input Few Numbers & Perform Merge Sort on them using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm28.c
$ a.out
Enter total number of elements:5
Enter the elements:
12
36
22
76
54
After merge sort:
12   22   36   54   76
--------------------------------

#include <stdio.h>

void mergeSort(int [], int, int, int);
void partition(int [],int, int);

int main()
{
int list[50];
int i, size;

printf("Enter total number of elements:");
scanf("%d", &size);
printf("Enter the elements:\n");
for(i = 0; i < size; i++)
{
scanf("%d", &list[i]);
}
partition(list, 0, size - 1);
printf("After merge sort:\n");
for(i = 0;i < size; i++)
{
printf("%d   ",list[i]);
}

return 0;
}

void partition(int list[],int low,int high)
{
int mid;

if(low < high)
{
mid = (low + high) / 2;
partition(list, low, mid);
partition(list, mid + 1, high);
mergeSort(list, low, mid, high);
}
}

void mergeSort(int list[],int low,int mid,int high)
{
int i, mi, k, lo, temp[50];

lo = low;
i = low;
mi = mid + 1;
while ((lo <= mid) && (mi <= high))
{
if (list[lo] <= list[mi])
{
temp[i] = list[lo];
lo++;
}
else
{
temp[i] = list[mi];
mi++;
}
i++;
}
if (lo > mid)
{
for (k = mi; k <= high; k++)
{
temp[i] = list[k];
i++;
}
}
else
{
for (k = lo; k <= mid; k++)
{
temp[i] = list[k];
i++;
}
}

for (k = low; k <= high; k++)
{
list[k] = temp[k];
}
}
 ETP 
 
C Program to Perform Quick Sort on a set of Entries from a File using Recursion
================================ EOPN
/** C Program to Perform Quick Sort on a set of Entries from a File * using Recursion
================================ EOKW
--------------------------------
output:
$ cc pgm29.c
$ a.out
Enter the number of elements: 6
Enter the elements to be sorted:
67
45
24
98
12
38
After applying quick sort
12 24 38 45 67 98
--------------------------------
#include <stdio.h>

void quicksort (int [], int, int);

int main()
{
int list[50];
int size, i;

printf("Enter the number of elements: ");
scanf("%d", &size);
printf("Enter the elements to be sorted:\n");
for (i = 0; i < size; i++)
{
scanf("%d", &list[i]);
}
quicksort(list, 0, size - 1);
printf("After applying quick sort\n");
for (i = 0; i < size; i++)
{
printf("%d ", list[i]);
}
printf("\n");

return 0;
}
void quicksort(int list[], int low, int high)
{
int pivot, i, j, temp;
if (low < high)
{
pivot = low;
i = low;
j = high;
while (i < j)
{
while (list[i] <= list[pivot] && i <= high)
{
i++;
}
while (list[j] > list[pivot] && j >= low)
{
j--;
}
if (i < j)
{
temp = list[i];
list[i] = list[j];
list[j] = temp;
}
}
temp = list[j];
list[j] = list[pivot];
list[pivot] = temp;
quicksort(list, low, j - 1);
quicksort(list, j + 1, high);
}
}
 ETP 
 
 C Program to Read an Array and Search for an Element 
================================ EOPN
     /*     * C program accept an array of N elements and a key to search.     * If the search is successful, it displays "SUCCESSFUL SEARCH".     * Otherwise, a message "UNSUCCESSFUL SEARCH" is displayed.     
================================ EOKW
--------------------------------
output:
Enter the size of an array
4
Enter the array elements
90
560
300
390
Enter the key
90
SUCCESSFUL SEARCH
 
$ a.out
Enter the size of an array
4
Enter the array elements
100
500
580
470
Enter the key
300
UNSUCCESSFUL SEARCH
--------------------------------

#include <stdio.h>
void main()
{

int array[20];
int i, low, mid, high, key, size;

printf("Enter the size of an array\n");
scanf("%d", &size);

printf("Enter the array elements\n");
for (i = 0; i < size; i++)
{
scanf("%d", &array[i]);
}

printf("Enter the key\n");
scanf("%d", &key);

/*  search begins */

low = 0;
high = (size - 1);

while (low <= high)
{
mid = (low + high) / 2;

if (key == array[mid])
{
printf("SUCCESSFUL SEARCH\n");
return;
}

if (key < array[mid])
high = mid - 1;

else
low = mid + 1;

}

printf("UNSUCCESSFUL SEARCH\n");

}
 ETP 
 
C Program to accept Sorted Array and do Search using Binary Search 
================================ EOPN
/* * C program to accept N numbers sorted in ascending order * and to search for a given number using Binary Search. * Report success or failure. 
================================ EOKW
--------------------------------
output:
If the input array is {1, 2, 3, 4, 5, 6}
and the key to be searched for is 6
then the expected output will be "Search Successful".
--------------------------------
#include <stdio.h>

void main()
{
int array[10];
int i, j, num, temp, keynum;
int low, mid, high;
printf("Enter the value of num \n");
scanf("%d", &num);
printf("Enter the elements one by one \n");
for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}
printf("Input array elements \n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
/*  Bubble sorting begins */
for (i = 0; i < num; i++)
{
for (j = 0; j < (num - i - 1); j++)
{
if (array[j] > array[j + 1])
{
temp = array[j];
array[j] = array[j + 1];
array[j + 1] = temp;
}
}
}
printf("Sorted array is...\n");
for (i = 0; i < num; i++)
{
printf("%d\n", array[i]);
}
printf("Enter the element to be searched \n");
scanf("%d", &keynum);
/*  Binary searching begins */
low = 1;
high = num;
do
{
mid = (low + high) / 2;
if (keynum < array[mid])
high = mid - 1;
else if (keynum > array[mid])
low = mid + 1;
} while (keynum != array[mid] && low <= high);
if (keynum == array[mid])
{
printf("SEARCH SUCCESSFUL \n");
}
else
{
printf("SEARCH FAILED \n");
}
}
 ETP 
 
C Program using Recursion to Search an Element in Array
================================ EOPN
/* * C Program to search for an element in a list using 
================================ EOKW
--------------------------------
output:
$ cc search
$ a.out
Enter the size of the list: 10
 
Printing the list:
3   6   7   5   3   5   6   2   9   1
 
Enter the key to search: 5
 
Key found at position: 6
 
Key found at position: 4
--------------------------------
#include <stdio.h>

int search(int [], int, int);
int main()
{
int size, index, key;
int list[20];
int count = 0;
int i;

printf("Enter the size of the list: ");
scanf("%d", &size);
index = size;
printf("Printing the list:\n");
for (i = 0; i < size; i++)
{
list[i] = rand() % size;
printf("%d\t", list[i]);
}
printf("\nEnter the key to search: ");
scanf("%d", &key);
while (index > 0)
{
index = search(list, index - 1, key);
/* In an array first position is indexed by 0 */
printf("Key found at position: %d\n", index + 1);
count++;
}
if (!count)
printf("Key not found.\n");
return 0;
}
int search(int array[], int size, int key)
{
int location;
if (array[size] == key)
{
return size;
}
else if (size == -1)
{
return -1;
}
else
{
return (location = search(array, size - 1, key));
}
}
 ETP 
 
C Program to Perform Binary Search using Recursion
================================ EOPN
/* * C Program to Perform Binary Search using Recursion 
================================ EOKW
--------------------------------
output:
If the input array is {1, 2, 3, 4, 5, 6}
and the key to be searched for is 6
then the expected output will be "Search Successful".
--------------------------------

#include <stdio.h>

void binary_search(int [], int, int, int);
void bubble_sort(int [], int);

int main()
{
int key, size, i;
int list[25];

printf("Enter size of a list: ");
scanf("%d", &size);
printf("Enter elements\n");
for(i = 0; i < size; i++)
{
scanf("%d",&list[i]);
}
bubble_sort(list, size);
printf("\n");
printf("Enter key to search\n");
scanf("%d", &key);
binary_search(list, 0, size, key);

}

void bubble_sort(int list[], int size)
{
int temp, i, j;
for (i = 0; i < size; i++)
{
for (j = i; j < size; j++)
{
if (list[i] > list[j])
{
temp = list[i];
list[i] = list[j];
list[j] = temp;
}
}
}
}

void binary_search(int list[], int lo, int hi, int key)
{
int mid;

if (lo > hi)
{
printf("Key not found\n");
return;
}
mid = (lo + hi) / 2;
if (list[mid] == key)
{
printf("Key found\n");
}
else if (list[mid] > key)
{
binary_search(list, lo, mid - 1, key);
}
else if (list[mid] < key)
{
binary_search(list, mid + 1, hi, key);
}
}
 ETP 
 
C Program to Implement Linear Search
================================ EOPN
/* * C program to input N numbers and store them in an array. * Do a linear search for a given key and report success * or failure. 
================================ EOKW
--------------------------------
output:
If the input array is {4, 6, 1, 2, 5, 3}
and if the element searched is 6,
then the expected output will be Position 2.
--------------------------------
#include <stdio.h>

void main()
{  int num;

int i,  keynum, found = 0;

printf("Enter the number of elements ");
scanf("%d", &num);
int array[num];
printf("Enter the elements one by one \n");
for (i = 0; i < num; i++)
{
scanf("%d", &array[i]);
}

printf("Enter the element to be searched ");
scanf("%d", &keynum);
/*  Linear search begins */
for (i = 0; i < num ; i++)
{
if (keynum == array[i] )
{
found = 1;
break;
}
}
if (found == 1)
printf("Element is present in the array at position %d",i+1);
else
printf("Element is not present in the array\n");
}
 ETP 
 
 C Program to Implement Insertion Sort 
================================ EOPN
/* C Program to sort an array in ascending order using Insertion Sort 
================================ EOKW
--------------------------------
output:
If the input array is {4, 6, 1, 2, 5, 3}
the expected output array will have data as {1, 2, 3, 4, 5, 6}
--------------------------------
#include <stdio.h>
int main()
{
int n, i, j, temp;
int arr[64];

printf("Enter number of elements\n");
scanf("%d", &n);

printf("Enter %d integers\n", n);
for (i = 0; i < n; i++)
{
scanf("%d", &arr[i]);
}
for (i = 1 ; i <= n - 1; i++)
{
j = i;
while ( j > 0 && arr[j-1] > arr[j])
{
temp     = arr[j];
arr[j]   = arr[j-1];
arr[j-1] = temp;
j--;
}
}
printf("Sorted list in ascending order:\n");
for (i = 0; i <= n - 1; i++)
{
printf("%d\n", arr[i]);
}
return 0;
}
 ETP 
 
 C Program to Implement Postman Sort Algorithm 
================================ EOPN
/*  * C Program to Implement Postman Sort Algorithm 
================================ EOKW
--------------------------------
output:
$ cc postman.c
$ a.out
/* Average case */
 
Enter size of array :8
Enter elements into array :170
45
90
75
802
24
2
66
 
Sorted Array (Postman sort) :2 24 45 66 75 90 170 802 
 
$ a.out
/* Best case */
Enter size of array :7
Enter elements into array :25
64
185
136
36
3645
45
 
Sorted Array (Postman sort) :25 36 45 64 136 185 3645 
 
$ a.out
/* Worst case */
Enter size of array :8
Enter elements into array :15
214
166
0836
98
6254
73
642
 
Sorted Array (Postman sort) :15 73 98 166 214 642 836 6254
--------------------------------
#include <stdio.h>

void arrange(int,int);
int array[100], array1[100];
int i, j, temp, max, count, maxdigits = 0, c = 0;

void main()
{
int t1, t2, k, t, n = 1;

printf("Enter size of array :");
scanf("%d", &count);
printf("Enter elements into array :");
for (i = 0; i < count; i++)
{
scanf("%d", &array[i]);
array1[i] = array[i];
}
for (i = 0; i < count; i++)
{
t = array[i];        /*first element in t */
while(t > 0)
{
c++;
t = t / 10;        /* Find MSB */
}
if (maxdigits < c)
maxdigits = c;   /* number of digits of a each number */
c = 0;
}
while(--maxdigits)
n = n * 10;

for (i = 0; i < count; i++)
{
max = array[i] / n;        /* MSB - Dividnng by perticular base */
t = i;
for (j = i + 1; j < count;j++)
{
if (max > (array[j] / n))
{
max = array[j] / n;   /* greatest MSB */
t = j;
}
}
temp = array1[t];
array1[t] = array1[i];
array1[i] = temp;
temp = array[t];
array[t] = array[i];
array[i] = temp;
}
while (n >= 1)
{
for (i = 0; i < count;)
{
t1 = array[i] / n;
for (j = i + 1; t1 == (array[j] / n); j++);
arrange(i, j);
i = j;
}
n = n / 10;
}
printf("\nSorted Array (Postman sort) :");
for (i = 0; i < count; i++)
printf("%d ", array1[i]);
printf("\n");
}

/* Function to arrange the of sequence having same base */
void arrange(int k,int n)
{
for (i = k; i < n - 1; i++)
{
for (j = i + 1; j < n; j++)
{
if (array1[i] > array1[j])
{
temp = array1[i];
array1[i] = array1[j];
array1[j] = temp;
temp = (array[i] % 10);
array[i] = (array[j] % 10);
array[j] = temp;
}
}
}
}
 ETP 
 
 C Program to Sort an Integer Array using LSDRadix Sort Algorithm 
================================ EOPN
/*  * C Program to Sort an Integer Array using LSDRadix Sort Algorithm 
================================ EOKW
--------------------------------
output:
$ cc lsdradix.c
$ a.out
/* Average Case */
Enter size of array :7
Enter elements into array :170    
45 
90
75
802
24
2
Sorted Array (ladradix sort) : 2 24 45 75 90 170 802 
 
$ a.out
/*Best case */
Enter size of array :7    
Enter elements into array :22
64
121
78
159
206
348
Sorted Array (ladradix sort) : 22 64 78 159 121 206 348
 
$ a.out
/* Worst case */
Enter size of array :7
Enter elements into array :985
27
64
129
345
325
091
Sorted Array (ladradix sort) : 27 64 91 129 325 345 985
--------------------------------
#include <stdio.h>

int min = 0, count = 0, array[100] = {0}, array1[100] = {0};

void main()
{
int k, i, j, temp, t, n;

printf("Enter size of array :");
scanf("%d", &count);
printf("Enter elements into array :");
for (i = 0; i < count; i++)
{
scanf("%d", &array[i]);
array1[i] = array[i];
}
for (k = 0; k < 3; k++)
{
for (i = 0; i < count; i++)
{
min = array[i] % 10;        /* To find minimum lsd */
t = i;
for (j = i + 1; j < count; j++)
{
if (min > (array[j] % 10))
{
min = array[j] % 10;
t = j;
}
}
temp = array1[t];
array1[t] = array1[i];
array1[i] = temp;
temp = array[t];
array[t] = array[i];
array[i] = temp;

}
for (j = 0; j < count; j++)        /*to find MSB */
array[j] = array[j] / 10;
}
printf("Sorted Array (lSdradix sort) : ");
for (i = 0; i < count; i++)
printf("%d ", array1[i]);
}
 ETP 
 
 C Program to Sort an Array based on Heap Sort Algorithm 
================================ EOPN
/* * C Program to sort an array based on heap sort algorithm(MAX heap) 
================================ EOKW
--------------------------------
output:
$ cc heap.c
$ a.out
Average case 
Enter no of elements :7
 
Enter the nos : 6
5
3
1
8
7
2
Heap array : 8   6       7       1       5       3       2
The sorted array is :      1     2     3     5     6     7     8
Complexity : 
Best case = Avg case = Worst case = O(n logn) 
 
$ a.out
/* Best case 
Enter no of elements :7
 
Enter the nos : 12
10
8
9
7
4
2
Heap array : 12  10      8       9       7       4       2
The sorted array is :      2     4     7     8     9     10     12
Complexity : 
Best case = Avg case = Worst case = O(n logn) 
 
$ a.out
/* Worst case 
Enter no of elements :7
 
Enter the nos : 5
7
12
6
9
10
14
Heap array : 14  9    12      5       6       7       10
The sorted array is :  5     6     7     9     10     12     14
Complexity : 
Best case = Avg case = Worst case = O(n logn) 
*/
--------------------------------
#include <stdio.h>

void main()
{
int heap[10], no, i, j, c, root, temp;

printf("\n Enter no of elements :");
scanf("%d", &no);
printf("\n Enter the nos : ");
for (i = 0; i < no; i++)
scanf("%d", &heap[i]);
for (i = 1; i < no; i++)
{
c = i;
do
{
root = (c - 1) / 2;
if (heap[root] < heap[c])   /* to create MAX heap array */
{
temp = heap[root];
heap[root] = heap[c];
heap[c] = temp;
}
c = root;
} while (c != 0);
}

printf("Heap array : ");
for (i = 0; i < no; i++)
printf("%d\t ", heap[i]);
for (j = no - 1; j >= 0; j--)
{
temp = heap[0];
heap[0] = heap[j    /* swap max element with rightmost leaf element */
heap[j] = temp;
root = 0;
do
{
c = 2 * root + 1;    /* left node of root element */
if ((heap[c] < heap[c + 1]) && c < j-1)
c++;
if (heap[root]<heap[c] && c<j)    /* again rearrange to max heap array */
{
temp = heap[root];
heap[root] = heap[c];
heap[c] = temp;
}
root = c;
} while (c < j);
}
printf("\n The sorted array is : ");
for (i = 0; i < no; i++)
printf("\t %d", heap[i]);
printf("\n Complexity : \n Best case = Avg case = Worst case = O(n logn) \n");
}
 ETP 
 
 C Program to Sort the Array Elements using Gnome Sort 
================================ EOPN
/* * C Program to Sort the Array Elements using Gnome Sort 
================================ EOKW
--------------------------------
output:
$ cc gnomesort.c
$ a.out
enter the elemts number u would like to enter:7
enter the elements to be sorted through gnome sort:
6
0
9
5
2
4
3
0       2       3       4       5       6       9       
 
$ a.out
enter the elemts number u would like to enter:6
enter the elements to be sorted through gnome sort:
1
2
4
5
6
7
1       2       4       5       6       7       
 
$ a.out
enter the elemts number u would like to enter:9
enter the elements to be sorted through gnome sort:
9
8
7
6
5
4
3
3
2
2       3       3       4       5       6       7       8       9
--------------------------------
#include <stdio.h>

void main()
{
int i, temp, ar[10], n;

printf("\nenter the elemts number u would like to enter:");
scanf("%d", &n);
printf("\nenter the elements to be sorted through gnome sort:\n");
for (i = 0; i < n; i++)
scanf("%d", &ar[i]);
i = 0;
while (i < n)
{
if (i == 0 || ar[i - 1] <= ar[i])
i++;
else
{
temp = ar[i-1];
ar[i - 1] = ar[i];
ar[i] = temp;
i = i - 1;
}
}
for (i = 0;i < n;i++)
printf("%d\t", ar[i]);
}
 ETP 
 
 C Program to Implement qsort using Function Pointers 
================================ EOPN
/*  * C Program to Implement qsort using function pointers 
================================ EOKW
--------------------------------
output:
$ cc qsort_fp.c
$ a.out
10    20    30    50    60    
Sorting of Structure elements 
aaa    400
bbb    100
ccc    200
ddd    500
eee    300
--------------------------------
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct s
{
char empname[5];
int empid;
};

/* To sort array elemets */
int int_call(const void *a1,const void *b1)
{
const int *a = (const int *)a1;
const int *b = (const int *)b1;

if (*a > *b)
return 1;
else
{
if (*a == *b)
return 0;
else
return -1;
}
}

/* To sort structure elemets */
int string_call(const void *a1, const void *b1)
{
const char *a = (const char *)a1;
const char *b = (const char *)b1;
return(strcmp(a, b));
}

void main()
{
int array1[5]={20, 30, 50, 60, 10};
struct s emprec[5];
int i, j;

strcpy(emprec[0].empname, "bbb");
emprec[0].empid = 100;
strcpy(emprec[1].empname, "ccc");
emprec[1].empid = 200;
strcpy(emprec[2].empname, "eee");
emprec[2].empid = 300;
strcpy(emprec[3].empname, "aaa");
emprec[3].empid = 400;
strcpy(emprec[4].empname,"ddd");
emprec[4].empid = 500;
qsort(array1, 5, sizeof(int), int_call);
qsort(emprec, 5, sizeof(struct s), string_call);
for (i = 0; i < 5; i++)
printf("%d\t", array1[i]);
printf("\nSorting of Structure elements ");
for (i = 0; i < 5; i++)
printf("\n%s\t%d", emprec[i].empname, emprec[i].empid);
printf("\n");
}
 ETP 
 
 C Program to Implement Pigeonhole Sort 
================================ EOPN
/* *  C Program to Implement Pigeonhole Sort 
================================ EOKW
--------------------------------
output:
 
$cc pigeonholesort.c
 
/* average case */
$ a.out
enter the values into the matrix :7 3 8 2 5 4 9
Sorted order is :
2345789
 
/* best case */
$ a.out
enter the values into the matrix :1 2 3 4 5 6 7
Sorted order is :
1234567
 
/* worst case */
$ a.out
enter the values into the matrix :7 6 5 4 3 2 1
Sorted order is :
1234567
--------------------------------
#include <stdio.h>

#define MAX 7

void pigeonhole_sort(int, int, int *);
void main()
{
int a[MAX], i, min, max;
printf("enter the values into the matrix :");
for (i = 0; i < MAX; i++)
{
scanf("%d", &a[i]);
}
min = a[0];
max = a[0];
for (i = 1; i < MAX; i++)
{
if (a[i] < min)
{
min = a[i];
}
if (a[i] > max)
{
max = a[i];
}
}
pigeonhole_sort(min, max, a);
printf("Sorted order is :\n");
for (i = 0; i < MAX; i++)
{
printf("%d", a[i]);
}
}

/* sorts the array using pigeonhole algorithm */
void pigeonhole_sort(int mi, int ma, int * a)
{

int size, count = 0, i;
int *current;
current = a;
size = ma - mi + 1;
int holes[size];
for (i = 0; i < size; i++)
{
holes[i] = 0;
}
for (i = 0; i < size; i++, current++)
{
holes[*current-mi] += 1;
}
for (count = 0, current = &a[0]; count < size; count++)
{
while (holes[count]--> 0)
{
*current++ = count + mi;
}
}
}
 ETP 
 
 C Program to Implement Cyclesort 
================================ EOPN
/*  * C Program to Implement Cyclesort  
================================ EOKW
--------------------------------
output:
$ cc cyclesort.c
$ a.out
enter the elements into array :7 3 2 5 4 8 9 6
sorted elements are :
23456789
$ a.out
enter the elements into array :7 3 2 4 5 4 6 3
sorted elements are :
23344567
--------------------------------
#include <stdio.h>

#define MAX 8

void cycle_sort(int *);

void main()
{
int a[MAX],i;

printf("enter the elements into array :");
for (i = 0;i < MAX; i++)
{
scanf("%d", &a[i]);
}
cycle_sort(a);
printf("sorted elements are :\n");
for (i = 0;i < MAX; i++)
{
printf("%d", a[i]);
}
}

/* sorts elements using cycle sort algorithm */
void cycle_sort(int * a)
{
int temp, item, pos, i, j, k;

for (i = 0;i < MAX; i++)
{
item = a[i];
pos = i;
do
{
k = 0;
for (j = 0;j < MAX;j++)
{
if (pos != j && a[j] < item)
{
k++;
}
}
if (pos != k)
{
while (pos != k && item == a[k])
{
k++;
}
temp = a[k];
a[k] = item;
item = temp;
pos = k;
}
}while (pos != i);
}
}
 ETP 
 
 C Program to Implement Oddeven Sort 
================================ EOPN
/* * C Program to Implement Oddeven Sort  
================================ EOKW
--------------------------------
output:
$ cc oddevensort.c
/* average case */
$ a.out
enter the elements in to the matrix :7 8 3 2 5 4 9
sorted elements are :
 2 3 4 5 7 8 9
 
/* best case */
$ a.out
enter the elements in to the matrix :1 2 3 4 5 6 7
sorted elements are :
 1 2 3 4 5 6 7
 
/* worst case */
$ a.out
enter the elements in to the matrix :7 6 5 4 3 2 1
sorted elements are :
 1 2 3 4 5 6 7
--------------------------------
#include <stdio.h>
#define MAX 7

void swap(int *,int *);
void oddeven_sort(int *);

void main()
{
int a[MAX], i;

printf("enter the elements in to the matrix :");
for (i = 0;i < MAX;i++)
{
scanf("%d", &a[i]);
}
printf("sorted elements are :\n");
oddeven_sort(a);
for (i = 0;i < MAX;i++)
{
printf(" %d", a[i]);
}
}

/* swaps the elements */
void swap(int * x, int * y)
{
int temp;

temp = *x;
*x = *y;
*y = temp;
}

/* sorts the array using oddeven algorithm */
void oddeven_sort(int * x)
{
int sort = 0, i;

while (!sort)
{
sort = 1;
for (i = 1;i < MAX;i += 2)
{
if (x[i] > x[i+1])
{
swap(&x[i], &x[i+1]);
sort = 0;
}
}
for (i = 0;i < MAX - 1;i += 2)
{
if (x[i] > x[i + 1])
{
swap(&x[i], &x[i + 1]);
sort = 0;
}
}
}
}
 ETP 
 
 C Program to Implement CockTail Sort 
================================ EOPN
/* * C Program to Implement CockTail Sort 
================================ EOKW
--------------------------------
output:
$ gcc cocktailsort.c
$ a.out
/*
 * Average case
 */
Enter the data
9 6 2 12 11 9 3 7
The sorted elements are:2       3       6       7       9       9       11      12  
/*
 * Worst case
 */
 Enter the data
 8 7 6 5 4 3 2 1
 The sorted elements are:1         2        3        4        5        6        7        8
 /*
  *Best case
  */
  Enter the data
  1 2 3 4 5 6 7 8
  The sorted elements are:1     2        3        4        5        6        7        8
--------------------------------
#include <stdio.h>
#define MAX 8

int main()
{
int data[MAX];
int i, j, n, c;

printf("\nEnter the data");
for (i = 0; i < MAX; i++)
{
scanf("%d", &data[i]);
}
n = MAX;
do
{
/*
* Rightward pass will shift the largest element to its correct place at the end
*/
for (i = 0;  i < n - 1; i++)
{
if (data[i] > data[i + 1])
{
data[i] = data[i] + data[i + 1];
data[i + 1] = data[i] - data[i + 1];
data[i] = data[i] - data[i + 1];

}

}
n = n - 1;
/*
* Leftward pass will shift the smallest element to its correct place at the beginning
*/
for (i= MAX - 1, c = 0; i >= c; i--)
{
if(data[i] < data[i - 1])
{
data[i] = data[i] + data[i - 1];
data[i - 1] = data[i] - data[i - 1];
data[i] = data[i] - data[i - 1];
}
}
c = c + 1;

} while (n != 0 && c != 0);
printf("The sorted elements are:");
for (i = 0; i < MAX; i++)
{
printf("%d\t", data[i]);
}
}
 ETP 
 
 C Program to Implement Bitonic sort 
================================ EOPN
/* *  C Program to Implement Bitonic sort 
================================ EOKW
--------------------------------
output:
$ gcc bitonicsort.c
$ a.out
/*
 * Average case
 */
Enter the data
3 5 8 9 7 4 2 1
1  2  3  4  5  7  8  9
$  a.out
/*
 *Worst case
 */
Enter the data
100 99 98 97 96 95 94 93
93  94  95  96  97  98  99  100
 
$  a.out
/*
 *Best case
 */
Enter the data
1111 2222 3333 4444 5555 6666 7777 8888
1111  2222  3333  4444  5555  6666  7777  8888
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#define MAX 8
#define SWAP(x,y) t = x; x = y; y = t;

void compare();
void bitonicmerge(int, int, int);
void recbitonic(int, int, int);
void sort();

int data[MAX];
int up = 1;
int down = 0;

int main()
{
int i;

printf("\nEnter the data");
for (i = 0;i < MAX ;i++)
{
scanf("%d", &data[i]);
}
sort();
for (i = 0;i < MAX;i++)
{
printf("%d ", data[i]);
}
}
/*
* compare and swap based on dir
*/
void compare(int i, int j, int dir)
{
int t;

if (dir == (data[i] > data[j]))
{
SWAP(data[i], data[j]);
}
}
/*
* Sorts a bitonic sequence in ascending order if dir=1
* otherwise in descending order
*/
void bitonicmerge(int low, int c, int dir)
{
int k, i;

if (c > 1)
{
k = c / 2;
for (i = low;i < low+k ;i++)
compare(i, i+k, dir);
bitonicmerge(low, k, dir);
bitonicmerge(low+k, k, dir);
}
}
/*
* Generates bitonic sequence by sorting recursively
* two halves of the array in opposite sorting orders
* bitonicmerge will merge the resultant data
*/
void recbitonic(int low, int c, int dir)
{
int k;

if (c > 1)
{
k = c / 2;
recbitonic(low, k, up);
recbitonic(low + k, k, down);
bitonicmerge(low, c, dir);
}
}

/*
* Sorts the entire array
*/
void sort()
{
recbitonic(0, MAX, up);
}
 ETP 
 
 C Program to Perform Comb Sort on Array of Integers
================================ EOPN
/* * C Program to Perform Comb Sort on Array of Integers 
================================ EOKW
--------------------------------
output:
$ cc combsort.c
$ a.out
Please insert the number of elements to be sorted: 10
Input element 0 :5
Input element 1 :6
Input element 2 :1
Input element 3 :3
Input element 4 :4
Input element 5 :7
Input element 6 :8
Input element 7 :9
Input element 8 :0
Input element 9 :6
unsorted list5613478906Sorted list:
0 1 3 4 5 6 6 7 8 9 
$ ./a.out
Please insert the number of elements to be sorted: 10
Input element 0 :1
Input element 1 :2
Input element 2 :3
Input element 3 :4
Input element 4 :5
Input element 5 :6
Input element 6 :7
Input element 7 :8
Input element 8 :9
Input element 9 :10
unsorted list12345678910Sorted list:
1 2 3 4 5 6 7 8 9 10 
$ ./a.out
Please insert the number of elements to be sorted: 10
Input element 0 :10
Input element 1 :9
Input element 2 :8
Input element 3 :7
Input element 4 :6
Input element 5 :5
Input element 6 :4
Input element 7 :3
Input element 8 :2
Input element 9 :1
unsorted list10987654321Sorted list:
1 2 3 4 5 6 7 8 9 10
--------------------------------
#include <stdio.h>
#include <stdlib.h>

/*Function to find the new gap between the elements*/
int newgap(int gap)
{
gap = (gap * 10) / 13;
if (gap == 9 || gap == 10)
gap = 11;
if (gap < 1)
gap = 1;
return gap;
}

/*Function to implement the combsort*/
void combsort(int a[], int aSize)
{
int gap = aSize;
int temp, i;
for (;;)
{
gap = newgap(gap);
int swapped = 0;
for (i = 0; i < aSize - gap; i++)
{
int j = i + gap;
if (a[i] > a[j])
{
temp = a[i];
a[i] = a[j];
a[j] = temp;
swapped  =  1;
}
}
if (gap  ==  1 && !swapped)
break;
}
}
int main ()
{
int n, i;
int *a;
printf("Please insert the number of elements to be sorted: ");
scanf("%d", &n);       // The total number of elements
a  =  (int *)calloc(n, sizeof(int));
for (i = 0;i< n;i++)
{
printf("Input element %d :", i);
scanf("%d", &a[i]); // Adding the elements to the array
}
printf("unsorted list");       // Displaying the unsorted array
for(i = 0;i < n;i++)
{
printf("%d", a[i]);
}
combsort(a, n);
printf("Sorted list:\n");        // Display the sorted array
for(i = 0;i < n;i++)
{
printf("%d ", (a[i]));
}
return 0;
}
 ETP 
 
 C Program to Implement Stooge Sort 
================================ EOPN
/* * C Program to Implement Stooge Sort 
================================ EOKW
--------------------------------
output:
$ gcc stoogesort.c
$ a.out
Enter the values you want to sort using STOOGE SORT!!!:
6
1
5
3
8
7
2
sorted by stooge sort
1 2 3 5 6 7 8
$ a.out
Enter the values you want to sort using STOOGE SORT!!!:
7
6
5
4
3
2
1
sorted by stooge sort
1 2 3 4 5 6 7
$ a.out
Enter the values you want to sort using STOOGE SORT!!!:
1
2
3
4
5
6
7
sorted by stooge sort
1 2 3 4 5 6 7
--------------------------------
#include <stdio.h>

// Function Prototype
void stoogesort(int [], int, int);

void main()
{
int b[7], i;

printf("Enter the values you want to sort using STOOGE SORT!!!:\n");
for (i = 0;i < 7;i++)
scanf(" %d", &b[i]);
stoogesort(b, 0, 6);
printf("sorted by stooge sort \n");
for (i = 0;i < 7;i++)
{
printf("%d ", b[i]);
}
printf("\n");
}

// Function to implement STOOGE SORT
void stoogesort(int a[], int i, int j)
{
int temp, k;

if (a[i] > a[j])
{
temp = a[i];
a[i] = a[j];
a[j] = temp;
}
if ((i + 1) >= j)
return;
k = (int)((j - i + 1) / 3);
stoogesort(a, i, j - k);
stoogesort(a, i + k, j);
stoogesort(a, i, j - k);
}
 ETP 
 
 C Program to Implement Pancake Sort on Array of Integers 
================================ EOPN
/* * C Program to Implement Pancake Sort on Array of Integers 
================================ EOKW
--------------------------------
output:
$ cc pancake.c
$ a.out
enter the 9 elements of array:
10
9
8
7
6
5
4
3
2
 
Original: 10 9 8 7 6 5 4 3 2
Sorted: 2 3 4 5 6 7 8 9 10   - with a total of 0 moves
$ a.out
enter the 9 elements of array:
1
2
3
4
5
6
7
8
9
 
Original: 1 2 3 4 5 6 7 8 9
Sorted: 1 2 3 4 5 6 7 8 9   - with a total of 0 moves
$ a.out
enter the 9 elements of array:
5
6
7
8
9
1
4
2
3
Original: 5 6 7 8 9 1 4 2 3
Sorted: 1 2 3 4 5 6 7 8 9   - with a total of 3 moves
--------------------------------
#include <stdio.h>
#include <stdlib.h>

void do_flip(int *, int, int);

/*Function to implement the pancake sort*/
int pancake_sort(int *list, unsigned int length)
{
if (length < 2)
return 0;
int i, a, max_num_pos, moves;

moves = 0;
for (i = length;i > 1;i--)
{
max_num_pos = 0;
for (a = 0;a < i;a++)
{
if (list[a] > list[max_num_pos])
max_num_pos = a;
}
if (max_num_pos ==  i - 1)
continue;
if (max_num_pos)
{
moves++;
do_flip(list, length, max_num_pos + 1);
}
do_flip(list, length, i);
}
return moves;
}

/*Function to do flips in the elements*/
void do_flip(int *list,  int length,  int num)
{
int swap;
int i = 0;
for (i;i < --num;i++)
{
swap = list[i];
list[i] = list[num];
list[num] = swap;
}
}

/*Function to print the array*/
void print_array(int list[], int length)
{
int i;
for (i = 0;i < length;i++)
{
printf("%d ", list[i]);
}
}

int main(int argc,  char **argv)
{
int list[9];
int i;
printf("enter the 9 elements of array:\n");
for (i = 0;i < 9;i++)
scanf("%d", &list[i]);
printf("\nOriginal: ");
print_array(list, 9);
int moves  =  pancake_sort(list, 9);
printf("\nSorted: ");
print_array(list, 9);
printf(" - with a total of %d moves\n",  moves);
}
 ETP 
 
 C Program to Implement BogoSort in an Integer Array 
================================ EOPN
/* * C Program to Implement BogoSort in an Integer Array 
================================ EOKW
--------------------------------
output:
$ cc bogo_sort.c
Average case:
$ a.out
Enter the elements of array:56
34
96
26
08
87
36
The array after sorting is:8
26
34
36
56
87
96
 
Best case:
$ a.out
Enter the elements of array:12
23
34
45
56
67
78
The array after sorting is:12
23
34
45
56
67
78
 
Worst case:
$ a.out
Enter the elements of array:984
38
983
389
37
596
483
The array after sorting is:37
38
389
483
596
983
984
--------------------------------
#include <stdio.h>
#include <stdlib.h>

#define size 7
/* Function Prototypes */

int is_sorted(int *, int);
void shuffle(int *, int);
void bogosort(int *, int);

int main()
{
int numbers[size];
int i;

printf("Enter the elements of array:");
for (i = 0; i < size;i++)
{
scanf("%d", &numbers[i]);
}
bogosort(numbers, size);
printf("The array after sorting is:");
for (i = 0;i < size;i++)
{
printf("%d\n", numbers[i]);
}
printf("\n");
}

/* Code to check if the array is sorted or not */
int is_sorted(int *a, int n)
{
while (--n >= 1)
{
if (a[n] < a[n - 1])
{
return 0;
}
}
return 1;
}

/* Code to shuffle the array elements */
void shuffle(int *a, int n)
{
int i, t, temp;
for (i = 0;i < n;i++)
{
t = a[i];
temp = rand() % n;    /* Shuffles the given array using Random function */
a[i] = a[temp];
a[temp] = t;
}
}

/* Code to check if the array is sorted or not and if not sorted calls the shuffle function to shuffle the array elements */
void bogosort(int *a, int n)
{
while (!is_sorted(a, n))
{
shuffle(a, n);
}
}
 ETP 
 
 C Program to Perform Shell Sort without using Recursion
================================ EOPN
/* * C Program to Perform Shell Sort without using Recursion 
================================ EOKW
--------------------------------
output:
$ cc shellsort.c
Average case:
$ a.out
Enter the elements to be sorted:57
67
48
93
42
84
95
The array after sorting is:
42
48
57
67
84
93
95
 
Best case:
$ a.out
Enter the elements of array:22
33
74
85
86
87
98
The array after sorting is:22
33
74
85
86
87
98
 
Worst case:
$ a.out
Enter the elements of array:94
92
91
89
85
80
43
The array after sorting is:43
80
85
89
91
92
94
--------------------------------
#include  <stdio.h>
#define size 7

/* Function Prototype */
int shell_sort(int []);

void main()
{
int arr[size], i;
printf("Enter the elements to be sorted:");
for (i = 0;i < size;i++)
{
scanf("%d", &arr[i]);
}
shell_sort(arr);
printf("The array after sorting is:");
for (i = 0;i < size;i++)
{
printf("\n%d", arr[i]);
}
}

/* Code to sort array using shell sort */
int shell_sort(int array[])
{
int i = 0, j = 0, k = 0, mid = 0;
for (k = size / 2;k > 0;k /= 2)
{
for (j = k;j < size;j++)
{
for (i = j - k;i >= 0;i -= k)
{
if (array[i + k] >= array[i])
{
break;
}
else
{
mid = array[i];
array[i] = array[i + k];
array[i + k] = mid;
}
}
}
}
return 0;
}
 ETP 
 
C Program for Depth First Binary Tree Search using Recursion
================================ EOPN
/* * C Program for Depth First Binary Tree Search using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm34.c
$ a.out
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 5
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 4
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 7
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 8
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 6
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 2
2  4  3  6  8  7  5  
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
void DFS(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Perform DFS Traversal\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
DFS(head);
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default:
printf("Not a valid input, try again\n");
}
} while (choice != 3);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

void DFS(struct node *head)
{
if (head)
{
if (head->left)
{
DFS(head->left);
}
if (head->right)
{
DFS(head->right);
}
printf("%d  ", head->a);
}
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Traverse the Tree Recursively
================================ EOPN
/* * C Program to Traverse the Tree Recursively 
================================ EOKW
--------------------------------
output:
$ pgm36.c
$ a.out
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 5
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 4
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 6
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 2
2   3   4   5   6   
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 3
5   3   2   4   6   
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 4
2   4   3   6   5   
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 5
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
void infix(struct node *);
void postfix(struct node *);
void prefix(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Traverse via infix\n3.Traverse via prefix\n4. Traverse via postfix\n5. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
infix(head);
break;
case 3:
prefix(head);
break;
case 4:
postfix(head);
break;
case 5:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default: printf("Not a valid input, try again\n");
}
} while (choice != 5);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

void infix(struct node *head)
{
if (head)
{
infix(head->left);
printf("%d   ", head->a);
infix(head->right);
}
}

void prefix(struct node *head)
{
if (head)
{
printf("%d   ", head->a);
prefix(head->left);
prefix(head->right);
}
}

void postfix(struct node *head)
{
if (head)
{
postfix(head->left);
postfix(head->right);
printf("%d   ", head->a);
}
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Search an Element in a Tree Recursively
================================ EOPN
/* * C Program to search an element in a Binary Search Tree 
================================ EOKW
--------------------------------
output:
If the input tree is              
                    25
                  /    \  
                 17     35   
                / \     / \ 
              13  19   27 55 
and the key to be searched for is 15,
then the output will be : Key not found.
--------------------------------
#include <stdio.h>
#include <stdlib.h>
struct node
{
int info;
struct node *left, *right;
};
struct node *createnode(int key)
{
struct node *newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;
return(newnode);
}
int search(struct node *head, int key)
{
while (head != NULL)
{
if (key > head->info)
{
return search(head->right, key);
}
else if (key < head->info)
{
return search(head->left, key);
}
else
{
return 1;
}
}
return 0;
}
/*
* Main Function
*/
int main()
{
int flag = 0;
/* Creating first Tree. */
struct node *newnode = createnode(25);
newnode->left = createnode(17);
newnode->right = createnode(35);
newnode->left->left = createnode(13);
newnode->left->right = createnode(19);
newnode->right->left = createnode(27);
newnode->right->right = createnode(55);
/* Sample Tree 1:
*               25
*             /    \
*            17     35
*           / \     / \
*         13  19   27 55
*/
flag = search(newnode,15);
if (flag)
{
printf("Key %d found in tree 1 \n", 15);
}
else
{
printf("Key %d not found in tree 1\n", 15);
}

/* Creating second Tree. */
struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);
/* Sample Tree 2:   Right Skewed Tree (Unbalanced).
*               1
*                \
*                 2
*                  \
*                   3
*                    \
*                     4
*                      \
*                       5
*/
flag = search(node,4);
if (flag)
{
printf("Key %d found in tree 2\n", 4);
}
else
{
printf("Key %d not found in tree 2\n", 4);
}

/* Creating third Tree. */
struct node *root = createnode(15);
/* Sample Tree 3- Tree having just one root node.
*              15
*/
flag = search(root,15);
if (flag)
{
printf("Key %d found in tree 3 \n", 15);
}
else
{
printf("Key %d not found in tree 3\n", 15);
}
return 0;
}
 ETP 
 
C Program to Search an Element in a Tree Non-Recursively
================================ EOPN
/* * C Program to Traverse the Tree Non-Recursively 
================================ EOKW
--------------------------------
output:
$ cc pgm37.c
$ a.out
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 1
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 
4
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 1
Key found in tree
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 6
Key not found
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
printf("Enter key to search: ");
scanf("%d", &key);
flag = search(head, key);
if (flag)
{
printf("Key found in tree\n");
}
else
{
printf("Key not found\n");
}
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default: printf("Not a valid input, try again\n");
}
} while (choice != 3);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

int search(struct node *head, int key)
{
while (head != NULL)
{
if (key > head->a)
{
head = head->right;
}
else if (key < head->a)
{
head = head->left;
}
else
{
return 1;
}
}
return 0;
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Traverse the Tree Non-Recursively
================================ EOPN
/* * C Program to Traverse the Tree Non-Recursively 
================================ EOKW
--------------------------------
output:
$ cc pgm37.c
$ a.out
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 1
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 
4
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 1
Key found in tree
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 6
Key not found
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
printf("Enter key to search: ");
scanf("%d", &key);
flag = search(head, key);
if (flag)
{
printf("Key found in tree\n");
}
else
{
printf("Key not found\n");
}
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default: printf("Not a valid input, try again\n");
}
} while (choice != 3);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

int search(struct node *head, int key)
{
while (head != NULL)
{
if (key > head->a)
{
head = head->right;
}
else if (key < head->a)
{
head = head->left;
}
else
{
return 1;
}
}
return 0;
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
/* * C Program for Depth First Binary Tree Search without using  * Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm33.c
$ a.out
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 5
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 4
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 1
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 7
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 6
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 8
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 2
On DFS traversal we get:
1  2  4  3  6  8  7  5  
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
int visited;
};

void generate(struct node **, int);
void DFS(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Perform DFS Traversal\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
DFS(head);
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default:
printf("Not a valid input, try again\n");
}
} while (choice != 3);

return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->visited = 0;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
temp->visited = 0;
if (temp->a >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

void DFS(struct node *head)
{
struct node *temp = head, *prev;

printf("On DFS traversal we get:\n");
while (temp && !temp->visited)
{
if (temp->left && !temp->left->visited)
{
temp = temp->left;
}
else if (temp->right && !temp->right->visited)
{
temp = temp->right;
}
else
{
printf("%d  ", temp->a);
temp->visited = 1;
temp = head;
}
}
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Find Nth Node in the Inorder Traversal of a Tree 
================================ EOPN
/* * C Program to Find Nth Node in the Inorder Traversal of a Tree 
================================ EOKW
--------------------------------
output:
$ cc pgm63.c
$ a.out
 
[1416572]
--------------------------------

typedef struct node
{
int value;
struct node *left;
struct node *right;
}newnode;

newnode *root;
static ctr;

void nthnode(newnode *root, int n, newnode **nthnode);
int main()
{
newnode *temp;
root=0;

// Construct the tree
add(19);
add(20);
add(11);
inorder(root);
// Get the pointer to the nth Inorder node
nthinorder(root, 6, &temp);
printf("\n[%d]\n", temp->value);
return(0);
}

// Get the pointer to the nth inorder node in "nthnode"
void nthinorder(newnode *root, int n, newnode **nthnode)
{
static whichnode;
static found;

if (!found)
{
if (root)
{
nthinorder(root->left, n , nthnode);
if (++whichnode == n)
{
printf("\n Found %dth node\n", n);
found = 1;
*nthnode = root;
}
nthinorder(root->right, n , nthnode);
}
}
}

inorder(newnode *root)
{
}
// Add value to a Binary Search Tree
add(int value)
{
newnode *temp, *prev, *cur;

temp = malloc(sizeof(newnode));
temp->value = value;
temp->left  = 0;
temp->right = 0;
if (root == 0)
{
root = temp;
}
else
{
prev = 0;
cur = root;
while(cur)
{
prev = cur;
cur =(value < cur->value)? cur->left : cur->right;
}
if (value > prev->value)
prev->right = temp;
else
prev->left  = temp;
}
}
 ETP 
 
 C Program to Find the Largest value in a Tree using Inorder Traversal 
================================ EOPN
/* * C Program for finding the largest node * in a Binary Search Tree using  Inorder Traversal  
================================ EOKW
--------------------------------
output:
                    25
                  /    \  
                 17     35   
                / \     / \ 
              13  19   27 55
--------------------------------
#include <stdio.h>
#include <stdlib.h>
struct node
{
int info;
struct node *left, *right;
};
struct node *createnode(int key)
{
struct node *newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;
return(newnode);
}
void inorder(struct node *root)
{
if(root != NULL)
{
inorder(root->left);
printf(" %d ",root->info);
inorder(root->right);
}
}
void largest(struct node *root)
{
while (root != NULL && root->right != NULL)
{
root = root->right;
}
printf("\nLargest value is %d\n", root->info);
}
/*
* Main Function
*/
int main()
{
/* Creating first Tree. */
struct node *newnode = createnode(25);
newnode->left = createnode(17);
newnode->right = createnode(35);
newnode->left->left = createnode(13);
newnode->left->right = createnode(19);
newnode->right->left = createnode(27);
newnode->right->right = createnode(55);
/* Sample Tree 1:
*               25
*             /    \
*            17     35
*           / \     / \
*         13  19   27 55
*/
printf("Inorder traversal of tree 1 :");
inorder(newnode);
largest(newnode);

/* Creating second Tree. */
struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);
/* Sample Tree 2:   Right Skewed Tree (Unbalanced).
*               1
*                \
*                 2
*                  \
*                   3
*                    \
*                     4
*                      \
*                       5
*/
printf("\nInorder traversal of tree 2 :");
inorder(node);
largest(node);

/* Creating third Tree. */
struct node *root = createnode(15);
/* Sample Tree 3- Tree having just one root node.
*              15
*/
printf("\nInorder traversal of tree 3 :");
inorder(root);
largest(root);
return 0;
}
 ETP 
 
 C Program to Implement Depth First Search Traversal using Post Order 
================================ EOPN
/* * C Program to Implement Depth First Search Traversal using Post Order       50      /  \    20   30   /  \      70  80 /  \    \10  40   60    (50, 20, 30, 70, 80, 10, 40, 60) 
================================ EOKW
--------------------------------
output:
        50
       /  \
     20    30
     / \    
   70    80
  /  \     \
 10  40    60
$ cc tree29.c
$ a.out
->10->70->40->20->80->60->50->30
Depth first traversal
->10->40->70->60->80->20->30->50
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode {
int value;
struct btnode *l;
struct btnode *r;
};

typedef struct btnode bt;
bt *root;
bt *new, *list;
bt *create_node();
void display(bt *);
void construct_tree();
void dfs(bt *);

void main()
{
construct_tree();
display(root);
printf("\n");
printf("Depth first traversal\n ");
dfs(root);
}

/* Creates an empty node */
bt * create_node()
{
new=(bt *)malloc(sizeof(bt));
new->l = NULL;
new->r = NULL;
}

/* Constructs a tree */
void construct_tree()
{
root = create_node();
root->value = 50;
root->l = create_node();
root->l->value = 20;
root->r = create_node();
root->r->value = 30;
root->l->l = create_node();
root->l->l->value = 70;
root->l->r = create_node();
root->l->r->value = 80;
root->l->r->r = create_node();
root->l->r->r->value = 60;
root->l->l->l = create_node();
root->l->l->l->value = 10;
root->l->l->r = create_node();
root->l->l->r->value = 40;
}

/* Display the elements in a tree using inorder */
void display(bt * list)
{
if (list == NULL)
{
return;
}
display(list->l);
printf("->%d", list->value);
display(list->r);
}

/* Dfs traversal using post order */
void dfs(bt * list)
{
if (list == NULL)
{
return;
}
dfs(list->l);
dfs(list->r);
printf("->%d ", list->value);
}
 ETP 
 
 C Program to Find the Largest value in a Tree using Inorder Traversal 
================================ EOPN
/* * C Program for finding the largest node * in a Binary Search Tree using  Inorder Traversal  
================================ EOKW
--------------------------------
output:
                    25
                  /    \  
                 17     35   
                / \     / \ 
              13  19   27 55
--------------------------------
#include <stdio.h>
#include <stdlib.h>
struct node
{
int info;
struct node *left, *right;
};
struct node *createnode(int key)
{
struct node *newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;
return(newnode);
}
void inorder(struct node *root)
{
if(root != NULL)
{
inorder(root->left);
printf(" %d ",root->info);
inorder(root->right);
}
}
void largest(struct node *root)
{
while (root != NULL && root->right != NULL)
{
root = root->right;
}
printf("\nLargest value is %d\n", root->info);
}
/*
* Main Function
*/
int main()
{
/* Creating first Tree. */
struct node *newnode = createnode(25);
newnode->left = createnode(17);
newnode->right = createnode(35);
newnode->left->left = createnode(13);
newnode->left->right = createnode(19);
newnode->right->left = createnode(27);
newnode->right->right = createnode(55);
/* Sample Tree 1:
*               25
*             /    \
*            17     35
*           / \     / \
*         13  19   27 55
*/
printf("Inorder traversal of tree 1 :");
inorder(newnode);
largest(newnode);

/* Creating second Tree. */
struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);
/* Sample Tree 2:   Right Skewed Tree (Unbalanced).
*               1
*                \
*                 2
*                  \
*                   3
*                    \
*                     4
*                      \
*                       5
*/
printf("\nInorder traversal of tree 2 :");
inorder(node);
largest(node);

/* Creating third Tree. */
struct node *root = createnode(15);
/* Sample Tree 3- Tree having just one root node.
*              15
*/
printf("\nInorder traversal of tree 3 :");
inorder(root);
largest(root);
return 0;
}
 ETP 
 
 C Program to Create a Mirror Copy of a Tree and Display using BFS Traversal 
================================ EOPN
/*  * C Program to Create a Mirror Copy of a Tree and Display using  * BFS Traversal *                    40 *                    /\ *                   20 60 *                   /\  \ *                  10 30  80 *                          \ *                           90 
================================ EOKW
--------------------------------
output:
$ cc tree16.c
$ a.out
Enter the elements of the tree(enter 0 to exit)
40
20
10
30
60
70
80
0
mirror image of tree is
40 -> 60 -> 20 -> 70 -> 30 -> 10 -> 80
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *left, *right;
};
typedef struct btnode node;

/* function prototypes */
void insert(node *, node *);
void mirror(node *);

/* global variables */
node *root = NULL;
int val, front = 0, rear = -1, i;
int queue[20];

void main()
{
node *new = NULL ;
int num = 1;
printf("Enter the elements of the tree(enter 0 to exit)\n");
while (1)
{
scanf("%d",  &num);
if (num == 0)
break;
new = malloc(sizeof(node));
new->left = new->right = NULL;
new->value = num;
if (root == NULL)
root = new;
else
{
insert(new, root);
}
}
printf("mirror image of tree is\n");
queue[++rear] = root->value;
mirror(root);
for (i = 0;i <= rear;i++)
printf("%d -> ", queue[i]);
printf("%d\n", root->right->right->right->value);
}

/* inserting nodes into the tree */
void insert(node * new , node *root)
{
if (new->value > root->value)
{
if (root->right == NULL)
root->right = new;
else
insert (new, root->right);
}
if (new->value < root->value)
{
if (root->left == NULL)
root->left = new;
else
insert (new, root->left);
}
}

/* mirror image of nodes */
void mirror(node *root)
{
val = root->value;
if ((front <= rear) && (root->value == queue[front]))
{
if (root->right != NULL || root->right == NULL)
queue[++rear] = root->right->value;
if (root->left != NULL)
queue[++rear] = root->left->value;
front++;
}
if (root->right != NULL)
{
mirror(root->right);
}
if (root->left != NULL)
{
mirror(root->left);
}
}
 ETP 
 
 C  Program to Build Binary Tree if Inorder or Postorder Traversal as Input 
================================ EOPN
/* * C  Program to Build Binary Tree if Inorder or Postorder Traversal as Input * *                     40 *                    /  \ *                   20   60 *                  /  \   \ *                 10  30   80 *                           \ *                           90     *             (Given Binary Search Tree)     
================================ EOKW
--------------------------------
output:
$ cc trees.c
$ a.out
 
1- Inorder
2 - postorder
Enter choice : 1
Given inorder traversal as input
10->20->30->40->60->80->90
preorder traversal of tree
40->10->20->30->60->80->90
inorder traversal of tree
10->20->30->40->60->80->90
postorder traversal of tree
10->20->30->60->80->90->40
 
$ a.out
1 - Inorder
2 - postorder
Enter choice : 2
Given post order traversal array
10->30->20->90->80->60->40
preorder traversal of tree
40->10->20->30->60->80->90
Inorder traversal of tree
10->20->30->40->60->80->90
postorder traversal of tree
10->20->30->60->80->90->40
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
}*root = NULL, *temp = NULL;

typedef struct btnode N;
void insert();
N* bt(int arr[],int,int);
N* new(int);
void inorder(N *t);
void create();
void search(N *t);
void preorder(N *t);
void postorder(N *t);

void main()
{
int ch, i, n;
int arr[] = {10, 20, 30, 40, 60, 80, 90};
n = sizeof(arr) / sizeof(arr[0]);

printf("\n1- Inorder\n");
printf("2 - postorder\n");
printf("\nEnter choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
root = bt(arr, 0, n-1);
printf("Given inorder traversal as input\n");
for (i = 0;i< = 6;i++)
printf("%d->", arr[i]);
printf("\npreorder traversal of tree\n");
preorder(root);
printf("\ninorder traversal of tree\n");
inorder(root);
printf("\npostorder traversal of tree\n");
postorder(root);
break;
case 2:
insert();
printf("\npreorder traversal of tree\n");
preorder(root);
printf("\nInorder traversal of tree\n");
inorder(root);
printf("\npostorder traversal of tree\n");
postorder(root);
break;
default:printf("enter correct choice");
}
}

/* To create a new node */
N* new(int val)
{
N* node = (N*)malloc(sizeof(N));

node->value = val;
node->l = NULL;
node->r  =  NULL;
return node;
}

/* To create a balanced binary search tree */
N* bt(int arr[], int first, int last)
{
int mid;

N* root = (N*)malloc(sizeof(N));
if (first > last)
return NULL;
mid = (first + last) / 2;
root = new(arr[mid]);
root->l = bt(arr, first, mid - 1);
root->r = bt(arr, mid + 1, last);
return root;
}

/* Insert a node in the tree */
void insert()
{
int arr1[] = {10, 30, 20, 90, 80, 60, 40}, i;

printf("Given post order traversal array\n");
for (i = 0;i <= 6;i++)
{
printf("%d->", arr1[i]);
}
for (i = 6;i >= 0;i--)
{
create(arr1[i]);
if (root =  = NULL)
root = temp;
else
search(root);
}
}

/*Create a node */
void create(int data)
{
temp = (N *)malloc(1*sizeof(N));

temp->value = data;
temp->l = temp->r = NULL;
}

/* Search for the appropriate position to insert the new node */
void search(N *t)
{
if ((temp->value>t->value)&&(t->r != NULL))
search(t->r);
else if ((temp->value>t->value)&&(t->r  == NULL))
t->r = temp;
else if ((temp->value<t->value)&&(t->l != NULL))
search(t->l);
else if ((temp->value<t->value)&&(t->l == NULL))
t->l = temp;
}

/* to display inorder of tree */
void inorder(N *t)
{
if (t->l != NULL)
inorder(t->l);
printf("%d->", t->value);
if (t->r != NULL)
inorder(t->r);
}

/* to display preorder traversal of tree */
void preorder(N *t)
{
printf("%d->", t->value);
if (t->l != NULL)
inorder(t->l);
if (t->r != NULL)
inorder(t->r);
}

/* to display postorder traversal of tree */
void postorder(N *t)
{
if (t->l != NULL)
inorder(t->l);
if (t->r != NULL)
inorder(t->r);
printf("%d->", t->value);
}
 ETP 
 
C Program to Implement Binary Tree using Linked List 
================================ EOPN
/* * C Program to Implement Binary Tree using Linked List 
================================ EOKW
--------------------------------
output:
$ cc pgm64.c
$ a.out
In-order Traversal:
D    B    H    E    A    F    C    G
--------------------------------
#include <stdio.h>
#include <malloc.h>

struct node {
struct node * left;
char data;
struct node * right;
};

struct node *constructTree( int );
void inorder(struct node *);

char array[ ] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', '\0', '\0', 'H' };
int leftcount[ ] = {  1,   3,   5,   -1,   9,  -1,  -1,   -1,   -1,  -1 };
int rightcount[ ] = {  2,   4,   6,   -1,  -1,  -1,  -1,   -1,   -1,  -1 };

void main() {
struct node *root;
root = constructTree( 0 );
printf("In-order Traversal: \n");
inorder(root);
}

struct node * constructTree( int index ) {
struct node *temp = NULL;
if (index != -1) {
temp = (struct node *)malloc( sizeof ( struct node ) );
temp->left = constructTree( leftcount[index] );
temp->data = array[index];
temp->right = constructTree( rightcount[index] );
}
return temp;
}

void inorder( struct node *root ) {
if (root != NULL) {
inorder(root->left);
printf("%c\t", root->data);
inorder(root->right);
}
}
 ETP 
 
C Program to Implement a Heap & provide Insertion & Deletion Operation 
================================ EOPN
/* * C Program to Implement a Heap & provide Insertion & Deletion Operation  
================================ EOKW
--------------------------------
output:
$ cc pgm66.c
$ a.out
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 1
Enter the element to be inserted to the list : 30
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 1
Enter the element to be inserted to the list : 50
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 1
Enter the element to be inserted to the list : 70
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 2
Enter the elements to be deleted from the list: 10
10 not found in heap list
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 2
Enter the elements to be deleted from the list: 50
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 1
Enter the element to be inserted to the list : 100
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 3
100 30 70
1.Insert the element
2.Delete the element
3.Display all elements
4.Quit
Enter your choice : 4
--------------------------------
#include <stdio.h>

int array[100], n;
main()
{
int choice, num;
n = 0;/*Represents number of nodes in the heap*/
while(1)
{
printf("1.Insert the element \n");
printf("2.Delete the element \n");
printf("3.Display all elements \n");
printf("4.Quit \n");
printf("Enter your choice : ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter the element to be inserted to the list : ");
scanf("%d", &num);
insert(num, n);
n = n + 1;
break;
case 2:
printf("Enter the elements to be deleted from the list: ");
scanf("%d", &num);
delete(num);
break;
case 3:
display();
break;
case 4:
exit(0);
default:
printf("Invalid choice \n");
}/*End  of switch */
}/*End of while */
}/*End of main()*/

display()
{
int i;
if (n == 0)
{
printf("Heap is empty \n");
return;
}
for (i = 0; i < n; i++)
printf("%d ", array[i]);
printf("\n");
}/*End of display()*/

insert(int num, int location)
{
int parentnode;
while (location > 0)
{
parentnode =(location - 1)/2;
if (num <= array[parentnode])
{
array[location] = num;
return;
}
array[location] = array[parentnode];
location = parentnode;
}/*End of while*/
array[0] = num; /*assign number to the root node */
}/*End of insert()*/

delete(int num)
{
int left, right, i, temp, parentnode;

for (i = 0; i < num; i++) {
if (num == array[i])
break;
}
if (num != array[i])
{
printf("%d not found in heap list\n", num);
return;
}
array[i] = array[n - 1];
n = n - 1;
parentnode =(i - 1) / 2; /*find parentnode of node i */
if (array[i] > array[parentnode])
{
insert(array[i], i);
return;
}
left = 2 * i + 1; /*left child of i*/
right = 2 * i + 2; /* right child of i*/
while (right < n)
{
if (array[i] >= array[left] && array[i] >= array[right])
return;
if (array[right] <= array[left])
{
temp = array[i];
array[i] = array[left];
array[left] = temp;
i = left;
}
else
{
temp = array[i];
array[i] = array[right];
array[right] = temp;
i = right;
}
left = 2 * i + 1;
right = 2 * i + 2;
}/*End of while*/
if (left == n - 1 && array[i])    {
temp = array[i];
array[i] = array[left];
array[left] = temp;
}
}
 ETP 
 
C Program to Construct a B Tree 
================================ EOPN
/* * C Program to Construct a B Tree 
================================ EOKW
--------------------------------
output:
$ cc pgm61.c
$ a.out
PREORDER
g d b a c f e i h j
INORDER
a b c d e f g h i j
POSTORDER
a c b e f d h j i g
--------------------------------

/***************************
* binarytree.h
***************************/

typedef char DATA;

struct node
{
DATA d;
struct node *left;
struct node *right;
};

typedef struct node NODE;
typedef NODE *BTREE;

BTREE newnode(void);
BTREE init_node(DATA d, BTREE p1, BTREE p2);
BTREE create_tree(DATA a[], int i, int size);
void preorder (BTREE root);
void inorder (BTREE root);
void postorder (BTREE root);

/**********************
* binarytree.c:
***********************/
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "binarytree.h"

BTREE new_node()
{
return ((BTREE)malloc(sizeof(NODE)));
}

BTREE init_node(DATA d1, BTREE p1, BTREE p2)
{
BTREE t;

t = new_node();
t->d = d1;
t->left = p1;
t->right = p2;
return t;
}

/* create a linked binary tree from an array */
BTREE create_tree(DATA a[], int i, int size)
{
if (i >= size)
return NULL;
else
return(init_node(a[i],
create_tree(a, 2*i+1, size),
create_tree(a, 2*i+2, size)));
}

/* preorder traversal */
void preorder (BTREE root)
{
if (root != NULL) {
printf("%c ", root->d);
preorder(root -> left);
preorder(root -> right);
}
}

/* Inorder traversal */
void inorder (BTREE root)
{
if (root != NULL) {
inorder(root -> left);
printf("%c ", root->d);
inorder(root -> right);
}
}

/* postorder binary tree traversal */

void postorder (BTREE root)
{
if (root != NULL) {
postorder(root -> left);
postorder(root -> right);
printf("%c ", root->d);
}
}

/***************************
* pgm.c
***************************/
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "binarytree.c"
#define ARRAY_SIZE 10
int main(void)
{
char a[ARRAY_SIZE] = {'g','d','i','b','f','h','j','a','c','e'};
BTREE root;

root = create_tree(a, 0, ARRAY_SIZE) ;
assert(root != NULL);
printf("PREORDER\n");
preorder(root);
printf("\n");
printf("INORDER\n");
inorder(root);
printf("\n");

printf("POSTORDER\n");
postorder(root);
printf("\n");
}
 ETP 
 
 C Program to Construct a Binary Search Tree and perform deletion and inorder traversal 
================================ EOPN
/*  * C Program to Construct a Binary Search Tree and perform deletion, inorder traversal on it 
================================ EOKW
--------------------------------
output:
$ cc tree43.c
$ a.out
OPERATIONS ---
1 - Insert an element into tree
2 - Delete an element from the tree
3 - Inorder Traversal
4 - Preorder Traversal
5 - Postorder Traversal
6 - Exit
 
Enter your choice : 1
Enter data of node to be inserted : 40
 
Enter your choice : 1
Enter data of node to be inserted : 20
 
Enter your choice : 1
Enter data of node to be inserted : 10
 
Enter your choice : 1
Enter data of node to be inserted : 30
 
Enter your choice : 1
Enter data of node to be inserted : 60
 
Enter your choice : 1
Enter data of node to be inserted : 80
 
Enter your choice : 1
Enter data of node to be inserted : 90
 
Enter your choice : 3
10 -> 20 -> 30 -> 40 -> 60 -> 80 -> 90 ->
 
            40
            /\
           /  \
         20    60
         / \    \
       10  30   80
                  \
                  90
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
}*root = NULL, *temp = NULL, *t2, *t1;

void delete1();
void insert();
void delete();
void inorder(struct btnode *t);
void create();
void search(struct btnode *t);
void preorder(struct btnode *t);
void postorder(struct btnode *t);
void search1(struct btnode *t,int data);
int smallest(struct btnode *t);
int largest(struct btnode *t);

int flag = 1;

void main()
{
int ch;

printf("\nOPERATIONS ---");
printf("\n1 - Insert an element into tree\n");
printf("2 - Delete an element from the tree\n");
printf("3 - Inorder Traversal\n");
printf("4 - Preorder Traversal\n");
printf("5 - Postorder Traversal\n");
printf("6 - Exit\n");
while(1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
insert();
break;
case 2:
delete();
break;
case 3:
inorder(root);
break;
case 4:
preorder(root);
break;
case 5:
postorder(root);
break;
case 6:
exit(0);
default :
printf("Wrong choice, Please enter correct choice  ");
break;
}
}
}

/* To insert a node in the tree */
void insert()
{
create();
if (root == NULL)
root = temp;
else
search(root);
}

/* To create a node */
void create()
{
int data;

printf("Enter data of node to be inserted : ");
scanf("%d", &data);
temp = (struct btnode *)malloc(1*sizeof(struct btnode));
temp->value = data;
temp->l = temp->r = NULL;
}

/* Function to search the appropriate position to insert the new node */
void search(struct btnode *t)
{
if ((temp->value > t->value) && (t->r != NULL))      /* value more than root node value insert at right */
search(t->r);
else if ((temp->value > t->value) && (t->r == NULL))
t->r = temp;
else if ((temp->value < t->value) && (t->l != NULL))    /* value less than root node value insert at left */
search(t->l);
else if ((temp->value < t->value) && (t->l == NULL))
t->l = temp;
}

/* recursive function to perform inorder traversal of tree */
void inorder(struct btnode *t)
{
if (root == NULL)
{
printf("No elements in a tree to display");
return;
}
if (t->l != NULL)
inorder(t->l);
printf("%d -> ", t->value);
if (t->r != NULL)
inorder(t->r);
}

/* To check for the deleted node */
void delete()
{
int data;

if (root == NULL)
{
printf("No elements in a tree to delete");
return;
}
printf("Enter the data to be deleted : ");
scanf("%d", &data);
t1 = root;
t2 = root;
search1(root, data);
}

/* To find the preorder traversal */
void preorder(struct btnode *t)
{
if (root == NULL)
{
printf("No elements in a tree to display");
return;
}
printf("%d -> ", t->value);
if (t->l != NULL)
preorder(t->l);
if (t->r != NULL)
preorder(t->r);
}

/* To find the postorder traversal */
void postorder(struct btnode *t)
{
if (root == NULL)
{
printf("No elements in a tree to display ");
return;
}
if (t->l != NULL)
postorder(t->l);
if (t->r != NULL)
postorder(t->r);
printf("%d -> ", t->value);
}

/* Search for the appropriate position to insert the new node */
void search1(struct btnode *t, int data)
{
if ((data>t->value))
{
t1 = t;
search1(t->r, data);
}
else if ((data < t->value))
{
t1 = t;
search1(t->l, data);
}
else if ((data==t->value))
{
delete1(t);
}
}

/* To delete a node */
void delete1(struct btnode *t)
{
int k;

/* To delete leaf node */
if ((t->l == NULL) && (t->r == NULL))
{
if (t1->l == t)
{
t1->l = NULL;
}
else
{
t1->r = NULL;
}
t = NULL;
free(t);
return;
}

/* To delete node having one left hand child */
else if ((t->r == NULL))
{
if (t1 == t)
{
root = t->l;
t1 = root;
}
else if (t1->l == t)
{
t1->l = t->l;

}
else
{
t1->r = t->l;
}
t = NULL;
free(t);
return;
}

/* To delete node having right hand child */
else if (t->l == NULL)
{
if (t1 == t)
{
root = t->r;
t1 = root;
}
else if (t1->r == t)
t1->r = t->r;
else
t1->l = t->r;
t == NULL;
free(t);
return;
}

/* To delete node having two child */
else if ((t->l != NULL) && (t->r != NULL))
{
t2 = root;
if (t->r != NULL)
{
k = smallest(t->r);
flag = 1;
}
else
{
k =largest(t->l);
flag = 2;
}
search1(root, k);
t->value = k;
}

}

/* To find the smallest element in the right sub tree */
int smallest(struct btnode *t)
{
t2 = t;
if (t->l != NULL)
{
t2 = t;
return(smallest(t->l));
}
else
return (t->value);
}

/* To find the largest element in the left sub tree */
int largest(struct btnode *t)
{
if (t->r != NULL)
{
t2 = t;
return(largest(t->r));
}
else
return(t->value);
}
 ETP 
 
 C Program To Find the Smallest and Largest Elements in the Binary Search Tree 
================================ EOPN
/* * C Program for finding the smallest * and the largest node in a Binary Search Tree 
================================ EOKW
--------------------------------
output:
                    25
                  /    \  
                 17     35   
                / \     / \ 
              13  19   27 55
--------------------------------
#include <stdio.h>
#include <stdlib.h>
struct node
{
int info;
struct node *left, *right;
};
struct node *createnode(int key)
{
struct node *newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;
return(newnode);
}
void inorder(struct node *root)
{
if(root != NULL)
{
inorder(root->left);
printf(" %d ",root->info);
inorder(root->right);
}
}
void smallest(struct node *root)
{
while(root != NULL && root->left != NULL)
{
root = root->left;
}
printf("\nSmallest value is %d\n", root->info);
}
void largest(struct node *root)
{
while (root != NULL && root->right != NULL)
{
root = root->right;
}
printf("\nLargest value is %d", root->info);
}
/*
* Main Function
*/
int main()
{
/* Creating first Tree. */
struct node *newnode = createnode(25);
newnode->left = createnode(17);
newnode->right = createnode(35);
newnode->left->left = createnode(13);
newnode->left->right = createnode(19);
newnode->right->left = createnode(27);
newnode->right->right = createnode(55);
/* Sample Tree 1:
*               25
*             /    \
*            17     35
*           / \     / \
*         13  19   27 55
*/
printf("Inorder traversal of tree 1 :");
inorder(newnode);
largest(newnode);
smallest(newnode);

/* Creating second Tree. */
struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);
/* Sample Tree 2:   Right Skewed Tree (Unbalanced).
*               1
*                \
*                 2
*                  \
*                   3
*                    \
*                     4
*                      \
*                       5
*/
printf("\nInorder traversal of tree 2 :");
inorder(node);
largest(node);
smallest(node);

/* Creating third Tree. */
struct node *root = createnode(15);
/* Sample Tree 3- Tree having just one root node.
*              15
*/
printf("\nInorder traversal of tree 3 :");
inorder(root);
largest(root);
smallest(root);
return 0;
}
 ETP 
 
 C Program to Construct a Balanced Binary Tree using Sorted Array 
================================ EOPN
/* * C Program to Construct a Balenced Binary Tree using Sorted Array *                   40 *                   /  \ *                  20   60 *                 /  \   \ *                10  30   80 *                          \ *                           90     *            (Given Binary Search Tree) 
================================ EOKW
--------------------------------
output:
$ cc tree21.c
$ a.out
Given sorted array is
10      20      30      40      60      80      90
The preorder traversal of binary search tree is as follows
40->20->10->30->80->60->90
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
};

typedef struct btnode N;
N* bst(int arr[], int first, int last);
N* new(int val);
void display(N *temp);

int main()
{
int arr[] = {10, 20, 30, 40, 60, 80, 90};
N *root = (N*)malloc(sizeof(N));
int n = sizeof(arr) / sizeof(arr[0]), i;

printf("Given sorted array is\n");
for (i = 0;i < n;i++)
printf("%d\t", arr[i]);
root = bst(arr, 0, n - 1);
printf("\n The preorder traversal of binary search tree is as follows\n");
display(root);
printf("\n");
return 0;
}

/* To create a new node */
N* new(int val)
{
N* node = (N*)malloc(sizeof(N));

node->value = val;
node->l = NULL;
node->r  =  NULL;
return node;
}

/* To create a balanced binary search tree */
N* bst(int arr[], int first, int last)
{
int mid;
N* temp = (N*)malloc(sizeof(N));
if (first > last)
return NULL;
mid = (first + last) / 2;
temp = new(arr[mid]);
temp->l = bst(arr, first, mid - 1);
temp->r = bst(arr, mid + 1, last);
return temp;
}

/* To display the preorder */
void display(N *temp)
{
printf("%d->", temp->value);
if (temp->l != NULL)
display(temp->l);
if (temp->r != NULL)
display(temp->r);
}
 ETP 
 
 C Program to Find the Common Ancestor and Print the Path 
================================ EOPN
/* * C Program to Find the Common Ancestor and Print the Path * *                       10 *                       /  \                     *                      7    15 *                     / \   / \ *                    6   8 12  18 *                   /     \ *                  5         9 *               (Given Binary tree)  
================================ EOKW
--------------------------------
output:
$ cc tree33.c
$ a.out
Enter the choice
1-Display : 2-path : 3-Exit
1
preorder display of tree elements
10->7->6->5->8->9->15->12->18->20
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
6
8
anc = 7
7->6
7->8
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
7
20
anc = 10
10->7
10->15->18->20
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
12
20
anc = 15
15->12
15->18->20
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
15
20
10->15
10->15->18->20
Enter the choice
1-Display : 2-path : 3-Exit
3
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
};

typedef struct btnode N;

N* new(int);
int count;

void create();
void preorder(N *t);
void ancestor(N *t);
int search(N *t, int, int);
void path(int, int, int);

N *root = NULL;

void main()
{
int choice;

create();
while (1)
{
printf("Enter the choice\n");
printf("1-Display : 2-path : 3-Exit\n");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("preorder display of tree elements\n");
preorder(root);
printf("\n");
break;
case 2:
ancestor(root);
break;
case 3:
exit(0);
default:
printf("Enter the right choice\n");
}
}
}

/* creating temporary node */
N* new(int data)
{
N* temp = (N*)malloc(sizeof(N));
temp->value = data;
temp->l = NULL;
temp->r = NULL;

return(temp);
}

/* Creating the binary search tree */
void create()
{
root = new(10);
root->l = new(7);
root->r = new(15);
root->l->l = new(6);
root->l->r = new(8);
root->r->l = new(12);
root->r->r = new(18);
root->r->r->r = new(20);
root->l->l->l = new(5);
root->l->r->r = new(9);
}

/* To display the preorder traversal of the tree */
void preorder(N *temp)
{
printf("%d->", temp->value);
if (temp->l != NULL)
preorder(temp->l);
if (temp->r != NULL)
preorder(temp->r);
}

/* to find common ancestor for given nodes */
void ancestor(N *temp)
{
int a, b, anc = 0;
count = 0;

printf("enter two node values to find common ancestor\n");
scanf("%d", &a);
scanf("%d", &b);
count = search(root, a, b);
if (count  == 2)
{
while (temp->value != a && temp->value != b)
{
if ((temp->value > a)&&(temp->value > b))
{
anc = temp->value;
temp = temp->l;
}
else if ((temp->value < a)&&(temp->value < b))
{
anc = temp->value;
temp = temp->r;
}
else if ((temp->value > a)&&(temp->value < b))
{
anc = temp->value;
printf("anc = %d\n", anc);
break;
}
else if ((temp->value < a)&&(temp->value > b))
{
anc = temp->value;
temp = temp->r;
}
else
{
printf("common ancestor = %d\n", anc);
break;
}
}
path(anc, a, b);
}
else
printf("enter correct node values & do not enter root value\n");
}

/* to find whether given nodes are present in tree or not */
int search(N *temp, int a, int b)
{
if ((temp->value  == a ||temp->value  == b)&& (root->value != a&&root->value != b))
{
count++;
}
if (temp->l != NULL)
search(temp->l, a, b);
if (temp->r != NULL)
search(temp->r, a, b);
return count;
}

/* to print the path ancestor to given nodes */
void path(int anc, int c, int b)
{
N *temp = NULL;
int i = 0, a[2];
a[0] = c;
a[1] = b;

for (;i < 2;i++)
{
if (anc == root->value)    // If ancestor is root
{
temp = root;
while (1)
{
printf("%d", temp->value);
if (a[i] < temp->value)
temp = temp->l;
else if (a[i] > temp->value)
temp = temp->r;
else
{
if (a[i] == temp->value)
{
break;
}
}
printf("->");
}
printf("\n");
}
else if (anc < root->value)    //If ancestor is less than the root value
{
temp = root;
while (temp != NULL)
{
if (anc < temp->value)
temp = temp->l;
else if (anc > temp->value)
temp = temp->r;
else
{
while (1)
{
if (a[i] < temp->value)
{
printf("%d->", temp->value);
temp = temp->l;
}
else if (a[i] > temp->value)
{
printf("%d->", temp->value);
temp = temp->r;
}
else
{
printf("%d\n", temp->value);
break;
}
}
}
}
}
else //If ancestor greater than the root value
{
temp = root;
while (temp != NULL)
{
if (anc > temp->value)
temp = temp->r;
else if (anc < temp->value)
temp = temp->l;
else
{
while (1)
{
if (a[i] < temp->value)
{
printf("%d->", temp->value);
temp = temp->l;
}
else if (a[i] > temp->value)
{
printf("%d->", temp->value);
temp = temp->r;
}
else
{
printf("%d\n", temp->value);
break;
}
}
}
}
}
}
}
 ETP 
 
 C Program to Count Number of Leaf Node in a Tree 
================================ EOPN
/* C Program to find the number of leaf nodes in a Tree 
================================ EOKW
--------------------------------
output:
If the input tree is      
                    25
                  /    \
                 27     19
                / \     / \
              17  91   13 55
then number of leaf nodes in this tree will be 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int info;
struct node* left, *right;

};

/*
* Function to create new nodes
*/

struct node* createnode(int key)
{
struct node* newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;

return(newnode);
}

/*
* Function to count number of leaf nodes
*/

int count = 0;
int leafnodes(struct node* newnode)
{

if(newnode != NULL)
{
leafnodes(newnode->left);
if((newnode->left == NULL) && (newnode->right == NULL))
{
count++;
}
leafnodes(newnode->right);
}
return count;

}

/*
* Main Function
*/

int main()
{
/* Creating first Tree.*/

struct node *newnode = createnode(25);
newnode->left = createnode(27);
newnode->right = createnode(19);
newnode->left->left = createnode(17);
newnode->left->right = createnode(91);
newnode->right->left = createnode(13);
newnode->right->right = createnode(55);

/* Sample Tree 1- Balanced Tree


25
/    \
27     19
/ \     / \
17  91   13 55

*/
printf("Number of leaf nodes in first Tree are\t%d\n",leafnodes(newnode));
count = 0;

struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);

/* Sample Tree 2-   Right Skewed Tree (Unbalanced).

1
\
2
\
3
\
4
\
5
*/

printf("\nNumber of leaf nodes in second tree are\t%d\n",leafnodes(node));
count = 0;

/*Creating third Tree. */

struct node *root = createnode(15);

/* Sample Tree 3-  Tree having just one root node.

15
*/

printf("\nNumber of leaf nodes in third tree are\t%d",leafnodes(root));

return 0;
}
 ETP 
 
 C Program to Find Nodes which are at Maximum Distance in Binary Tree 
================================ EOPN
/*  * C Program to Find Nodes which are at Maximum Distance in Binary Tree 
================================ EOKW
--------------------------------
output:
$ cc tree19.c
$ a.out
Program to find nodes at maximum distance
OPERATIONS ----
   1] Insert 
   2] Display nodes 
   3] Exit 
   Enter your choice : 1
   Enter the data of node : 50
 
   Enter your choice : 1
   Enter the data of node : 30
 
   Enter your choice : 1
   Enter the data of node : 20
 
   Enter your choice : 1
   Enter the data of node : 40
 
   Enter your choice : 1
   Enter the data of node : 35
 
   Enter your choice : 1
   Enter the data of node : 100
 
   Enter your choice : 1
   Enter the data of node : 70
 
   Enter your choice : 1
   Enter the data of node : 120
 
   Enter your choice : 1
   Enter the data of node : 140
 
   Enter your choice : 2
   Maximum distance nodes 
   Nodes     Distance 
    35      3 
    140      3 
 
 
            50
            /\
           /  \
         30    100
         / \   / \
       20  40 70 120
           /       \
          35       140
 
    Enter your choice : 3
 
 
   $ ./a.out
 
   Program to find nodes at maximum distance
      OPERATIONS ----
   1] Insert 
   2] Display nodes 
   3] Exit 
   Enter your choice : 1
   Enter the data of node : 40
 
   Enter your choice : 1
   Enter the data of node : 20
 
   Enter your choice : 1
   Enter the data of node : 60
 
   Enter your choice : 1
   Enter the data of node : 10
 
   Enter your choice : 1
   Enter the data of node : 30
 
   Enter your choice : 1
   Enter the data of node : 80
 
   Enter your choice : 1
   Enter the data of node : 90
 
   Enter your choice : 2
   Maximum distance nodes 
      Nodes     Distance 
       90     3 
   Enter your choice : 3
 
 
 
            40
            /\
           /  \
         20    60
         / \    \
       10  30   80
                  \
                  90
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *r,*l;
} *root = NULL, *temp = NULL;

void create();
void insert();
void add(struct btnode *t);
void maxdistance(struct btnode *t);

int count = 0, max = 0, v[100] = {0}, z = 0, max2, max1[100] = {0};

void main()
{
int ch, i;

printf("Program to find nodes at maximum distance");
printf("\n  OPERATIONS ----");
printf("\n1] Insert ");
printf("\n2] Display nodes ");
printf("\n3] Exit ");
while (1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
insert();
break;
case 2:
max = 0;
count = 0;
maxdistance(root);
for (i = 1; i < z; i++)
{
max2 = max1[0];
if (max2 < max1[i])
max2 = max1[i];
}
printf("Maximum distance nodes \nNodes\t Distance ");
for (i = 0; i < z; i++)
{
if (max2 == max1[i])
printf("\n %d\t  %d ",v[i],max2);
}
break;
case 3:
exit(0);
default :
printf("Wrong choice, Please enter correct choice  ");
break;
}
}
}

/* To create a new node with the data from the user */
void create()
{
int data;

printf("Enter the data of node : ");
scanf("%d", &data);
temp = (struct btnode* ) malloc(1*(sizeof(struct btnode)));
temp->value = data;
temp->l = temp->r = NULL;
}

/* To check for root node and then create it */
void insert()
{
create();

if (root == NULL)
root = temp;
else
add(root);
}

/* Search for the appropriate position to insert the new node */
void add(struct btnode *t)
{
if ((temp->value > t->value) && (t->r!=NULL))    /* value more than root node value insert at right */
add(t->r);
else if ((temp->value > t->value) && (t->r==NULL))
t->r = temp;
else if ((temp->value < t->value) && (t->l!=NULL))   /* value less than root node value insert at left */
add(t->l);
else if ((temp->value < t->value) && (t->l==NULL))
t->l = temp;
}

/* Function to find the max distance nodes */
void maxdistance(struct btnode *t)
{
if (t->l!=NULL)
{
count++;            /* to count the number of nodes in between root and leaf */
maxdistance(t->l);
}
if (max < count)
max = count;
if (max == count)
{
max1[z] = max;
v[z] = t->value;
z++;
}
if (t->r != NULL)
{
count++;
maxdistance(t->r);
}
count--;
}
 ETP 
 
 C Program to Find the Number of Nodes in a Binary Tree 
================================ EOPN
/* C Program for counting the number of nodes in a Tree 
================================ EOKW
--------------------------------
output:
                    25
                  /    \  
                 27     19   
                / \     / \ 
              17  91   13 55
--------------------------------
#include <stdio.h>
#include <stdlib.h>
struct node
{
int info;
struct node *left, *right;
};
struct node *createnode(int key)
{
struct node *newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;
return(newnode);
}
static int count = 0;
int countnodes(struct node *root)
{
if(root != NULL)
{
countnodes(root->left);
count++;
countnodes(root->right);
}
return count;
}
/*
* Main Function
*/
int main()
{
/* Creating first Tree. */
struct node *newnode = createnode(25);
newnode->left = createnode(27);
newnode->right = createnode(19);
newnode->left->left = createnode(17);
newnode->left->right = createnode(91);
newnode->right->left = createnode(13);
newnode->right->right = createnode(55);
/* Sample Tree 1:
*                25
*             /    \
*            27     19
*           / \     / \
*         17  91   13 55
*/
printf("Number of nodes in tree 1 = %d ",countnodes(newnode));
printf("\n");
count = 0;

/* Creating second Tree. */
struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);
/* Sample Tree 2:   Right Skewed Tree (Unbalanced).
*               1
*                \
*                 2
*                  \
*                   3
*                    \
*                     4
*                      \
*                       5
*/
printf("Number of nodes in tree 2 = %d ",countnodes(node));
printf("\n");
count = 0;

/* Creating third Tree. */
struct node *root = createnode(15);
/* Sample Tree 3- Tree having just one root node.
*              15
*/
printf("Number of nodes in tree 3 = %d",countnodes(root));
return 0;
}
 ETP 
 
 C Program to Print Border of given Tree in Anticlockwise Direction 
================================ EOPN
/* * C Program to Print Border of given Tree in Anticlockwise Direction  *              50 *             /  \ *            20  30 *           /  \ *          70  80 *         / \    \ *       10  40   60                                 
================================ EOKW
--------------------------------
output:
 
         50
        /  \
       20   30
       / \
      70  80
     /  \   \
    10   40  60        
 
$ cc tree30.c
$ a.out
 
printing the border elements anticlockwise direction:
->50->20->70->10->40->60->30
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode {
int value;
struct btnode *l;
struct btnode *r;
};
struct btnode *root;
typedef struct btnode bt;
bt *new, *ptr, *ptr1, *ptr2;

void print();
void print_leaf_nodes(bt*);
void print_right_recursive(bt*);
bt* create();
void construct_binary_tree();

void main()
{
construct_binary_tree();
printf("\nprinting the border elements anticlockwise direction:\n");
print();
printf("\n");
}

bt* create()
{
new = (bt *)malloc(sizeof(bt));
new->l = NULL;
new->r = NULL;
return new;
}

void construct_binary_tree()
{
root = create();
root->value = 50;

ptr = create();
root->l = ptr;
ptr->value = 20;
ptr1 = create();
ptr->l = ptr1;
ptr1->value = 70;
ptr2 = create();
ptr1->l = ptr2;
ptr2->value = 10;
ptr2 = create();
ptr1->r = ptr2;
ptr2->value = 40;
ptr1 = create();
ptr->r = ptr1;
ptr1->value = 80;
ptr2 = create();
ptr1->r = ptr2;
ptr2->value = 60;
ptr = create();
root->r = ptr;
ptr->value = 30;
}

void print()
{
ptr = root;
while (ptr->l != NULL)
{
printf("->%d", ptr->value);
ptr = ptr->l;
}
ptr = root;
print_leaf_nodes(ptr);
ptr = root;
print_right_recursive(ptr);
}

void print_leaf_nodes(bt* ptr)
{
if (ptr != NULL)
{
if (ptr->l == NULL && ptr->r == NULL)
{
printf("->%d", ptr->value);
}
else
{
print_leaf_nodes(ptr->l);
print_leaf_nodes(ptr->r);
}
}
else
return;
}

void print_right_recursive(bt* ptr)
{
int val;
ptr = ptr->r;
if (ptr->r != NULL)
{
print_right_recursive(ptr->r);
printf("->%d", ptr->value);
}
else
{
return;
}
}
 ETP 
 
 C Program to Print Height and Depth of given Binary Tree 
================================ EOPN
/* * C Program to Print Height and Depth of given Binary Tree *                                        50 *                                       /  \ *                                      20   30 *                                     /  \ *                                    70  80 *                                   / \    \ *                                  10  40   60                                 
================================ EOKW
--------------------------------
output:
$ cc tree18.c
$ a.out
height of the tree is 3
depth of the tree is 3
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode {
int value;
struct btnode *l;
struct btnode *r;
};
struct btnode *root;
typedef struct btnode bt;
bt *new,*ptr,*ptr1,*ptr2;

bt* create()
{
new = (bt *)malloc(sizeof(bt));
new->l = NULL;
new->r = NULL;
return new;
}

void construct_binary_tree()
{
root = create();
root->value = 50;

ptr = create();
root->l = ptr;
ptr->value = 20;

ptr1 = create();
ptr->l = ptr1;
ptr1->value = 70;

ptr2 = create();
ptr1->l = ptr2;
ptr2->value = 10;

ptr2 = create();
ptr1->r = ptr2;
ptr2->value = 40;

ptr1 = create();
ptr->r = ptr1;
ptr1->value = 80;

ptr2 = create();
ptr1->r = ptr2;
ptr2->value = 60;

ptr = create();
root->r = ptr;
ptr->value = 30;
}

void main()
{
int depth1 = 0, depth2 = 0;

construct_binary_tree();
ptr = root;
while (ptr->l != NULL || ptr->r != NULL)
{
depth1++;
if (ptr->l == NULL)
ptr = ptr->r;
else
ptr = ptr->l;
}
ptr = root;
while (ptr->l != NULL || ptr->r != NULL)
{
depth2++;
if (ptr->r == NULL)
ptr = ptr->l;
else
ptr = ptr->r;
}
/*
*DEPTH IS CONSIDERED FROM LEVEL-0 ALSO HEIGHT IS CONSIDERED AS NUMBER OF EDGES
*/
if (depth1 > depth2)
printf("height of the tree is %d\ndepth of the tree is %d",depth1,depth1);
else
printf("height of the tree is %d\ndepth of the tree is %d",depth2,depth2);
}
 ETP 
 
 C Program to Count Number of Non Leaf Nodes of a given Tree 
================================ EOPN
/* C Program to find the number of non leaf nodes in a Tree 
================================ EOKW
--------------------------------
output:
If the input tree is   
                    25
                  /    \
                 27     19
                / \     / \
              17  91   13 55 
The number of internal or non leaf nodes in this tree are 3
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int info;
struct node* left, *right;

};

/*
* Function to create new nodes
*/

struct node* createnode(int key)
{
struct node* newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;

return(newnode);
}

/*
* Function to count number of leaf nodes
*/

int count = 0;
int nonleafnodes(struct node* newnode)
{

if(newnode != NULL)
{
nonleafnodes(newnode->left);
if((newnode->left != NULL) || (newnode->right != NULL))
{
count++;
}
nonleafnodes(newnode->right);
}
return count;

}

/*
* Main Function
*/

int main()
{
/* Creating first Tree.*/

struct node *newnode = createnode(25);
newnode->left = createnode(27);
newnode->right = createnode(19);
newnode->left->left = createnode(17);
newnode->left->right = createnode(91);
newnode->right->left = createnode(13);
newnode->right->right = createnode(55);

/* Sample Tree 1- Balanced Tree


25
/    \
27     19
/ \     / \
17  91   13 55

*/
printf("Number of non leaf nodes in first Tree are\t%d",nonleafnodes(newnode));
printf("\n");
count = 0;

struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);

/* Sample Tree 2-   Right Skewed Tree (Unbalanced).

1
\
2
\
3
\
4
\
5
*/
printf("\n");
printf("Number of non leaf nodes in second tree are\t%d",nonleafnodes(node));
printf("\n");
count = 0;

/*Creating third Tree. */

struct node *root = createnode(15);

/* Sample Tree 3-  Tree having just one root node.

15
*/
printf("\n");
printf("Number of non leaf nodes in third tree are\t%d",nonleafnodes(root));

return 0;
}
 ETP 
 
 C Program to Check whether a Tree and its Mirror Image are same 
================================ EOPN
/* * C Program to Check whether a Tree and its Mirror Image are same *                        50                               50 *                       /  \                             /  \ *                      20     30                        30   20 *  Sample Tree<------ /  \                                  /  \   ----------> Mirror image *                    70      80                            80   70 *                   /  \    \                             /    /  \   *                  10  40     60                        60   40   10 *                             (50,20,30,70,80,10,40,60)                                   
================================ EOKW
--------------------------------
output:
 
 
           50                                   50
          /  \                                 /  \ 
        20     30                             30   20
       /  \                                          /  \  
     70       80                                    80   70
    /  \    \                                   /    /  \
   10    40     60                                   60   40   10
   (Given Tree)                                (Mirror)
$ cc tree7.c
$ ./a.out
->10->70->40->20->80->60->50->30
mirror image:
->30->50->60->80->20->40->70->10
not same
 
            50                                    50
           /  \                                  /  \
          50   50                               50   50     
        (Given Tree)                          (Mirror)
 
$ ./a.out
->50->50->50
mirror image:
->50->50->50
same
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode {
int value;
struct btnode * l;
struct btnode * r;
};

typedef struct btnode bt;

bt *root,*temp;
bt *new;
int c;

bt * create_node();
void display(bt *);
bt * construct_tree();
void mirror_image(bt *);
int compare(bt *,bt *);

void main()
{
root = construct_tree();
display(root);
temp = construct_tree();
mirror_image(temp);
printf("\n mirror image:\n");
display(temp);
c = compare(root,temp);
if (c)
{
printf("\nsame");
}
else
{
printf("\nnot same");
}
}

/* creates new node */
bt * create_node()
{
new=(bt *)malloc(sizeof(bt));
new->l = NULL;
new->r = NULL;
}

/* constructs the tree */
bt * construct_tree()
{
bt *list;

list = create_node();
list->value = 50;
list->l = create_node();
list->l->value = 20;
list->r = create_node();
list->r->value = 30;
list->l->l = create_node();
list->l->l->value = 70;
list->l->r = create_node();
list->l->r->value = 80;
list->l->r->r = create_node();
list->l->r->r->value = 60;
list->l->l->l = create_node();
list->l->l->l->value = 10;
list->l->l->r = create_node();
list->l->l->r->value = 40;

return list;
}

/* displays the tree using inorder */
void display(bt * list)
{
if (list == NULL)
{
return;
}
display(list->l);
printf("->%d", list->value);
display(list->r);
}

/* creates mirror image of a tree */
void mirror_image(bt * list)
{
bt * temp1;

if (list == NULL)
{
return;
}
temp1 = list->l;
list->l = list->r;
list->r = temp1;
mirror_image(list->l);
mirror_image(list->r);
}

/* compares tree and its mirror image */
int compare(bt *list, bt * list1)
{
int d;
if (list == NULL && list1 == NULL)
{
return 1;
}
else if (list != NULL && list1 != NULL)
{
return(list->value == list1->value &&
compare(list->l, list1->l) &&
compare(list->r, list1->r));
}
else
{
return 0;
}
}
 ETP 
 
 C Program to Create a Mirror Copy of a Tree and Display using BFS Traversal 
================================ EOPN
/*  * C Program to Create a Mirror Copy of a Tree and Display using  * BFS Traversal *                    40 *                    /\ *                   20 60 *                   /\  \ *                  10 30  80 *                          \ *                           90 
================================ EOKW
--------------------------------
output:
$ cc tree16.c
$ a.out
Enter the elements of the tree(enter 0 to exit)
40
20
10
30
60
70
80
0
mirror image of tree is
40 -> 60 -> 20 -> 70 -> 30 -> 10 -> 80
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *left, *right;
};
typedef struct btnode node;

/* function prototypes */
void insert(node *, node *);
void mirror(node *);

/* global variables */
node *root = NULL;
int val, front = 0, rear = -1, i;
int queue[20];

void main()
{
node *new = NULL ;
int num = 1;
printf("Enter the elements of the tree(enter 0 to exit)\n");
while (1)
{
scanf("%d",  &num);
if (num == 0)
break;
new = malloc(sizeof(node));
new->left = new->right = NULL;
new->value = num;
if (root == NULL)
root = new;
else
{
insert(new, root);
}
}
printf("mirror image of tree is\n");
queue[++rear] = root->value;
mirror(root);
for (i = 0;i <= rear;i++)
printf("%d -> ", queue[i]);
printf("%d\n", root->right->right->right->value);
}

/* inserting nodes into the tree */
void insert(node * new , node *root)
{
if (new->value > root->value)
{
if (root->right == NULL)
root->right = new;
else
insert (new, root->right);
}
if (new->value < root->value)
{
if (root->left == NULL)
root->left = new;
else
insert (new, root->left);
}
}

/* mirror image of nodes */
void mirror(node *root)
{
val = root->value;
if ((front <= rear) && (root->value == queue[front]))
{
if (root->right != NULL || root->right == NULL)
queue[++rear] = root->right->value;
if (root->left != NULL)
queue[++rear] = root->left->value;
front++;
}
if (root->right != NULL)
{
mirror(root->right);
}
if (root->left != NULL)
{
mirror(root->left);
}
}
 ETP 
 
 C Program to Find the Nearest Common Ancestor in the Given set of Nodes 
================================ EOPN
/* * C Program to Find the Nearest Common Ancestor in the Given set  * of Nodes  
================================ EOKW
--------------------------------
output:
/*
 * Binary tree
 *     50
 *     / \
 *    20 30
 *   / \ 
 *  70 80
 * / \     \
 *10 40      60
 */    
$ gcc test14.c
$ a.out
Enter nodes having common ancestor 60 30
The common ancestor is 50
 
$ a.out
Enter nodes having common ancestor 10 40
The common ancestor is 70
 
$ a.out
Enter nodes having common ancestor 10 70
The common ancestor is 20
 
$ a.out
Enter nodes having common ancestor 20 50
No common ancestor
--------------------------------
#include <stdio.h>
#include <stdlib.h>

/*
* Structure of binary tree node
*/
struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
};

void createbinary();
node* add(int val);
int height(node *);
int nearest_common_ancestor(node*,  int,  int);
typedef struct btnode node;
node *root = NULL, *ptr;

int  main()
{
int c, n1, n2;

createbinary();
printf("\nEnter nodes having common ancestor");
scanf("%d %d", &n1, &n2);
c = nearestcommonancestor(root, n1, n2);
if (c == -1)
{
printf("No common ancestor");
}
else
{
printf("The common ancestor is %d", c);
}
}
/*
* constructing the following binary tree
*     50
*     / \
*    20 30
*   / \
*  70 80
* / \     \
*10 40      60
*/
void createbinary()
{
root = add(50);
root->l = add(20);
root->r = add(30);
root->l->l = add(70);
root->l->r = add(80);
root->l->l->l = add(10);
root->l->l->r = add(40);
root->l->r->r = add(60);
}

/*
* Add node to binary tree
*/
node* add(int val)
{
ptr = (node*)malloc(sizeof(node));
if (ptr == NULL)
{
printf("Memory was not allocated");
return;
}
ptr->value = val;
ptr->l = NULL;
ptr->r = NULL;
return ptr;
}

/*
* height of the binary tree
*/
int height(node *n)
{
int lheight, rheight;

if (n != NULL)
{
lheight = height(n->l);
rheight = height(n->r);
if (lheight > rheight)
return(lheight + 1);
else
return(rheight + 1);
}
}

/*
* Finds the nearest common ancestor
*/
int nearestcommonancestor(node *temp, int n1, int n2)
{
int h, i, j, k;
node *prev;

/*
* If any one the inputted node is root then no common ancestor
*/
if (n1 == root->value || n2 == root->value)
{
return - 1;
}
h = height(root);
for (i = 1;i < h;i++)
{
if (temp->l->value == n1 || temp->r->value == n1 || temp ->l->value == n2 || temp->r->value == n2)
{
prev = temp;
for (j = 1, temp = root;j < h;j++)
{
if (temp != NULL)
{
if (temp->r->value == n2 || temp->r->value == n1 || temp->l->value == n1 || temp->l->value == n2)
{
/*
* If the parent of n1 and parent of n2 are same then the value of parent is returned
*/
if (prev->value == temp->value)
return prev->value;
/*
* otherwise from parents of two nodes is traversed upward if any node matches with other's node parent then that is
* considered as common ancestor
*/
else
for (k = 0, prev = temp;k < h;k++)
{
if (temp->l->value == prev->l->value)
return temp->value;
else
temp = temp->l;
}
}
}
temp = temp->l;
}
}
temp = temp->l;
}
}
 ETP 
 
 C Program to Find the Common Ancestor and Print the Path 
================================ EOPN
/* * C Program to Find the Common Ancestor and Print the Path * *                       10 *                       /  \                     *                      7    15 *                     / \   / \ *                    6   8 12  18 *                   /     \ *                  5         9 *               (Given Binary tree)  
================================ EOKW
--------------------------------
output:
$ cc tree33.c
$ a.out
Enter the choice
1-Display : 2-path : 3-Exit
1
preorder display of tree elements
10->7->6->5->8->9->15->12->18->20
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
6
8
anc = 7
7->6
7->8
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
7
20
anc = 10
10->7
10->15->18->20
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
12
20
anc = 15
15->12
15->18->20
Enter the choice
1-Display : 2-path : 3-Exit
2
enter two node values to find common ancestor
15
20
10->15
10->15->18->20
Enter the choice
1-Display : 2-path : 3-Exit
3
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
};

typedef struct btnode N;

N* new(int);
int count;

void create();
void preorder(N *t);
void ancestor(N *t);
int search(N *t, int, int);
void path(int, int, int);

N *root = NULL;

void main()
{
int choice;

create();
while (1)
{
printf("Enter the choice\n");
printf("1-Display : 2-path : 3-Exit\n");
scanf("%d", &choice);
switch (choice)
{
case 1:
printf("preorder display of tree elements\n");
preorder(root);
printf("\n");
break;
case 2:
ancestor(root);
break;
case 3:
exit(0);
default:
printf("Enter the right choice\n");
}
}
}

/* creating temporary node */
N* new(int data)
{
N* temp = (N*)malloc(sizeof(N));
temp->value = data;
temp->l = NULL;
temp->r = NULL;

return(temp);
}

/* Creating the binary search tree */
void create()
{
root = new(10);
root->l = new(7);
root->r = new(15);
root->l->l = new(6);
root->l->r = new(8);
root->r->l = new(12);
root->r->r = new(18);
root->r->r->r = new(20);
root->l->l->l = new(5);
root->l->r->r = new(9);
}

/* To display the preorder traversal of the tree */
void preorder(N *temp)
{
printf("%d->", temp->value);
if (temp->l != NULL)
preorder(temp->l);
if (temp->r != NULL)
preorder(temp->r);
}

/* to find common ancestor for given nodes */
void ancestor(N *temp)
{
int a, b, anc = 0;
count = 0;

printf("enter two node values to find common ancestor\n");
scanf("%d", &a);
scanf("%d", &b);
count = search(root, a, b);
if (count  == 2)
{
while (temp->value != a && temp->value != b)
{
if ((temp->value > a)&&(temp->value > b))
{
anc = temp->value;
temp = temp->l;
}
else if ((temp->value < a)&&(temp->value < b))
{
anc = temp->value;
temp = temp->r;
}
else if ((temp->value > a)&&(temp->value < b))
{
anc = temp->value;
printf("anc = %d\n", anc);
break;
}
else if ((temp->value < a)&&(temp->value > b))
{
anc = temp->value;
temp = temp->r;
}
else
{
printf("common ancestor = %d\n", anc);
break;
}
}
path(anc, a, b);
}
else
printf("enter correct node values & do not enter root value\n");
}

/* to find whether given nodes are present in tree or not */
int search(N *temp, int a, int b)
{
if ((temp->value  == a ||temp->value  == b)&& (root->value != a&&root->value != b))
{
count++;
}
if (temp->l != NULL)
search(temp->l, a, b);
if (temp->r != NULL)
search(temp->r, a, b);
return count;
}

/* to print the path ancestor to given nodes */
void path(int anc, int c, int b)
{
N *temp = NULL;
int i = 0, a[2];
a[0] = c;
a[1] = b;

for (;i < 2;i++)
{
if (anc == root->value)    // If ancestor is root
{
temp = root;
while (1)
{
printf("%d", temp->value);
if (a[i] < temp->value)
temp = temp->l;
else if (a[i] > temp->value)
temp = temp->r;
else
{
if (a[i] == temp->value)
{
break;
}
}
printf("->");
}
printf("\n");
}
else if (anc < root->value)    //If ancestor is less than the root value
{
temp = root;
while (temp != NULL)
{
if (anc < temp->value)
temp = temp->l;
else if (anc > temp->value)
temp = temp->r;
else
{
while (1)
{
if (a[i] < temp->value)
{
printf("%d->", temp->value);
temp = temp->l;
}
else if (a[i] > temp->value)
{
printf("%d->", temp->value);
temp = temp->r;
}
else
{
printf("%d\n", temp->value);
break;
}
}
}
}
}
else //If ancestor greater than the root value
{
temp = root;
while (temp != NULL)
{
if (anc > temp->value)
temp = temp->r;
else if (anc < temp->value)
temp = temp->l;
else
{
while (1)
{
if (a[i] < temp->value)
{
printf("%d->", temp->value);
temp = temp->l;
}
else if (a[i] > temp->value)
{
printf("%d->", temp->value);
temp = temp->r;
}
else
{
printf("%d\n", temp->value);
break;
}
}
}
}
}
}
}
 ETP 
 
 C Program to Print all the Elements of Nth Level in Single Line 
================================ EOPN
/* * C Program to Print all the Elements of Nth Level in Single Line  
================================ EOKW
--------------------------------
output:
/*
 * Binary tree
 *     50
 *     / \
 *    20 30
 *   / \ 
 *  70 80
 * / \     \
 *10 40      60
 */    
$ gcc tes26.c
$ a.out
 
LEVEL 0  :50
 
LEVEL 1  :20    30
 
LEVEL 2  :70    80
 
LEVEL 3  :10    40      60
--------------------------------
#include <stdio.h>
#include <stdlib.h>

/*
* structure of node
*/
struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
};

void createbinary();
node* add(int val);
int height(node *);
void printlevel(node *, int, int);
void print();

typedef struct btnode node;
node *root = NULL, *ptr;

int  main()
{
int c;

createbinary();
print();
}
/*
* constructing the following binary tree
*     50
*     / \
*    20 30
*   / \
*  70 80
* / \     \
*10 40      60
*/
void createbinary()
{
root = add(50);
root->l = add(20);
root->r = add(30);
root->l->l = add(70);
root->l->r = add(80);
root->l->l->l = add(10);
root->l->l->r = add(40);
root->l->r->r = add(60);
}

/*
* Adding node to binary tree
*/
node* add(int val)
{
ptr = (node*)malloc(sizeof(node));
if (ptr == NULL)
{
printf("Memory was not allocated");
return;
}
ptr->value = val;
ptr->l = NULL;
ptr->r = NULL;
return ptr;
}

/*
* Prints all the nodes of all levels of the binary tree
*/
void print()
{
int h, i;

h = height(root);
for (i = 0;i < h;i++)
{
printf("\nLEVEL %d  :", i);
printlevel(root, i, 0);
printf("\n");
}
}
/*
*Prints the nodes of a particular level
*/
void printlevel(node *n, int desired, int current)
{
if (n)
{
if (desired == current)
printf("%d\t", n->value);
else
{
printlevel(n->l, desired, current + 1);
printlevel(n->r, desired, current + 1);
}
}
}

/*
* Height of the binary tree
*/
int height(node *n)
{
int lheight, rheight;
if (n != NULL)
{
lheight = height(n->l);
rheight = height(n->r);
if (lheight > rheight)
return(lheight+1);
else
return(rheight+1);
}
}
 ETP 
 
 C Program to Convert Binary Tree to Binary Search Tree 
================================ EOPN
/* C Program to convert given binary tree to BST 
================================ EOKW
--------------------------------
output:
 
                    25                   |          25   
                  /    \                 |        /    \
                 27     19               |       17     55
                / \     / \              |      /  \    / \
              17  91   13 55             |    13   19  27  91
 
                 Binary Tree                  Binary Search Tree
--------------------------------

#include <stdio.h>
#include <stdlib.h>

struct node
{
int info;
struct node* left, *right;
};

int data[100];
int i = 0;

/*creates a new node */

struct node* createnode(int key)
{
struct node* newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;

return(newnode);
}

/* counts the number of nodes in a tree */

int count(struct node *n)
{
int c = 1;

if (n == NULL)
return 0;
else
{
c += count(n->left);
c += count(n->right);
return c;
}
}

/*
* Copies the nodes of Binary Tree in an array
*/
void binarytoarray(struct node * root, int data[], int *ptr)
{
if(root != NULL)
{
binarytoarray(root->left, data, ptr);
data[*ptr] = root->info;
(*ptr)++;
binarytoarray(root->right, data, ptr);
}
}

/*
* Copies the element of array to bst
*/
void arraytobst(int *arr, struct node *root, int *index)
{
if(root != NULL)
{
arraytobst(arr, root->left, index);
root->info = arr[i++];
arraytobst(arr, root->right, index);
}
}

int compare(const void *a, const void *b)
{
return *(int*)a-*(int*)b;
}

/*
* Inorder traversal of a tree
*/

void inorder(struct node *root)
{
if(root !=NULL)
{
inorder(root->left);
printf("%d\t",root->info);
inorder(root->right);
}
}

/*
* Converts binary tree to bst
*/
void binary_to_bst(struct node *root)
{
int n, i;

if (root == NULL)
return;
n = count(root);
i = 0;
binarytoarray(root, data, &i);
qsort(&data, n, sizeof(data[0]), compare);
i = 0;
arraytobst(data, root, &i);
}

/*
* Main Function
*/

int main()
{
int flag = 0;
struct node *newnode = createnode(25);
newnode->left = createnode(27);
newnode->right = createnode(19);
newnode->left->left = createnode(17);
newnode->left->right = createnode(91);
newnode->right->left = createnode(13);
newnode->right->right = createnode(55);

/* Sample Tree 1- Balanced Tree


25                   |          25
/    \                 |        /    \
27     19               |       17      55
/ \     / \              |      /  \    /  \
17  91   13 55             |    13   19  27   91

*/

printf("Inorder traversal of Input Binary Tree is\n");
inorder(newnode);
binary_to_bst(newnode);
printf("\nInorder traversal of the converted Binary Search Tree is\n");
inorder(newnode);
return 0;
}
 ETP 
 
 C Program to find the Total Columns/Vertical Lines of a given Binary Search Tree 
================================ EOPN
/* * C Program to find the Total Columns/Vertical Lines of a given  * Binary Search Tree     40   /  \  20   60 /  \    \10  30   80          \          90(40,60,80,20,30,90,10)    (Binary search tree)          
================================ EOKW
--------------------------------
output:
     40
    /  \
   20   60
  /  \    \                                         
10   30   80
            \
             90
$ cc tree41a.c
$ a.out
enter the number:40
enter the number:20
enter the number:60
enter the number:80
enter the number:90
enter the number:10
enter the number:30
enter the number:0
->10->20->30->40->60->80->90
total number of columns : 6
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode {
int value;
int col;
struct btnode *l;
struct btnode *r;
};

typedef struct btnode bt;

bt *root,*temp;
bt *new;
int min = 0, max = 0;

bt * create_node();
void display(bt *);
void insert(bt *, bt *);
void columns(bt *);

void main()
{
int num;

while (1)
{
printf("enter the number:");
scanf("%d", &num);
if (num == 0)
{
break;
}
create_node();
new->value = num;
if (root == NULL)
{
root = new;
root->col = 0;
}
else
{
insert(new,root);
}
}
display(root);
columns(root);
printf("\n total number of columns : %d",-min + max + 1);
}

/* creates new node */
bt * create_node()
{
new=(bt *)malloc(sizeof(bt));
new->l = NULL;
new->r = NULL;
}

/* inserts the node into tree */
void insert(bt * new , bt * list)
{
if (new->value>list->value)
{
if (list->r == NULL)
{
list->r = new;
new->col = list->col + 1;
}
else
{
insert (new,list->r);
}
}
if (new->value < list->value)
{
if (list->l == NULL)
{
list->l = new;
new->col = list->col - 1;
}
else
{
insert (new,list->l);
}
}
}

/* displays the elements in the tree using inorder */
void display(bt * list)
{
if (list == NULL)
{
return;
}
display(list->l);
printf("->%d", list->value);
display(list->r);
}

/* counts the number of columns in tree */
void columns(bt * list)
{
if (list == NULL)
{
return;
}
if (list->col < min)
{
min = list->col;
}
if (list->col > max)
{
max = list->col;
}
columns(list->l);
columns(list->r);
}
 ETP 
 
 C Program to Find the Sum of all Nodes in a Tree 
================================ EOPN
/* * C Program to Find the Sum of all Nodes in a Tree * *        50 *        / \ *     20  30 *    / \ *   70  80 *   / \   \ *  10 40   60 * 
================================ EOKW
--------------------------------
output:
$ gcc tree37.c
$ a.out
10
70
40
20
80
60
50
30
Depth of tree is 4
tree elements after modification are ----
0
50
0
260
60
0
310
0
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
}*root = NULL, *ptr, *temp;

// Function Prototypes
int find_depth(struct btnode *);
int modify_tree(struct btnode *);
void printout(struct btnode *);
struct btnode* newnode(int);

void main()
{
int d;

root  =  newnode(50);
root->l  =  newnode(20);
root->r  =  newnode(30);
root->l->l  =  newnode(70);
root->l->r  =  newnode(80);
root->l->r->r  =  newnode(60);
root->l->l->l  =  newnode(10);
root->l->l->r  =  newnode(40);
printout(root);
ptr = root;
d = find_depth(ptr);
printf("Depth of tree is %d\n",d);
printf("tree elements after modification are ----\n");
modify_tree(ptr);
printout(ptr);
}

// Create a node
struct btnode* newnode(int value)
{
struct btnode* node  =  (struct btnode*)malloc(sizeof(struct btnode));
node->value  =  value;
node->l  =  NULL;
node->r  =  NULL;
return(node);
}

// Function to find depth of a tree
int find_depth(struct btnode* tree)
{
int ldepth, rdepth;

if (tree == NULL)
return 0;
else
{
ldepth = find_depth(tree->l);
rdepth = find_depth(tree->r);
if (ldepth > rdepth)
return ldepth + 1;
else
return rdepth + 1;
}
}

// Function to modify the tree
int modify_tree(struct btnode *tree)
{
int i, original;

if (tree == NULL)
return 0;
original = tree->value;
tree->value = modify_tree(tree->l) + modify_tree(tree->r);
return tree->value + original;
}

// Function to print the elements of tree
void printout(struct btnode *tree)
{
if (tree->l)
printout(tree->l);
printf("%d\n", tree->value);
if (tree->r)
printout(tree->r);
}
 ETP 
 
 C Program to Construct a Tree & Perform Insertion, Deletion, Display 
================================ EOPN
/* * C Program to Construct a Tree & Perform Insertion, Deletion, Display  
================================ EOKW
--------------------------------
output:
$ gcc tree1.c
$ a.out
tree elements are
 
DISPLAYED IN INORDER
10->70->40->20->80->60->50->30
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
}*root = NULL;

// Function Prototype
void printout(struct btnode*);
struct btnode* newnode(int);

void main()
{
root=newnode(50);
root->l=newnode(20);
root->r=newnode(30);
root->l->l=newnode(70);
root->l->r=newnode(80);
root->l->r->r=newnode(60);
root->l->l->l=newnode(10);
root->l->l->r=newnode(40);
printf("tree elements are\n");
printf("\nDISPLAYED IN INORDER\n");
printout(root);
printf("\n");
}

// Create a node
struct btnode* newnode(int value)
{
struct btnode* node = (struct btnode*)malloc(sizeof(struct btnode));
node->value = value;
node->l = NULL;
node->r = NULL;
return(node);
}

// to display the tree in inorder
void printout (struct btnode *tree)
{
if (tree->l)
printout(tree->l);
printf("%d->", tree->value);
if (tree->r)
printout(tree->r);
}
 ETP 
 
 C Program to Check whether a Tree is a Binary Search Tree 
================================ EOPN
/* * C Program to Check whether a Tree is a Binary Search Tree  
================================ EOKW
--------------------------------
output:
$ cc tree8.c
$ a.out
TREE 1 Is BST
TREE 2 Not a BST
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int data;
struct node* left;
struct node* right;
};

static struct node *prev = NULL;

/*Function to check whether the tree is BST or not*/
int is_bst(struct node* root)
{
if (root)
{
if (!is_bst(root->left)) //moves towards the leftmost child of the tree and checks for the BST
return 0;
if (prev != NULL && root->data <= prev->data)
return 0;
prev = root;
return is_bst(root->right);    //moves the corresponding right child of the tree and checks for the BST
}
return 1;
}

struct node* newNode(int data)
{
struct node* node = (struct node*)malloc(sizeof(struct node));
node->data = data;
node->left = NULL;
node->right = NULL;

return(node);
}

int main()
{
/*
The input tree is as shown below
40
/ \
20        60
/ \       \
10        30      80
\
90
*/
struct node *root = newNode(40);
root->left        = newNode(20);
root->right       = newNode(60);
root->left->left  = newNode(10);
root->left->right = newNode(30);
root->right->right = newNode(80);
root->right->right->right = newNode(90);
if (is_bst(root))
printf("TREE 1 Is BST");
else
printf("TREE 1 Not a BST");
prev = NULL;
/*
The input tree is as shown below
50
/ \
20        30
/ \
70        80
/ \          \
10     40     60
*/
struct node *root1 = newNode(50);
root1->left  = newNode(20);
root1->right  = newNode(30);
root1->left->left  = newNode(70);
root1->left->right = newNode(80);
root1->left->left->right = newNode(40);
root1->left->left->leftt = newNode(90);
if (is_bst1(root1))
printf("TREE 2 Is BST");
else
printf("TREE 2 Not a BST");
return 0;
}
 ETP 
 
 C Program to Find the Nearest Sibling of a Node in a Tree 
================================ EOPN
/* * C Program to Construct a Tree & Perform Insertion, Deletion, Display  
================================ EOKW
--------------------------------
output:
$ gcc tree1.c
$ a.out
tree elements are
 
DISPLAYED IN INORDER
10->70->40->20->80->60->50->30
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
}*root = NULL;

// Function Prototype
void printout(struct btnode*);
struct btnode* newnode(int);

void main()
{
root=newnode(50);
root->l=newnode(20);
root->r=newnode(30);
root->l->l=newnode(70);
root->l->r=newnode(80);
root->l->r->r=newnode(60);
root->l->l->l=newnode(10);
root->l->l->r=newnode(40);
printf("tree elements are\n");
printf("\nDISPLAYED IN INORDER\n");
printout(root);
printf("\n");
}

// Create a node
struct btnode* newnode(int value)
{
struct btnode* node = (struct btnode*)malloc(sizeof(struct btnode));
node->value = value;
node->l = NULL;
node->r = NULL;
return(node);
}

// to display the tree in inorder
void printout (struct btnode *tree)
{
if (tree->l)
printout(tree->l);
printf("%d->", tree->value);
if (tree->r)
printout(tree->r);
}
 ETP 
 
 C Program to Print all the Paths from the Root to the Leaf in a Tree 
================================ EOPN
/* * C Program to Print all the Paths from the Root to the Leaf  * in a Tree  
================================ EOKW
--------------------------------
output:
$ cc tree20.c
$ a.out
40 -> 20 -> 10 ->
40 -> 20 -> 30 ->
40 -> 60 -> 80 -> 90 ->
--------------------------------
#include<stdio.h>
#include<stdlib.h>

struct node
{
int data;
struct node* left;
struct node* right;
};

void print_paths_recur(struct node* node, int path[], int path_len);
void print_array(int ints[], int len);

/*Function to store all the paths from the root node to all leaf nodes in  a array*/

void print_paths(struct node* node)
{
int path[1000];
print_paths_recur(node, path, 0);
}

/*Function which helps the print_path to recursively print all the nodes*/
void print_paths_recur(struct node* node, int path[], int path_len)
{
if (node == NULL)
return;

path[path_len] = node->data;
path_len++;

if (node->left == NULL && node->right == NULL)
{
print_array(path, path_len);
}
else
{
print_paths_recur(node->left, path, path_len);    //recursively calls the left node of the tree
print_paths_recur(node->right, path, path_len);    //recursively calls the right node of the tree
}
}

/*Function to print all the paths */
void print_array(int ints[], int len)
{
int i;
for (i = 0; i < len; i++)
{
printf("%d -> ", ints[i]);
}
printf("\n");
}

struct node* newnode(int data)
{
struct node* node = (struct node*) malloc(sizeof(struct node));
node->data = data;
node->left = NULL;
node->right = NULL;

return(node);
}

int main()
{
/*
The input tree is as shown below
40
/ \
20        60
/ \       \
10        30      80
\
90
*/
struct node *root = newnode(40);
root->left = newnode(20);
root->right = newnode(60);
root->left->left = newnode(10);
root->left->right = newnode(30);
root->right->right = newnode(80);
root->right->right->right = newnode(90);
print_paths(root);
return 0;
}
 ETP 
 
 C Program to Print only Nodes in Left SubTree 
================================ EOPN
/* * C Program to Print only Nodes in Left SubTree  
================================ EOKW
--------------------------------
output:
$ cc tree32.c
$ a.out
20->10->30->
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int data;
struct node* left;
struct node* right;
};

int queue[100];
int front = 0, rear = 0, val;

/*Function to traverse the tree using Breadth First Search*/
void bfs_traverse(struct node *node)
{
val = node->data;
if ((front< = rear)&&(node->data =  = queue[front]))
{
if (node->left != NULL)
queue[rear++] = node->left->data;
if (node->right != NULL)
queue[rear++] = node->right->data;
front++;
}
if (node->left != NULL)
{
bfs_traverse(node->left);
}
if (node->right != NULL)
{
bfs_traverse(node->right);
}
}

struct node* newnode(int data)
{
struct node* node  =  (struct node *)malloc(sizeof(struct node));
node->data  =  data;
node->left  =  NULL;
node->right  =  NULL;

return(node);
}

int main()
{
int i;

/*
The input tree is as shown below
40
/ \
20        60
/ \       \
10        30      80
\
90
*/
struct node *root  =  newnode(40);
root->left         =  newnode(20);
root->right        =  newnode(60);
root->left->left   =  newnode(10);
root->left->right  =  newnode(30);
root->right->right  =  newnode(80);
root->right->right->right  =  newnode(90);
queue[rear++] = root->left->data;
bfs_traverse(root->left);
for (i = 0;i < rear;i++)
printf("%d->", queue[i]);
return 0;
}
 ETP 
 
 C Program to Find 2 Nodes with Longest Distance and Display using Inorder Traversal 
================================ EOPN
/*  * C Program to Find 2 Nodes with Longest Distance and Display  * using Inorder Traversal *             40 *             /\ *           20 60 *           /\  \ *         10 30  80 *                 \ *                  90 
================================ EOKW
--------------------------------
output:
$ cc tree40.c
$ a.out
Enter the elements of the tree(enter 0 to exit)
40
20
30
50
60
80
90
0
elements in a tree in inorder are
20 -> 30 -> 40 -> 50 -> 60 -> 80 -> 90
longest path is
20 -> 90
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *left, *right;
};
typedef struct btnode node;

/* function prototypes */
void insert(node *, node *);
void inorder(node *);
int  height(node *);

node *temp, *root = NULL;

void main()
{
node *new = NULL ;
int num  = 1;

printf("Enter the elements of the tree(enter 0 to exit)\n");
while (1)
{
scanf("%d",  &num);
if (num == 0)
break;
new  =  malloc(sizeof(node));
new->left  =  new->right  =  NULL;
new->value  =  num;
if (root  == NULL)
root  =  new;
else
{
insert(new, root);
}
}
printf("elements in a tree in inorder are\n");
inorder(root);
height(root);
}

/* displaying nodes of a tree using inorder */
void inorder(node *root)
{
if (root != NULL)
{
inorder(root->left);
printf("%d -> ", root->value);
inorder(root->right);
}
}

/* inserting nodes into a tree */
void insert(node * new , node *root)
{
if (new->value>root->value)
{
if (root->right  == NULL)
root->right  =  new;
else
insert(new, root->right);
}
if (new->value<root->value)
{
if (root->left  == NULL)
root->left = new;
else
insert(new, root->left);
}
}

/* to find the longest path */
int height(node *temp)
{
temp = root;

if (temp  == NULL)
printf("tree is empty\n");
else
{
printf("\nlongest path is\n");
while (temp->left != NULL)
{
if (temp->left == NULL)
temp = temp->right;
else
temp = temp->left;
}
printf("%d ->", temp->value);
temp = root;
while (temp->right != NULL)
{
if (temp->right  == NULL)
temp = temp->left;
else
temp = temp->right;
}
printf(" %d", temp->value);
}
}
 ETP 
 
 C Program to Display the Nodes of a Tree using BFS Traversal 
================================ EOPN
/* * C Program to Display the Nodes of a Tree using BFS Traversal  *                 40 *                 /\ *                20 60 *                /\  \ *              10 30  80 *                      \ *                       90 
================================ EOKW
--------------------------------
output:
$ cc tree28.c
$ a.out
Enter the elements of the tree(enter 0 to exit)
40
20
10
30
60
70
80
0
elements in a tree in inorder are
40 -> 20 -> 60 -> 10 -> 30 -> 70 -> 80
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *left, *right;
};
typedef struct btnode node;

/* function declarations */
void insert(node *, node *);
void bfs_traverse(node *);

/*global declarations */
node *root = NULL;
int val, front = 0, rear = -1, i;
int queue[20];

void main()
{
node *new = NULL ;
int num = 1;
printf("Enter the elements of the tree(enter 0 to exit)\n");
while (1)
{
scanf("%d",  &num);
if (num  ==  0)
break;
new = malloc(sizeof(node));
new->left = new->right = NULL;
new->value = num;
if (root == NULL)
root = new;
else
{
insert(new, root);
}
}
printf("elements in a tree in inorder are\n");
queue[++rear] = root->value;
bfs_traverse(root);
for (i = 0;i <= rear;i++)
printf("%d -> ", queue[i]);
printf("%d\n", root->right->right->right->value);
}

/* inserting nodes of a tree */
void insert(node * new , node *root)
{
if (new->value>root->value)
{
if (root->right == NULL)
root->right = new;
else
insert (new, root->right);
}
if (new->value < root->value)
{
if (root->left  ==  NULL)
root->left = new;
else
insert (new, root->left);
}
}

/* displaying elements using BFS traversal */
void bfs_traverse(node *root)
{
val = root->value;
if ((front <= rear)&&(root->value == queue[front]))
{
if (root->left != NULL)
queue[++rear] = root->left->value;
if (root->right != NULL || root->right  ==  NULL)
queue[++rear] = root->right->value;
front++;
}
if (root->left != NULL)
{
bfs_traverse(root->left);
}
if (root->right != NULL)
{
bfs_traverse(root->right);
}
}
 ETP 
 
 C Program to Search for a Particular Value in a Binary Tree 
================================ EOPN
/* * C Program to Search for a Particular Value in a Binary Tree *                  50 *                  /\ *                20  30 *                /\                                *              70 80 *              /\   \ *            10 40  60 
================================ EOKW
--------------------------------
output:
$ cc tree3.c
$ a.out
The elements of Binary tree are:10->70->40->20->80->60->50->30
Enter the value to be searched:60
Element present in the binary tree.
 
$ ./a.out
The elements of Binary tree are:10->70->40->20->80->60->50->30
Enter the value to be searched:99
Element not present in the binary tree
--------------------------------

#include <stdio.h>
#include <malloc.h>
/* Structure to create the binary tree */

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
};

struct btnode *root = NULL;
int flag;

/* Function Prototypes */
void in_order_traversal(struct btnode *);
void in_order_search(struct btnode *,int);
struct btnode *newnode(int);

void main()
{
/* Inserting elements in the binary tree */
int search_val;
root = newnode(50);
root->l = newnode(20);
root->r = newnode(30);
root->l->l = newnode(70);
root->l->r = newnode(80);
root->l->l->l = newnode(10);
root->l->l->r = newnode(40);
root->l->r->r = newnode(60);

printf("The elements of Binary tree are:");
in_order_traversal(root);
printf("Enter the value to be searched:");
scanf("%d", &search_val);
in_order_search(root, search_val);
if (flag  =  =  0)    // flag to check if the element is present in the tree or not
{
printf("Element not present in the binary tree\n");
}
}

/* Code to dynamically create new nodes */
struct btnode* newnode(int value)
{
struct btnode *temp = (struct btnode *)malloc(sizeof(struct btnode));
temp->value = value;
temp->l = NULL;
temp->r = NULL;
return temp;
}

/* Code to display the elements of the binary tree */

void in_order_traversal(struct btnode *p)
{
if (!p)
{
return;
}
in_order_traversal(p->l);
printf("%d->", p->value);
in_order_traversal(p->r);
}

/* Code to search for a particular element in the tree */
void in_order_search(struct btnode *p, int val)
{
if (!p)
{
return;
}
in_order_search(p->l, val);
if(p->value == val)
{
printf("\nElement present in the binary tree.\n");
flag = 1;
}
in_order_search(p->r, val);
}
 ETP 
 
 C Program to Find the Sum of All Nodes in a Binary Tree 
================================ EOPN
/* C Program for finding the sum of all the nodes in a Tree 
================================ EOKW
--------------------------------
output:
                    25
                  /    \  
                 27     19   
                / \     / \ 
              17  91   13 55
--------------------------------
#include <stdio.h>
#include <stdlib.h>
struct node
{
int info;
struct node *left, *right;
};
struct node *createnode(int key)
{
struct node *newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;
return(newnode);
}
int sumofnodes(struct node *root)
{
int rightsubtree, leftsubtree, sum = 0;
if(root != NULL)
{
leftsubtree = sumofnodes(root->left);
rightsubtree = sumofnodes(root->right);
sum = (root->info) + leftsubtree + rightsubtree;
return sum;
}
}
/*
* Main Function
*/
int main()
{
/* Creating first Tree. */
struct node *newnode = createnode(25);
newnode->left = createnode(27);
newnode->right = createnode(19);
newnode->left->left = createnode(17);
newnode->left->right = createnode(91);
newnode->right->left = createnode(13);
newnode->right->right = createnode(55);
/* Sample Tree 1:
*                25
*             /    \
*            27     19
*           / \     / \
*         17  91   13 55
*/
printf("Sum of nodes in tree 1 = %d", sumofnodes(newnode));
printf("\n");

/* Creating second Tree. */
struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);
/* Sample Tree 2:   Right Skewed Tree (Unbalanced).
*               1
*                \
*                 2
*                  \
*                   3
*                    \
*                     4
*                      \
*                       5
*/
printf("Sum of nodes in tree 2 = %d", sumofnodes(node));
printf("\n");

/* Creating third Tree. */
struct node *root = createnode(15);
/* Sample Tree 3: Tree having just one root node.
*              15
*/
printf("Sum of nodes in tree 3 = %d", sumofnodes(root));
printf("\n");
return 0;
}
 ETP 
 
 C Program to Construct a Binary Search Tree and perform deletion and inorder traversal 
================================ EOPN
/*  * C Program to Construct a Binary Search Tree and perform deletion, inorder traversal on it 
================================ EOKW
--------------------------------
output:
$ cc tree43.c
$ a.out
OPERATIONS ---
1 - Insert an element into tree
2 - Delete an element from the tree
3 - Inorder Traversal
4 - Preorder Traversal
5 - Postorder Traversal
6 - Exit
 
Enter your choice : 1
Enter data of node to be inserted : 40
 
Enter your choice : 1
Enter data of node to be inserted : 20
 
Enter your choice : 1
Enter data of node to be inserted : 10
 
Enter your choice : 1
Enter data of node to be inserted : 30
 
Enter your choice : 1
Enter data of node to be inserted : 60
 
Enter your choice : 1
Enter data of node to be inserted : 80
 
Enter your choice : 1
Enter data of node to be inserted : 90
 
Enter your choice : 3
10 -> 20 -> 30 -> 40 -> 60 -> 80 -> 90 ->
 
            40
            /\
           /  \
         20    60
         / \    \
       10  30   80
                  \
                  90
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *l;
struct btnode *r;
}*root = NULL, *temp = NULL, *t2, *t1;

void delete1();
void insert();
void delete();
void inorder(struct btnode *t);
void create();
void search(struct btnode *t);
void preorder(struct btnode *t);
void postorder(struct btnode *t);
void search1(struct btnode *t,int data);
int smallest(struct btnode *t);
int largest(struct btnode *t);

int flag = 1;

void main()
{
int ch;

printf("\nOPERATIONS ---");
printf("\n1 - Insert an element into tree\n");
printf("2 - Delete an element from the tree\n");
printf("3 - Inorder Traversal\n");
printf("4 - Preorder Traversal\n");
printf("5 - Postorder Traversal\n");
printf("6 - Exit\n");
while(1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
insert();
break;
case 2:
delete();
break;
case 3:
inorder(root);
break;
case 4:
preorder(root);
break;
case 5:
postorder(root);
break;
case 6:
exit(0);
default :
printf("Wrong choice, Please enter correct choice  ");
break;
}
}
}

/* To insert a node in the tree */
void insert()
{
create();
if (root == NULL)
root = temp;
else
search(root);
}

/* To create a node */
void create()
{
int data;

printf("Enter data of node to be inserted : ");
scanf("%d", &data);
temp = (struct btnode *)malloc(1*sizeof(struct btnode));
temp->value = data;
temp->l = temp->r = NULL;
}

/* Function to search the appropriate position to insert the new node */
void search(struct btnode *t)
{
if ((temp->value > t->value) && (t->r != NULL))      /* value more than root node value insert at right */
search(t->r);
else if ((temp->value > t->value) && (t->r == NULL))
t->r = temp;
else if ((temp->value < t->value) && (t->l != NULL))    /* value less than root node value insert at left */
search(t->l);
else if ((temp->value < t->value) && (t->l == NULL))
t->l = temp;
}

/* recursive function to perform inorder traversal of tree */
void inorder(struct btnode *t)
{
if (root == NULL)
{
printf("No elements in a tree to display");
return;
}
if (t->l != NULL)
inorder(t->l);
printf("%d -> ", t->value);
if (t->r != NULL)
inorder(t->r);
}

/* To check for the deleted node */
void delete()
{
int data;

if (root == NULL)
{
printf("No elements in a tree to delete");
return;
}
printf("Enter the data to be deleted : ");
scanf("%d", &data);
t1 = root;
t2 = root;
search1(root, data);
}

/* To find the preorder traversal */
void preorder(struct btnode *t)
{
if (root == NULL)
{
printf("No elements in a tree to display");
return;
}
printf("%d -> ", t->value);
if (t->l != NULL)
preorder(t->l);
if (t->r != NULL)
preorder(t->r);
}

/* To find the postorder traversal */
void postorder(struct btnode *t)
{
if (root == NULL)
{
printf("No elements in a tree to display ");
return;
}
if (t->l != NULL)
postorder(t->l);
if (t->r != NULL)
postorder(t->r);
printf("%d -> ", t->value);
}

/* Search for the appropriate position to insert the new node */
void search1(struct btnode *t, int data)
{
if ((data>t->value))
{
t1 = t;
search1(t->r, data);
}
else if ((data < t->value))
{
t1 = t;
search1(t->l, data);
}
else if ((data==t->value))
{
delete1(t);
}
}

/* To delete a node */
void delete1(struct btnode *t)
{
int k;

/* To delete leaf node */
if ((t->l == NULL) && (t->r == NULL))
{
if (t1->l == t)
{
t1->l = NULL;
}
else
{
t1->r = NULL;
}
t = NULL;
free(t);
return;
}

/* To delete node having one left hand child */
else if ((t->r == NULL))
{
if (t1 == t)
{
root = t->l;
t1 = root;
}
else if (t1->l == t)
{
t1->l = t->l;

}
else
{
t1->r = t->l;
}
t = NULL;
free(t);
return;
}

/* To delete node having right hand child */
else if (t->l == NULL)
{
if (t1 == t)
{
root = t->r;
t1 = root;
}
else if (t1->r == t)
t1->r = t->r;
else
t1->l = t->r;
t == NULL;
free(t);
return;
}

/* To delete node having two child */
else if ((t->l != NULL) && (t->r != NULL))
{
t2 = root;
if (t->r != NULL)
{
k = smallest(t->r);
flag = 1;
}
else
{
k =largest(t->l);
flag = 2;
}
search1(root, k);
t->value = k;
}

}

/* To find the smallest element in the right sub tree */
int smallest(struct btnode *t)
{
t2 = t;
if (t->l != NULL)
{
t2 = t;
return(smallest(t->l));
}
else
return (t->value);
}

/* To find the largest element in the left sub tree */
int largest(struct btnode *t)
{
if (t->r != NULL)
{
t2 = t;
return(largest(t->r));
}
else
return(t->value);
}
 ETP 
 
 C Program to Count Number of Leaf Node in a Tree 
================================ EOPN
/* C Program to find the number of leaf nodes in a Tree 
================================ EOKW
--------------------------------
output:
If the input tree is      
                    25
                  /    \
                 27     19
                / \     / \
              17  91   13 55
then number of leaf nodes in this tree will be 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int info;
struct node* left, *right;

};

/*
* Function to create new nodes
*/

struct node* createnode(int key)
{
struct node* newnode = (struct node*)malloc(sizeof(struct node));
newnode->info = key;
newnode->left = NULL;
newnode->right = NULL;

return(newnode);
}

/*
* Function to count number of leaf nodes
*/

int count = 0;
int leafnodes(struct node* newnode)
{

if(newnode != NULL)
{
leafnodes(newnode->left);
if((newnode->left == NULL) && (newnode->right == NULL))
{
count++;
}
leafnodes(newnode->right);
}
return count;

}

/*
* Main Function
*/

int main()
{
/* Creating first Tree.*/

struct node *newnode = createnode(25);
newnode->left = createnode(27);
newnode->right = createnode(19);
newnode->left->left = createnode(17);
newnode->left->right = createnode(91);
newnode->right->left = createnode(13);
newnode->right->right = createnode(55);

/* Sample Tree 1- Balanced Tree


25
/    \
27     19
/ \     / \
17  91   13 55

*/
printf("Number of leaf nodes in first Tree are\t%d\n",leafnodes(newnode));
count = 0;

struct node *node = createnode(1);
node->right = createnode(2);
node->right->right = createnode(3);
node->right->right->right = createnode(4);
node->right->right->right->right = createnode(5);

/* Sample Tree 2-   Right Skewed Tree (Unbalanced).

1
\
2
\
3
\
4
\
5
*/

printf("\nNumber of leaf nodes in second tree are\t%d\n",leafnodes(node));
count = 0;

/*Creating third Tree. */

struct node *root = createnode(15);

/* Sample Tree 3-  Tree having just one root node.

15
*/

printf("\nNumber of leaf nodes in third tree are\t%d",leafnodes(root));

return 0;
}
 ETP 
 
 C Program to Find Nodes which are at Maximum Distance in Binary Tree 
================================ EOPN
/*  * C Program to Find Nodes which are at Maximum Distance in Binary Tree 
================================ EOKW
--------------------------------
output:
$ cc tree19.c
$ a.out
Program to find nodes at maximum distance
OPERATIONS ----
   1] Insert 
   2] Display nodes 
   3] Exit 
   Enter your choice : 1
   Enter the data of node : 50
 
   Enter your choice : 1
   Enter the data of node : 30
 
   Enter your choice : 1
   Enter the data of node : 20
 
   Enter your choice : 1
   Enter the data of node : 40
 
   Enter your choice : 1
   Enter the data of node : 35
 
   Enter your choice : 1
   Enter the data of node : 100
 
   Enter your choice : 1
   Enter the data of node : 70
 
   Enter your choice : 1
   Enter the data of node : 120
 
   Enter your choice : 1
   Enter the data of node : 140
 
   Enter your choice : 2
   Maximum distance nodes 
   Nodes     Distance 
    35      3 
    140      3 
 
 
            50
            /\
           /  \
         30    100
         / \   / \
       20  40 70 120
           /       \
          35       140
 
    Enter your choice : 3
 
 
   $ ./a.out
 
   Program to find nodes at maximum distance
      OPERATIONS ----
   1] Insert 
   2] Display nodes 
   3] Exit 
   Enter your choice : 1
   Enter the data of node : 40
 
   Enter your choice : 1
   Enter the data of node : 20
 
   Enter your choice : 1
   Enter the data of node : 60
 
   Enter your choice : 1
   Enter the data of node : 10
 
   Enter your choice : 1
   Enter the data of node : 30
 
   Enter your choice : 1
   Enter the data of node : 80
 
   Enter your choice : 1
   Enter the data of node : 90
 
   Enter your choice : 2
   Maximum distance nodes 
      Nodes     Distance 
       90     3 
   Enter your choice : 3
 
 
 
            40
            /\
           /  \
         20    60
         / \    \
       10  30   80
                  \
                  90
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct btnode
{
int value;
struct btnode *r,*l;
} *root = NULL, *temp = NULL;

void create();
void insert();
void add(struct btnode *t);
void maxdistance(struct btnode *t);

int count = 0, max = 0, v[100] = {0}, z = 0, max2, max1[100] = {0};

void main()
{
int ch, i;

printf("Program to find nodes at maximum distance");
printf("\n  OPERATIONS ----");
printf("\n1] Insert ");
printf("\n2] Display nodes ");
printf("\n3] Exit ");
while (1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
insert();
break;
case 2:
max = 0;
count = 0;
maxdistance(root);
for (i = 1; i < z; i++)
{
max2 = max1[0];
if (max2 < max1[i])
max2 = max1[i];
}
printf("Maximum distance nodes \nNodes\t Distance ");
for (i = 0; i < z; i++)
{
if (max2 == max1[i])
printf("\n %d\t  %d ",v[i],max2);
}
break;
case 3:
exit(0);
default :
printf("Wrong choice, Please enter correct choice  ");
break;
}
}
}

/* To create a new node with the data from the user */
void create()
{
int data;

printf("Enter the data of node : ");
scanf("%d", &data);
temp = (struct btnode* ) malloc(1*(sizeof(struct btnode)));
temp->value = data;
temp->l = temp->r = NULL;
}

/* To check for root node and then create it */
void insert()
{
create();

if (root == NULL)
root = temp;
else
add(root);
}

/* Search for the appropriate position to insert the new node */
void add(struct btnode *t)
{
if ((temp->value > t->value) && (t->r!=NULL))    /* value more than root node value insert at right */
add(t->r);
else if ((temp->value > t->value) && (t->r==NULL))
t->r = temp;
else if ((temp->value < t->value) && (t->l!=NULL))   /* value less than root node value insert at left */
add(t->l);
else if ((temp->value < t->value) && (t->l==NULL))
t->l = temp;
}

/* Function to find the max distance nodes */
void maxdistance(struct btnode *t)
{
if (t->l!=NULL)
{
count++;            /* to count the number of nodes in between root and leaf */
maxdistance(t->l);
}
if (max < count)
max = count;
if (max == count)
{
max1[z] = max;
v[z] = t->value;
z++;
}
if (t->r != NULL)
{
count++;
maxdistance(t->r);
}
count--;
}
 ETP 
 
 C Program to Create a File & Store Information 
================================ EOPN
/* * C program to create a file called emp.rec and store information * about a person, in terms of his name, age and salary. 
================================ EOKW
--------------------------------
output:
$ cc pgm95.c
$ a.out
Enter the name
raj
Enter the age
40
Enter the salary
4000000
--------------------------------
#include <stdio.h>

void main()
{
FILE *fptr;
char name[20];
int age;
float salary;

/*  open for writing */
fptr = fopen("emp.rec", "w");

if (fptr == NULL)
{
printf("File does not exists \n");
return;
}
printf("Enter the name \n");
scanf("%s", name);
fprintf(fptr, "Name    = %s\n", name);
printf("Enter the age\n");
scanf("%d", &age);
fprintf(fptr, "Age     = %d\n", age);
printf("Enter the salary\n");
scanf("%f", &salary);
fprintf(fptr, "Salary  = %.2f\n", salary);
fclose(fptr);
}
 ETP 
 
 C Program to Illustrate Reading of Data from a File 
================================ EOPN
/* * C program to illustrate how a file stored on the disk is read 
================================ EOKW
--------------------------------
output:
$ cc pgm96.c
$ a.out
Enter the filename to be opened
pgm95.c
/*
 * C program to create a file called emp.rec and store information
 * about a person, in terms of his name, age and salary.
 */
 
#include <stdio.h>
 
void main()
{
    FILE *fptr;
    char name[20];
    int age;
    float salary;
 
    fptr = fopen ("emp.rec", "w"); /* open for writing*/
 
    if (fptr == NULL)
    {
        printf("File does not exists \n");
        return;
    }
    printf("Enter the name \n");
    scanf("%s", name);
    fprintf(fptr, "Name    = %s\n", name);
    printf("Enter the age \n");
    scanf("%d", &age);
    fprintf(fptr, "Age     = %d\n", age);
    printf("Enter the salary \n");
    scanf("%f", &salary);
    fprintf(fptr, "Salary  = %.2f\n", salary);
    fclose(fptr);
}
--------------------------------
#include <stdio.h>
#include <stdlib.h>

void main()
{
FILE *fptr;
char filename[15];
char ch;

printf("Enter the filename to be opened \n");
scanf("%s", filename);
/*  open the file for reading */
fptr = fopen(filename, "r");
if (fptr == NULL)
{
printf("Cannot open file \n");
exit(0);
}
ch = fgetc(fptr);
while (ch != EOF)
{
printf ("%c", ch);
ch = fgetc(fptr);
}
fclose(fptr);
}
 ETP 
 
C Program to Delete a specific Line from a Text File
================================ EOPN
/* * C Program Delete a specific Line from a Text File 
================================ EOKW
--------------------------------
output:
 
$ cc pgm47.c
$ a.out
Enter file name: pgm1.c
/*
 * C PROGRAM TO CONVERSION FROM Decimal to hexadecimal
 */
 
#include<stdio.h>
int main()
{
    long int decimalnum, remainder, quotient;
    int i = 1, j, temp;
    char hexadecimalnum[100];
 
    printf("Enter any decimal number: ");
    scanf("%ld", &decimalnum);
 
    quotient = decimalnum;
 
    while (quotient != 0)
    {
        temp = quotient % 16;
        //To convert integer into character
        if (temp < 10)
            temp = temp + 48;
        else
            temp = temp + 55;
 
        hexadecimalnum[i++] = temp;
        quotient = quotient / 16;
   }
 
    printf("Equivalent hexadecimal value of decimal number %d: ", decimalnum);
    for (j = i - 1; j > 0; j--)
        printf("%c", hexadecimalnum[j]);
    return 0;
}
 
 
 Enter line number of the line to be deleted: 10
 
 The contents of file after being modified are as follows:
*
 * C PROGRAM TO CONVERSION FROM Decimal to hexadecimal
 */
 
#include<stdio.h>
int main()
{
    long int decimalnum, remainder, quotient;
    int i = 1, j, temp;
 
    printf("Enter any decimal number: ");
    scanf("%ld", &decimalnum);
 
    quotient = decimalnum;
 
    while (quotient != 0)
    {
        temp = quotient % 16;
        //To convert integer into character
        if (temp < 10)
            temp = temp + 48;
        else
            temp = temp + 55;
 
        hexadecimalnum[i++] = temp;
        quotient = quotient / 16;
   }
 
    printf("Equivalent hexadecimal value of decimal number %d: ", decimalnum);
    for (j = i - 1; j > 0; j--)
        printf("%c", hexadecimalnum[j]);
    return 0;
}
--------------------------------
#include <stdio.h>

int main()
{
FILE *fileptr1, *fileptr2;
char filename[40];
char ch;
int delete_line, temp = 1;

printf("Enter file name: ");
scanf("%s", filename);
//open file in read mode
fileptr1 = fopen(filename, "r");
ch = getc(fileptr1);
`  while (ch != EOF)
{
printf("%c", ch);
ch = getc(fileptr1);
}
//rewind
rewind(fileptr1);
printf(" \n Enter line number of the line to be deleted:");
scanf("%d", &delete_line);
//open new file in write mode
fileptr2 = fopen("replica.c", "w");
ch = getc(fileptr1);
while (ch != EOF)
{
ch = getc(fileptr1);
if (ch == '\n')
temp++;
//except the line to be deleted
if (temp != delete_line)
{
//copy all lines in file replica.c
putc(ch, fileptr2);
}
}
fclose(fileptr1);
fclose(fileptr2);
remove(filename);
//rename the file replica.c to original name
rename("replica.c", filename);
printf("\n The contents of file after being modified are as follows:\n");
fileptr1 = fopen(filename, "r");
ch = getc(fileptr1);
while (ch != EOF)
{
printf("%c", ch);
ch = getc(fileptr1);
}
fclose(fileptr1);
return 0;
}
 ETP 
 
C Program to Replace a specified Line in a Text File
================================ EOPN
/* * C Program to Replace a specified Line in a Text File 
================================ EOKW
--------------------------------
output:
$ cc pgm48.c
$ a.out
Enter file name: pgm3.c
/*
 * C Program to Convert Octal to Decimal
 */
 
#include <stdio.h>
#include <math.h>
 
int main()
{
 
    long int octal, decimal = 0;
    int i = 0;
 
    printf("Enter any octal number: ");
    scanf("%ld", &octal);
    while (octal != 0)
    {
        decimal =  decimal +(octal % 10)* pow(8, i++);
        octal = octal / 10;
    }
    printf("Equivalent decimal value: %ld",decimal);
    return 0;
}
 
Enter line number to be deleted and replaced 13 replaced
Enter new text
/*
 * C Program to Convert Octal to Decimal
 */
 
#include <stdio.h>
#include <math.h>
 
int main()
{
 
    long int octal, decimal = 0;
    int i = 0;
 replaced
    printf("Enter any octal number: ");
    scanf("%ld", &octal);
    while (octal != 0)
    {
        decimal =  decimal +(octal % 10)* pow(8, i++);
        octal = octal / 10;
    }
    printf("Equivalent decimal value: %ld",decimal);
    return 0;
}
--------------------------------
#include <stdio.h>

int main(void)
{
FILE *fileptr1, *fileptr2;
char filechar[40];
char c;
int delete_line, temp = 1;

printf("Enter file name: ");
scanf("%s", filechar);
fileptr1 = fopen(filechar, "r");
c = getc(fileptr1);
//print the contents of file .
while (c != EOF)
{
printf("%c", c);
c = getc(fileptr1);
}
printf(" \n Enter line number to be deleted and replaced");
scanf("%d", &delete_line);
//take fileptr1 to start point.
rewind(fileptr1);
//open replica.c in write mode
fileptr2 = fopen("replica.c", "w");
c = getc(fileptr1);
while (c != EOF)
{
if (c == 'n')
{
temp++;
}
//till the line to be deleted comes,copy the content to other
if (temp != delete_line)
{
putc(c, fileptr2);
}
else
{
while ((c = getc(fileptr1)) != 'n')
{
}
//read and skip the line ask for new text
printf("Enter new text");
//flush the input stream
fflush(stdin);
putc('n', fileptr2);
//put 'n' in new file
while ((c = getchar()) != 'n')
putc(c, fileptr2);
//take the data from user and place it in new file
fputs("n", fileptr2);
temp++;
}
//continue this till EOF is encountered
c = getc(fileptr1);
}
fclose(fileptr1);
fclose(fileptr2);
remove(filechar);
rename("replica.c", filechar);
fileptr1 = fopen(filechar, "r");
//reads the character from file
c = getc(fileptr1);
//until last character of file is encountered
while (c != EOF)
{
printf("%c", c);
//all characters are printed
c = getc(fileptr1);
}
fclose(fileptr1);
return 0;
}
 ETP 
 
C Program to Find the Number of Lines in a Text File
================================ EOPN
/* * C Program to Find the Number of Lines in a Text File 
================================ EOKW
--------------------------------
output:
$ cc pgm49.c
$ a.out
Enter file name: pgm2.c
There are 43 lines in pgm2.c  in a file
--------------------------------
#include <stdio.h>

int main()
{
FILE *fileptr;
int count_lines = 0;
char filechar[40], chr;

printf("Enter file name: ");
scanf("%s", filechar);
fileptr = fopen(filechar, "r");
//extract character from file and store in chr
chr = getc(fileptr);
while (chr != EOF)
{
//Count whenever new line is encountered
if (chr == 'n')
{
count_lines = count_lines + 1;
}
//take next character from file.
chr = getc(fileptr);
}
fclose(fileptr); //close file.
printf("There are %d lines in %s  in a file\n", count_lines, filechar);
return 0;
}
 ETP 
 
C Program to Append the Content of File at the end of Another
================================ EOPN
/* * C Program to Append the Content of File at the end of Another 
================================ EOKW
--------------------------------
output:
$ cc pgm47.c
$ a.out
Enter name of first file a.txt
Enter name of second file b.txt
Enter name to store merged file merge.txt
Two files merged merge.txt successfully.
--------------------------------
#include <stdio.h>
#include <stdlib.h>

main()
{
FILE *fsring1, *fsring2, *ftemp;
char ch, file1[20], file2[20], file3[20];

printf("Enter name of first file ");
gets(file1);
printf("Enter name of second file ");
gets(file2);
printf("Enter name to store merged file ");
gets(file3);
fsring1 = fopen(file1, "r");
fsring2 = fopen(file2, "r");
if (fsring1 == NULL || fsring2 == NULL)
{
perror("Error has occured");
printf("Press any key to exit...\n");
exit(EXIT_FAILURE);
}
ftemp = fopen(file3, "w");
if (ftemp == NULL)
{
perror("Error has occures");
printf("Press any key to exit...\n");
exit(EXIT_FAILURE);
}
while ((ch = fgetc(fsring1)) != EOF)
fputc(ch, ftemp);
while ((ch = fgetc(fsring2) ) != EOF)
fputc(ch, ftemp);
printf("Two files merged  %s successfully.\n", file3);
fclose(fsring1);
fclose(fsring2);
fclose(ftemp);
return 0;
}
 ETP 
 
C Program that Merges Lines Alternatively from 2 Files & Print Result
================================ EOPN
/* * C Program that Merges Lines Alternatively from 2 Files & Print Result 
================================ EOKW
--------------------------------
output:
$ cc pgm51.c
$ a.out
enter the name of file 1
c.txt
enter the name of file 2
a.txt
$ vi merge2.txt
All participants will be provided with 1:1 Linux Systems for Lab work. If participants want, they can bring their own laptops with Linux in it. This enable them to do lot of quality assignments even Sanfoundry internship programs are great learning opportunities.
Students with proven credentials only are enrolled for this program and the duration of these programs ranges from 2-6 months full t after the classes are over. If they have Windows, we install virtualization software and Ubuntu Linux virtual appliance on top of windows system.
ime. Student must be passionate about Technology topics. As part of Sanfoundry's biggest open learning initiative, we are looking for interns (student or working professional) in following technolog
 
 number of lines = 4
 number of words is = 114
--------------------------------
#include<stdio.h>
main()
{
char file1[10], file2[10];

puts("enter the name of file 1");      /*getting the names of file to be concatenated*/
scanf("%s", file1);
puts("enter the name of file 2");
scanf("%s", file2);
FILE *fptr1, *fptr2, *fptr3;
fptr1=fopen(file1, "r");             /*opening the files in read only mode*/
fptr2=fopen(file2, "r");
fptr3=fopen("merge2.txt", "w+");   /*opening a new file in write,update mode*/
char str1[200];
char ch1, ch2;
int n = 0, w = 0;
while (((ch1=fgetc(fptr1)) != EOF) && ((ch2 = fgetc(fptr2)) != EOF))
{
if (ch1 != EOF)             /*getting lines in alternately from two files*/
{
ungetc(ch1, fptr1);
fgets(str1, 199, fptr1);
fputs(str1, fptr3);
if (str1[0] != 'n')
n++;      /*counting no. of lines*/
}
if (ch2 != EOF)
{
ungetc(ch2, fptr2);
fgets(str1, 199, fptr2);
fputs(str1, fptr3);
if (str1[0] != 'n')
n++;        /*counting no.of lines*/
}
}
rewind(fptr3);
while ((ch1 = fgetc(fptr3)) != EOF)       /*countig no.of words*/
{
ungetc(ch1, fptr3);
fscanf(fptr3, "%s", str1);
if (str1[0] != ' ' || str1[0] != 'n')
w++;
}
fprintf(fptr3, "\n\n number of lines = %d n number of words is = %d\n", n, w - 1);
/*appendig comments in the concatenated file*/
fclose(fptr1);
fclose(fptr2);
fclose(fptr3);
}
 ETP 
 
C Program to List Files in Directory
================================ EOPN
/* * C Program to List Files in Directory 
================================ EOKW
--------------------------------
output:
$ cc pgm59.c
$ a.out
.
..
 b.txt
 pgm2.c
 pgm5.c
1
a.out
a.txt
b.txt
pgm.c
pgm1.c
pgm10.c
pgm11.c
pgm12.c
pgm13.c
pgm14.c
pgm15.c
pgm16.c
pgm17.c
pgm18.c
pgm19.c
pgm2.c
pgm20.c
pgm21.c
pgm22.c
pgm23.c
pgm24.c
pgm25.c
pgm26.c
pgm27.c
pgm28.c
pgm29.c
pgm3.c
pgm30.c
pgm31.c
pgm32.c
pgm33.c
pgm34.c
pgm35.c
pgm36.c
pgm37.c
pgm38.c
pgm39.c
pgm4.c
pgm40.c
pgm41.c
pgm42.c
pgm43.c
pgm44.c
pgm45.c
pgm46.c
pgm47.c
pgm48.c
pgm49.c
pgm5.c
pgm50.c
pgm51.c
pgm52.c
pgm53.c
pgm54.c
pgm55.c
pgm56.c
pgm57.c
pgm58.c
pgm59.c
pgm6.c
pgm7.c
pgm8.c
pgm9.c
--------------------------------
#include <dirent.h>
#include <stdio.h>

int main(void)
{
DIR *d;
struct dirent *dir;
d = opendir(".");
if (d)
{
while ((dir = readdir(d)) != NULL)
{
printf("%s\n", dir->d_name);
}
closedir(d);
}
return(0);
}
 ETP 
 
 C Program to Find Sum of Numbers given in Command Line Arguments Recursively 
================================ EOPN
/*
 * C Program to Find Sum of Numbers given in Command Line Arguments 
 * Recursively
 
================================ EOKW
--------------------------------
output:
 
$ cc arg4.c
$ a.out 1 2 3 4
sum is 10
--------------------------------

#include <stdio.h>
 
int count, s = 0;
void sum(int *, int *);
 
void main(int argc, char *argv[])
{
    int i, ar[argc];
    count = argc;
    for (i = 1; i < argc; i++)
    {
        ar[i - 1] = atoi(argv[i]);
    }
    sum(ar, ar + 1);
    printf("%d", s);
}
 
/* computes sum of two numbers recursively 
 ETP 
 
 C Program to Display the Function Names defined in C Source File 
================================ EOPN
/* * C program to Display the Function Names defined in C Source File 
================================ EOKW
--------------------------------
output:
$ cc file9.c
$ a.out 
 
File Opened to display function names :
main
check
display
--------------------------------
#include <stdio.h>
#include <string.h>

void check(char *c,int p1, int p2);
void display(char *c, int p1);

void main(int argc, char **argv)
{
FILE *fp;
char ch[100];
char *pos1, *pos2, *pos3;

fp=fopen(argv[1], "r");
if (fp == NULL)
{
printf("\nFile unable to open");
return;
}
else
printf("\nFile Opened to display function names :\n");
while (1)
{
if ((fgets(ch, 100, fp)) != NULL)
{
if ((strstr(ch, "/*")) == NULL)
{
pos1 = strchr(ch, '(');                /* check opening brace */
if (pos1)
{
pos2 = strchr(ch,')');            /* check oclosing brace */
if (pos2)
{
pos3 = strchr(ch,';');        /* check for semicolon */
if ((pos1 < pos2) && (pos3 == NULL) || (pos3 < pos1))
{
check(ch, pos1 - ch, pos2 - ch);
}
else    continue;
}
else    continue;
}
else    continue;
}
else    continue;
}
else    break;
}
fclose(fp);
}

/* To check if it is a function */
void check(char *c, int p1, int p2)
{
int i, flag = 0, temp = p1;

if ((c[p1 + 1] == ')'))
{
display(c, p1);
return;
}
for (i = p1 + 1; i < p2; i++)
{
if ((c[i] != ' ') || (c[i] == ')'))
{
flag = 1;

}
if (flag == 0)
{
display(c, p1);
return;
}
else
{
flag = 0;
while (c[--temp] != ' ');
for (i = 0; i < temp; i++)
if (c[i]==' ')
{
flag = 1;
}
if (flag == 0)
{
display(c, p1);
return;
}
else
return;
}
}
}

/* To display function name */
void display(char *c,int p1)
{
int temp = p1, i;

while (c[--temp] != ' ');
for (i = temp + 1; i < p1; i++)            /* Print name of function character by character */
printf("%c", c[i]);
printf("\n");
return;

}
 ETP 
 
 C Program to Find the Size of File using File Handling Function 
================================ EOPN
/* * C Program to Find the Size of File using File Handling Function 
================================ EOKW
--------------------------------
output:
$ vi file10.c
$ cc file10.c
$ a.out myvmlinux
 
File opened The size of given file is : 3791744
--------------------------------
#include <stdio.h>

void main(int argc, char **argv)
{
FILE *fp;
char ch;
int size = 0;

fp = fopen(argv[1], "r");
if (fp == NULL)
printf("\nFile unable to open ");
else
printf("\nFile opened ");
fseek(fp, 0, 2);    /* file pointer at the end of file */
size = ftell(fp);   /* take a position of file pointer un size variable */
printf("The size of given file is : %d\n", size);
fclose(fp);
}
 ETP 
 
 C Program to Capitalize First Letter of every Word in a File 
================================ EOPN
/* * C Program to Capitalize First Letter of every Word in a File 
================================ EOKW
--------------------------------
output:
$ cc file5.c
$ a.out sample
success
$ cat sample
Wipro Technologies
File Copy Function
Successfully Read
--------------------------------
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
int to_initcap_file(FILE *);

void main(int argc, char * argv[])
{
FILE *fp1;
char fp[10];
int p;

fp1 = fopen(argv[1], "r+");
if (fp1 == NULL)
{
printf("cannot open the file ");
exit(0);
}
p = to_initcap_file(fp1);
if (p == 1)
{
printf("success");
}
else
{
printf("failure");
}
fclose(fp1);
}

/* capitalizes first letter of every word */
int to_initcap_file(FILE *fp)
{
char c;

c = fgetc(fp);
if (c >= 'a' && c <= 'z')
{
fseek(fp, -1L, 1);
fputc(c - 32, fp);
}
while(c != EOF)
{
if (c == ' ' || c == '\n')
{
c = fgetc(fp);
if (c >= 'a' && c <= 'z')
{
fseek(fp, -1L, 1);
fputc(c - 32, fp);
}
}
else
{
c = fgetc(fp);
}
}
return 1;
}
 ETP 
 
 C Program to Print Environment Variables 
================================ EOPN
/* * C Program to Print Environment variables 
================================ EOKW
--------------------------------
output:
$ cc arg7.c
$ a.out
 
HOSTNAME=localhost.localdomain
SELINUX_ROLE_REQUESTED=
SHELL=/bin/bash
TERM=xterm
HISTSIZE=1000
SSH_CLIENT=192.168.7.43 49162 22
SELINUX_USE_CURRENT_RANGE=
QTDIR=/usr/lib64/qt-3.3
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/8
USER=harika
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.tbz=01;31:*.tbz2=01;31:*.bz=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
PATH=/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/harika/bin:.
MAIL=/var/spool/mail/harika
PWD=/home/harika
KDE_IS_PRELINKED=1
LANG=en_US.UTF-8
KDEDIRS=/usr
SELINUX_LEVEL_REQUESTED=
HISTCONTROL=ignoredups
SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass
HOME=/home/harika
SHLVL=2
LOGNAME=harika
CVS_RSH=ssh
QTLIB=/usr/lib64/qt-3.3/lib
SSH_CONNECTION=192.168.7.43 49162 192.168.7.140 22
LESSOPEN=|/usr/bin/lesspipe.sh %s
G_BROKEN_FILENAMES=1
_=./a.out
OLDPWD=/home
--------------------------------
#include <stdio.h>

void main(int argc, char *argv[], char * envp[])
{
int i;

for (i = 0; envp[i] != NULL; i++)
{
printf("\n%s", envp[i]);
}
}
 ETP 
 
 C Program to Copy File into Another File 
================================ EOPN
/* * C Program to Copy a File into Another File 
================================ EOKW
--------------------------------
output:
$ cc file1.c
$ a.out /tmp/vmlinux mylinux
 
File opened for copy...
 
$cmp /tmp/vmlinux mylinux
 
$ ls -l mylinux
-rw-rw-r--. 1 adi adi 3791744 Jul 27 19:57 mylinux
--------------------------------
#include <stdio.h>

void main(int argc,char **argv)
{
FILE *fp1, *fp2;
char ch;
int pos;

if ((fp1 = fopen(argv[1],"r")) == NULL)
{
printf("\nFile cannot be opened");
return;
}
else
{
printf("\nFile opened for copy...\n ");
}
fp2 = fopen(argv[2], "w");
fseek(fp1, 0L, SEEK_END); // file pointer at end of file
pos = ftell(fp1);
fseek(fp1, 0L, SEEK_SET); // file pointer set at start
while (pos--)
{
ch = fgetc(fp1);  // copying file character by character
fputc(ch, fp2);
}
fcloseall();
}
 ETP 
 
 C Program to Create Employee Record and Update it 
================================ EOPN
/* * C Program to Create Employee Record and Update it 
================================ EOKW
--------------------------------
output:
$ a.out emprec1
 
1] Create a Record
2] Display Records
3] Update Records
4] Exit
Enter your choice : 1
Enter name of employee : aaa
Enter emp id : 100 
 
Enter your choice : 1
Enter name of employee : bbb
Enter emp id : 200
 
Enter your choice : 1
Enter name of employee : ccc
Enter emp id : 300
 
Enter your choice : 1
Enter name of employee : ddd
Enter emp id : 400
 
Enter your choice : 1
Enter name of employee : eee
Enter emp id : 500 
 
Enter your choice : 2
 
100 aaa
200 bbb
300 ccc
400 ddd
500 eee
Enter your choice : 3
Enter employee id to update : 300
Enter new name of emplyee to update : cdefgh
 
Enter your choice : 2
 
100 aaa
200 bbb
300 cdefgh
400 ddd
500 eee
Enter your choice : 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define size 200

struct emp
{
int id;
char *name;
}*emp1, *emp3;

void display();
void create();
void update();

FILE *fp, *fp1;
int count = 0;

void main(int argc, char **argv)
{
int i, n, ch;

printf("1] Create a Record\n");
printf("2] Display Records\n");
printf("3] Update Records\n");
printf("4] Exit");
while (1)
{
printf("\nEnter your choice : ");
scanf("%d", &ch);
switch (ch)
{
case 1:
fp = fopen(argv[1], "a");
create();
break;
case 2:
fp1 = fopen(argv[1],"rb");
display();
break;
case 3:
fp1 = fopen(argv[1], "r+");
update();
break;
case 4:
exit(0);
}
}
}

/* To create an employee record */
void create()
{
int i;
char *p;

emp1 = (struct emp *)malloc(sizeof(struct emp));
emp1->name = (char *)malloc((size)*(sizeof(char)));
printf("Enter name of employee : ");
scanf(" %[^\n]s", emp1->name);
printf("Enter emp id : ");
scanf(" %d", &emp1->id);
fwrite(&emp1->id, sizeof(emp1->id), 1, fp);
fwrite(emp1->name, size, 1, fp);
count++;   // count to number of entries of records
fclose(fp);
}

/* Display the records in the file */
void display()
{
emp3=(struct emp *)malloc(1*sizeof(struct emp));
emp3->name=(char *)malloc(size*sizeof(char));
int i = 1;

if (fp1 == NULL)
printf("\nFile not opened for reading");
while (i <= count)
{
fread(&emp3->id, sizeof(emp3->id), 1, fp1);
fread(emp3->name, size, 1, fp1);
printf("\n%d %s",emp3->id,emp3->name);
i++;
}
fclose(fp1);
free(emp3->name);
free(emp3);
}

void update()
{
int id, flag = 0, i = 1;
char s[size];

if (fp1 == NULL)
{
printf("File cant be opened");
return;
}
printf("Enter employee id to update : ");
scanf("%d", &id);
emp3 = (struct emp *)malloc(1*sizeof(struct emp));
emp3->name=(char *)malloc(size*sizeof(char));
while(i<=count)
{
fread(&emp3->id, sizeof(emp3->id), 1, fp1);
fread(emp3->name,size,1,fp1);
if (id == emp3->id)
{
printf("Enter new name of emplyee to update : ");
scanf(" %[^\n]s", s);
fseek(fp1, -204L, SEEK_CUR);
fwrite(&emp3->id, sizeof(emp3->id), 1, fp1);
fwrite(s, size, 1, fp1);
flag = 1;
break;
}
i++;
}
if (flag != 1)
{
printf("No employee record found");
flag = 0;
}
fclose(fp1);
free(emp3->name);        /* to free allocated memory */
free(emp3);
}
 ETP 
 
 C Program to Compare two Binary Files, Printing the First Byte Position where they Differ 
================================ EOPN
/* * C Program to Compare two Binary Files, Printing the First Byte  * Position where they Differ 
================================ EOKW
--------------------------------
output:
$ gcc file15.c
$ a.out /bin/chgrp /bin/chown
Two files are not equal :  byte poistion at which two files differ is 25
 
/*
 * Verify using cmp command
 */
$ cmp /bin/chgrp /bin/chown
/bin/chgrp /bin/chown differ: byte 25,  line 1
 
$ a.out a.out a.out
Two files are Equal
/*
 * Verify using cmp command
 */
$ cmp a.out a.out
--------------------------------
#include <stdio.h>

void compare_two_binary_files(FILE *,FILE *);

int main(int argc, char *argv[])
{
FILE *fp1, *fp2;

if (argc < 3)
{
printf("\nInsufficient Arguments: \n");
printf("\nHelp:./executable <filename1> <filename2>\n");
return;
}
else
{
fp1 = fopen(argv[1],  "r");
if (fp1 == NULL)
{
printf("\nError in opening file %s", argv[1]);
return;
}

fp2 = fopen(argv[2], "r");

if (fp2 == NULL)
{
printf("\nError in opening file %s", argv[2]);
return;
}

if ((fp1 != NULL) && (fp2 != NULL))
{
compare_two_binary_files(fp1, fp2);
}
}
}

/*
* compare two binary files character by character
*/
void compare_two_binary_files(FILE *fp1, FILE *fp2)
{
char ch1, ch2;
int flag = 0;

while (((ch1 = fgetc(fp1)) != EOF) &&((ch2 = fgetc(fp2)) != EOF))
{
/*
* character by character comparision
* if equal then continue by comparing till the end of files
*/
if (ch1 == ch2)
{
flag = 1;
continue;
}
/*
* If not equal then returns the byte position
*/
else
{
fseek(fp1, -1, SEEK_CUR);
flag = 0;
break;
}
}

if (flag == 0)
{
printf("Two files are not equal :  byte poistion at which two files differ is %d\n", ftell(fp1)+1);
}
else
{
printf("Two files are Equal\n ", ftell(fp1)+1);
}
}
 ETP 
 
 C Program to Convert the Content of File to UpperCase 
================================ EOPN
/* * C Program to Convert the Content of File to UpperCase 
================================ EOKW
--------------------------------
output:
/* Input file : mydata
$ cat mydata
This is Manish
I had worked in Wipro and Cisco
*/
 
$ gcc file3.c
$ a.out mydata
The content of "mydata" file was successfully converted to upper case
 
/* "mydata" after conversion
$ cat mydata
THIS IS MANISH
I HAD WORKED IN WIPRO AND CISCO
*/
--------------------------------
#include <stdio.h>

int to_upper_file(FILE *);

int main(int argc,char *argv[])
{
FILE *fp;
int status;

if (argc == 1)
{
printf("Insufficient Arguments:");
printf("No File name is provided at command line");
return;
}
if (argc > 1)
{
fp = fopen(argv[1],"r+");
status = to_upper_file(fp);

/*
*If the status returned is 0 then the coversion of file content was completed successfully
*/

if (status == 0)
{
printf("\n The content of \"%s\" file was successfully converted to upper case\n",argv[1]);
return;
}
/*
* If the status returnes is -1 then the conversion of file content was not done
*/
if (status == -1)
{
printf("\n Failed to convert");
return;
}
}
}

/*
* convert the file content to uppercase
*/
int to_upper_file(FILE *fp)
{
char ch;

if (fp == NULL)
{
perror("Unable to open file");
return -1;
}
else
{
/*
* Read the file content and convert to uppercase
*/
while (ch != EOF)
{
ch = fgetc(fp);
if ((ch >= 'a') && (ch <= 'z'))
{
ch = ch - 32;
fseek(fp,-1,SEEK_CUR);
fputc(ch,fp);
}
}
return 0;
}
}
 ETP 
 
 C Program to Replace First Letter of every Word with Capital Letter 
================================ EOPN
/* * C Program to replace first letter of every word with caps 
================================ EOKW
--------------------------------
output:
$ vi file5test
$ cat file5test
chandana ravella
chanikya ravella
sree lakshmi ravella
sree ramulu ravella
$ cc file5.c
$ a.out file5test
 
success$ cat file5test
Chandana Ravella
Chanikya Ravella
Sree Lakshmi Ravella
Sree Ramulu Ravella
--------------------------------
#include <stdio.h>
#include <stdlib.h>

void main(int argc, char *argv[])
{
FILE *fp1;
int return_val;

if ((fp1 = fopen(argv[1],"r+")) =  = NULL)
{
printf("file cant be opened");
exit(0);
}
return_val = init_cap_file(fp1);
if (return_val == 1)
{
printf("\nsuccess");
}
else
{
printf("\n failure");
}
}

int init_cap_file(FILE *fp1)
{
char ch;

ch = fgetc(fp1);
if (ch >= 97 && ch <= 122)
{
fseek(fp1, -1L, 1);
fputc(ch - 32, fp1);
}
while (ch != EOF)
{
if (ch = = ' '|| ch == '\n')
{
ch = fgetc(fp1);
if (ch >= 97 && ch <= 122)
{
fseek(fp1, -1L, 1);
fputc(ch - 32, fp1);
}
}
else
ch = fgetc(fp1);
}
return 1;
}
 ETP 
 
 C Program to Count No of Lines, Blank Lines, Comments in a given Program 
================================ EOPN
/* * C Program to Count No of Lines, Blank Lines, Comments in a given Program 
================================ EOKW
--------------------------------
output:
 
Total no of lines: 204
Total no of comment line: 19
Total no of blank lines: 11
Total no of non blank lines: 193
Total no of lines end with semicolon: 66
--------------------------------
#include <stdio.h>

void main(int argc, char* argv[])
{
int line_count = 0, n_o_c_l = 0, n_o_n_b_l = 0, n_o_b_l = 0, n_e_c = 0;
FILE *fp1;
char ch;
fp1 = fopen(argv[1], "r");

while ((ch = fgetc(fp1))! = EOF)
{
if (ch  ==  '\n')
{
line_count++;
}
if (ch  ==  '\n')
{
if ((ch = fgetc(fp1))  ==  '\n')
{
fseek(fp1, -1, 1);
n_o_b_l++;
}
}
if (ch  ==  ';')
{
if ((ch = fgetc(fp1))  ==  '\n')
{
fseek(fp1, -1, 1);
n_e_c++;
}
}
}
fseek(fp1, 0, 0);
while ((ch = fgetc(fp1))! = EOF)
{
if (ch  ==  '/')
{
if ((ch = fgetc(fp1))  ==  '/')
{
n_o_c_l++;
}
}
}
printf("Total no of lines: %d\n", line_count);
printf("Total no of comment line: %d\n", n_o_c_l);
printf("Total no of blank lines: %d\n", n_o_b_l);
printf("Total no of non blank lines: %d\n", line_count-n_o_b_l);
printf("Total no of lines end with semicolon: %d\n", n_e_c);
}
 ETP 
 
 C Program to Reverse the Contents of a File and Print it 
================================ EOPN
/*  * C Program to Reverse the Contents of a File and Print it 
================================ EOKW
--------------------------------
output:
$ gcc file12.c
$ cat test2
The function STRERROR returns a pointer to an ERROR MSG STRING whose contents are implementation defined.
THE STRING is not MODIFIABLE and maybe overwritten by a SUBSEQUENT Call to the STRERROR function.
$ a.out test2 test_new
The FILE has been opened..
Number of characters to be copied 203
 
**File copied successfully in reverse order**
$ cat test_new
 
.noitcnuf RORRERTS eht ot llaC TNEUQESBUS a yb nettirwrevo ebyam dna ELBAIFIDOM ton si GNIRTS EHT
.denifed noitatnemelpmi era stnetnoc esohw GNIRTS GSM RORRE na ot retniop a snruter RORRERTS noitcnuf ehT
$ ./a.out test_new test_new_2
The FILE has been opened..
Number of characters to be copied 203
 
**File copied successfully in reverse order**
$ cat test_new_2
The function STRERROR returns a pointer to an ERROR MSG STRING whose contents are implementation defined.
THE STRING is not MODIFIABLE and maybe overwritten by a SUBSEQUENT Call to the STRERROR function.
$ cmp test test_new_2
--------------------------------
#include <stdio.h>
#include <errno.h>

long count_characters(FILE *);

void main(int argc, char * argv[])
{
int i;
long cnt;
char ch, ch1;
FILE *fp1, *fp2;

if (fp1 = fopen(argv[1], "r"))
{
printf("The FILE has been opened...\n");
fp2 = fopen(argv[2], "w");
cnt = count_characters(fp1); // to count the total number of characters inside the source file
fseek(fp1, -1L, 2);     // makes the pointer fp1 to point at the last character of the file
printf("Number of characters to be copied %d\n", ftell(fp1));

while (cnt)
{
ch = fgetc(fp1);
fputc(ch, fp2);
fseek(fp1, -2L, 1);     // shifts the pointer to the previous character
cnt--;
}
printf("\n**File copied successfully in reverse order**\n");
}
else
{
perror("Error occured\n");
}
fclose(fp1);
fclose(fp2);
}
// count the total number of characters in the file that *f points to
long count_characters(FILE *f)
{
fseek(f, -1L, 2);
long last_pos = ftell(f); // returns the position of the last element of the file
last_pos++;
return last_pos;
}
 ETP 
 
 C Program to Convert the Content of File to LowerCase 
================================ EOPN
/* * C Program to Convert the Content of File to LowerCase 
================================ EOKW
--------------------------------
output:
$ gcc file4.c
$ cat test1
THE FUNCTION STRERROR RETURNS A POINTER TO AN ERROR MSG STRING WHOSE CONTENTS ARE IMPLEMENTATION DEFINED.
THE STRING IS NOT MODIFIABLE AND MAYBE OVERWRITTEN BY A SUBSEQUENT CALL TO THE STRERROR FUNCTION.
$ ./a.out test1
FILE has been opened..!!!
 0
$ cat test1
the function strerror returns a pointer to an error msg string whose contents are implementation defined.
the string is not modifiable and maybe overwritten by a subsequent call to the strerror function.
--------------------------------
#include <stdio.h>
#include <errno.h>

int to_lower_file(FILE *);

void main(int argc, char * argv[])
{
int op = -1;
char ch;
FILE *fp;
if (fp = fopen(argv[1], "r+"))
{
printf("FILE has been opened..!!!\n");
op = to_lower_file(fp);
printf(" %d \n", op);
fclose(fp);
}
else
{
perror("Error Occured");
printf(" %d\n ", op);
}
}

int to_lower_file(FILE *f)
{
int c;
char ch;
while ((ch = fgetc(f))! = EOF)
{
c = (int)ch;
if (c >= 65 && c <= 90)
{
ch = ch + 32;
fseek(f, -1L, 1);
fputc(ch, f);
}
}
return 0;
}
 ETP 
 
 C Program to Update Details of Employee using Files 
================================ EOPN
/* * C Program to Update Details of Employee using Files 
================================ EOKW
--------------------------------
output:
$ cc file5.c
$ a.out empl
MENU:
1.Add a record
2.Display the file
3.Update the record
Enter your choice:1
Enter the employee id
1
enter the employee name
aaa
MENU:
1.Add a record
2.Display the file
3.Update the record
Enter your choice:1
Enter the employee id
2
enter the employee name
bbb
MENU:
1.Add a record
2.Display the file
3.Update the record
Enter your choice:3
Enter the employee id to update:
1
1Enter the employee name to be updated1bc
Record updated
MENU:
1.Add a record
2.Display the file
3.Update the record
Enter your choice:2
1 1bc
2 bbb
MENU:
1.Add a record
2.Display the file
3.Update the record
Enter your choice:4
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct emp
{
int empid;
char *name;
};

int count = 0;
void add_rec(char *a);
void display(char *a);
void update_rec(char *a);

void main(int argc, char *argv[])
{
int choice;
while (1)
{
printf("MENU:\n");
printf("1.Add a record\n");
printf("2.Display the file\n");
printf("3.Update the record\n");
printf("Enter your choice:");
scanf("%d", &choice);

switch(choice)
{
case 1:
add_rec(argv[1]);
break;
case 2:
display(argv[1]);
break;
case 3:
update_rec(argv[1]);
break;
case 4:
exit(0);
default:
printf("Wrong choice!!!\nEnter the correct choice\n");
}
}
}

void add_rec(char *a)
{
FILE *fp;
fp = fopen(a, "a+");
struct emp *temp = (struct emp *)malloc(sizeof(struct emp));
temp->name = (char *)malloc(50*sizeof(char));
if (fp == NULL)
printf("Error!!!");
else
{
printf("Enter the employee id\n");
scanf("%d", &temp->empid);
fwrite(&temp->empid, sizeof(int), 1, fp);
printf("enter the employee name\n");
scanf(" %[^\n]s", temp->name);
fwrite(temp->name, 50, 1, fp);
count++;
}
fclose(fp);
free(temp);
free(temp->name);
}

void display(char *a)
{
FILE *fp;
char ch;
int rec = count;
fp = fopen(a, "r");
struct emp *temp = (struct emp *)malloc(sizeof(struct emp));
temp->name = (char *)malloc(50*sizeof(char));
if (fp == NULL)
printf("Error!!");
else
{
while (rec)
{
fread(&temp->empid, sizeof(int), 1, fp);
printf("%d", temp->empid);
fread(temp->name, 50, 1, fp);
printf(" %s\n", temp->name);
rec--;
}
}
fclose(fp);
free(temp);
free(temp->name);
}

void update_rec(char *a)
{
FILE *fp;
char ch, name[5];
int rec, id, c;
fp = fopen(a, "r+");
struct emp *temp = (struct emp *)malloc(sizeof(struct emp));
temp->name = (char *)malloc(50*sizeof(char));
printf("Enter the employee id to update:\n");
scanf("%d", &id);
fseek(fp, 0, 0);
rec = count;
while (rec)
{
fread(&temp->empid, sizeof(int), 1, fp);
printf("%d", temp->empid);
if (id == temp->empid)
{
printf("Enter the employee name to be updated");
scanf(" %[^\n]s", name);
c = fwrite(name, 50, 1, fp);
break;
}
fread(temp->name, 50, 1, fp);
rec--;
}
if (c == 1)
printf("Record updated\n");
else
printf("Update not successful\n");
fclose(fp);
free(temp);
free(temp->name);
}
 ETP 
 
 C Program to Create Employee File Name Record that is taken from the Command-Line Argument 
================================ EOPN
/* * C Program to Create Employee File Name Record that is taken from the Command-Line Argument  
================================ EOKW
--------------------------------
output:
$ cc file2.c
$ a.out emp
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
1
Enter the employee id
100
Enter the employee name
AAA
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
1
Enter the employee id
200
Enter the employee name
BBB
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
1
Enter the employee id
300
Enter the employee name
CCC
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
1
Enter the employee id
400
Enter the employee name
DDD
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
1
Enter the employee id
500
Enter the employee name
EEE
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
2
100 AAA
200 BBB
300 CCC
400 DDD
500 EEE
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
3
100 AAA
200 BBB
300 CCC
400 DDD
500 EEE
enter which employee id to be updated
200
enter employee name for update:CBF
update of the record succesfully
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
2
100 AAA
200 CBF
300 CCC
400 DDD
500 EEE
Enter the choice
1-Insert a new record into file
2-Display the records
3-Update the record
4-Exit
4
--------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

struct emprec
{
int empid;
char *name;
};
typedef struct emprec emp;

void insert(char *a);
void display(char *a);
void update(char *a);
int count;
void main(int argc, char *argv[])
{
int choice;

while (1)
{
printf("Enter the choice\n");
printf("1-Insert a new record into file\n2-Display the records\n");
printf("3-Update the record\n4-Exit\n");
scanf("%d",  &choice);
switch (choice)
{
case 1:
insert(argv[1]);
break;
case 2:
display(argv[1]);
break;
case 3:
update(argv[1]);
break;
case 4:
exit(0);
default:
printf("Enter the correct choice\n");
}
}
}

/* To insert a new recored into the file */
void insert(char *a)
{
FILE *fp1;
emp *temp1 = (emp *)malloc(sizeof(emp));
temp1->name = (char *)malloc(200 * sizeof(char)); //allocating memory for pointer

fp1 = fopen(a, "a+");
if (fp1 == NULL)
perror("");
else
{
printf("Enter the employee id\n");
scanf("%d", &temp1->empid);
fwrite(&temp1->empid, sizeof(int), 1, fp1);
printf("Enter the employee name\n");
scanf(" %[^\n]s", temp1->name);
fwrite(temp1->name, 200, 1, fp1);
count++;
}
fclose(fp1);
free(temp1);
free(temp1->name);
}

/* To display the records in the file */
void display(char *a)
{
FILE *fp1;
char ch;
int var = count;
emp *temp = (emp *)malloc(sizeof(emp));
temp->name = (char *)malloc(200*sizeof(char));

fp1 = fopen(a, "r");
if (count == 0)
{
printf("no records to display\n");
return;
}
if (fp1 == NULL)
perror("");
else
{
while(var)    // display the employee records
{
fread(&temp->empid, sizeof(int), 1, fp1);
printf("%d", temp->empid);
fread(temp->name, 200, 1, fp1);
printf(" %s\n", temp->name);
var--;
}
}
fclose(fp1);
free(temp);
free(temp->name);
}

/* To Update the given record */
void update(char *a)
{
FILE *fp1;
char ch, name[200];
int var = count, id, c;
emp *temp = (emp *)malloc(sizeof(emp));
temp->name = (char *)malloc(200*sizeof(char));

fp1 = fopen(a, "r+");
if (fp1 == NULL)
perror("");
else
{
while (var)    //displaying employee records so that user enter correct employee id
{
fread(&temp->empid, sizeof(int), 1, fp1);
printf("%d", temp->empid);
fread(temp->name, 200, 1, fp1);
printf(" %s\n", temp->name);
var--;
}
printf("enter which employee id to be updated\n");
scanf("%d", &id);
fseek(fp1, 0, 0);
var = count;
while(var)    //loop to update the name of entered employeeid
{
fread(&temp->empid, sizeof(int), 1, fp1);
if (id == temp->empid)
{
printf("enter employee name for update:");
scanf(" %[^\n]s", name);
c = fwrite(name, 200, 1, fp1);
break;
}
fread(temp->name, 200, 1, fp1);
var--;
}
if (c == 1)
printf("update of the record succesfully\n");
else
printf("update unsuccesful enter correct id\n");
fclose(fp1);
free(temp);
free(temp->name);
}
}
 ETP 
 
 C Program to Join Lines of Two given Files and Store them in a New file 
================================ EOPN
/* * C Program to Join Lines of Two given Files and  * Store them in a New file 
================================ EOKW
--------------------------------
output:
$ cc file7.c
$ ./a.out lines.c words.c final.c
The files have been successfully concatenated
 
/* FIRST FILE */
 
/*
Hello!!
This is a C Program File.
Consider a code to Add two numbers 
*/
 
#include <stdio.h>
/* Function Prototype */
int sum(int,  int);
void main()
{
    int num1, num2;
    printf("Enter Number1 and Number2:");
    scanf("%d %d ", num1, num2);
    sum(num1, num2);
}
 
int sum(int a, int b)
{
    return a + b;
}
 
/* SECOND FILE */
 
/*
 * this is temporary file for use in file handling
 */
#include <stdio.h>
 
int sqrt(int);
void main()
{
    int num;
    printf("enter the number:");
    scanf("%d", &num);
    sqrt(num);
    printf("The square of the given number is:", num);
}
int sqrt(int num)
{
    return num*num;
}
 
/* CONCATENATED FILE */
/*
Hello!! * this is temporary file for use in file handling
This is a C Program File. *
Consider a code to Add two numbers  */
*/
#include <stdio.h>
#include <stdio.h>
int sqrt(int);
/* Function Prototype */void main()
{
int sum(int,  int);    int num;
void main()    printf("enter the number:");
{    scanf("%d", &num);
    int num1, num2;    sqrt(num);
    printf("Enter Number1 and Number2:");    printf("The square of the given number is:", num);
    scanf("%d %d ", num1, num2);}
    sum(num1, num2);int sqrt(int num)
}{
    return num*num;
int sum(int a, int b)}
{
    return a + b;
}
--------------------------------
#include <stdio.h>
#include <stdlib.h>

/* Function Prototype */
int joinfiles(FILE *, FILE *, FILE *);

char ch;
int flag;

void main(int argc, char *argv[])
{
FILE *file1, *file2, *target;

file1 = fopen(argv[1], "r");
if (file1 == NULL)
{
perror("Error Occured!");
}
file2 = fopen(argv[2], "r");
if (file2 == NULL)
{
perror("Error Occured!");
}
target = fopen(argv[3], "a");
if (target == NULL)
{
perror("Error Occured!");
}

joinfiles(file1, file2, target);        /* Calling Function */

if (flag == 1)
{
printf("The files have been successfully concatenated\n");
}
}

/* Code join the two given files line by line into a new file */

int joinfiles(FILE *file1, FILE *file2, FILE *target)
{
while ((fgetc(file1) != EOF) || (fgetc(file2) != EOF))
{
fseek(file1, -1, 1);
while ((ch = fgetc(file1)) != '\n')
{
if (ch == EOF)
{
break;
}
else
{
fputc(ch, target);
}
}
while ((ch = fgetc(file2)) != '\n')
{
if (ch == EOF)
{
break;
}
else
{
fputc(ch, target);
}
}
fputc('\n', target);
}
fclose(file1);
fclose(file2);
fclose(target);
return flag = 1;
}
 ETP 
 
 C Program to Collect Statistics of a Source File like Total Lines, Total no. of Blank Lines, Total no. of Lines ending with Semicolon 
================================ EOPN
/* * C Program to Collect Statistics of a Source File like Total Lines,  * Total no. of Blank Lines, Total no. of Lines ending with Semicolon 
================================ EOKW
--------------------------------
output:
$ cc file8.c
$ a.out lines.c
 
The Total number of lines are 23
The Total number of Commented lines are 6
The Total number of blank lines are 4
The total number of lines that end with Semicolon 6
The length of Actual code is 13
--------------------------------
#include <stdio.h>
#include <stdlib.h>

void main(int argc, char *argv[])    /* Command line Arguments */
{
int ncount = 0, ccount = 0, scount = 0, blank = 0;
char ch;
FILE *fp;
fp = fopen(argv[1], "r");
if (fp == NULL)
{
perror("Error Occured");
}
else
{
while(1)
{
ch = fgetc(fp);
if (ch == EOF)
{
break;
}
if (ch == 10)
{
ncount++;
if (ch = fgetc(fp) == '\n')
{
fseek(fp, -1, 1);        /* shifting offset of the file to previous position */
blank++;
}
}
else if (ch == 59)
{
scount++;
}
else if (ch == '/' || ch == '*')
{
ccount++;
}
}
}
printf("\nThe Total number of lines are %d", ncount);
printf("\nThe Total number of Commented lines are %d", ccount);
printf("\nThe Total number of blank lines are %d", blank);
printf("\nThe total number of lines that end with Semicolon %d", scount);
printf("\nThe length of Actual code is %d ", ncount-blank-ccount);
fclose(fp);
}
 ETP 
 
 C Program to Calculate the Simple Interest 
================================ EOPN
/*
 * C program to find the simple interest, given principal,
 * rate of interest and time.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm3.c
$ a.out
Enter the values of principal_amt, rate and time
12
10
5
Amount = Rs. 12.00
Rate = Rs. 10.00%
Time = 5 years
Simple interest =  6.00
--------------------------------

#include <stdio.h>
 
void main()
{
    float principal_amt, rate, simple_interest;
    int time;
 
    printf("Enter the values of principal_amt, rate and time \n");
    scanf("%f %f %d", &principal_amt, &rate, &time);
    simple_interest = (principal_amt * rate * time) / 100.0;
    printf("Amount = Rs. %5.2f\n", principal_amt);
    printf("Rate = Rs. %5.2f%\n", rate);
    printf("Time = %d years\n", time);
    printf("Simple interest = %5.2f\n", simple_interest);
}
 ETP 
 
 C Program to Find out the Roots of a Quadratic Equation 
================================ EOPN
/*
 * C program to find out the roots of a quadratic equation
 * for non-zero coefficients. In case of errors the program
 * should report suitable error message.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm7.c -lm
$ a.out
Enter the values of a, b and c
45 50 65
Imaginary Roots
Root1 = -0.555556  +i 1.065740
Root2 = -0.555556  -i 1.065740
--------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
 
void main()
{
    float a, b, c, root1, root2;
    float realp, imagp, disc;
 
    printf("Enter the values of a, b and c \n");
    scanf("%f %f %f", &a, &b, &c);
    /* If a = 0, it is not a quadratic equation 
 ETP 
 
 C Program to Simulate a Simple Calculator 
================================ EOPN
/*
 * C program to simulate a simple calculator to perform arithmetic
 * operations like addition, subtraction, multiplication and division
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm.c
$ a.out8
Simulation of a Simple Calculator
 *
Enter two numbers
2 3
Enter the operator [+,-,*,/]
+
 
2.00 +  3.00 =  5.00
 
$ a.out
Simulation of a Simple Calculator
 *
Enter two numbers
50 40
Enter the operator [+,-,*,/]
*
 
50.00 * 40.00 = 2000.00
 
$ a.out
Simulation of a Simple Calculator
 *
Enter two numbers
500 17
Enter the operator [+,-,*,/]
/
 
500.00 / 17.00 = 29.41
 
$ a.out
Simulation of a Simple Calculator
 *
Enter two numbers
65000 4700
Enter the operator [+,-,*,/]
-
 
65000.00 - 4700.00 = 60300.00
--------------------------------

#include <stdio.h>
 
void main()
{
    char operator;
    float num1, num2, result;
 
    printf("Simulation of a Simple Calculator\n");
    printf(" *\n");
    printf("Enter two numbers \n");
    scanf("%f %f", &num1, &num2);
    fflush(stdin);
    printf("Enter the operator [+,-,*,/] \n");
    scanf("%s", &operator);
    switch(operator)
    {
    case '+': result = num1 + num2;
        break;
    case '-': result = num1 - num2;
        break;
    case '*': result = num1 * num2;
        break;
    case '/': result = num1 / num2;
        break;
    default : printf("Error in operationn");
        break;
    }
    printf("\n %5.2f %c %5.2f = %5.2f\n", num1, operator, num2, result);
}
 ETP 
 
 C Program to Generate Fibonacci Series 
================================ EOPN
/*
 * C program to generate Fibonacci Series. Fibonacci Series
 * is 0 1 1 2 3 5 8 13 21 ...
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm40.c
$ a.out
Enter the limit to generate the Fibonacci Series
6
Fibonacci Series is ...
0
1
1
2
3
5
--------------------------------

#include <stdio.h>
 
void main()
{
    int  fib1 = 0, fib2 = 1, fib3, limit, count = 0;
 
    printf("Enter the limit to generate the Fibonacci Series \n");
    scanf("%d", &limit);
    printf("Fibonacci Series is ...\n");
    printf("%d\n", fib1);
    printf("%d\n", fib2);
    count = 2;
    while (count < limit)
    {
        fib3 = fib1 + fib2;
        count++;
        printf("%d\n", fib3);
        fib1 = fib2;
        fib2 = fib3;
    }
}
 ETP 
 
C Program to find the Nth Fibonacci Number using Recursion
================================ EOPN
/* * C Program to find the nth number in Fibonacci series using recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm9.c
$ a.out
Enter the nth number in fibonacci series: 8
The 8 number in fibonacci series is 21
 
$ a.out
Enter the nth number in fibonacci series: 12
The 12 number in fibonacci series is 144
--------------------------------
#include <stdio.h>
int fibo(int);

int main()
{
int num;
int result;

printf("Enter the nth number in fibonacci series: ");
scanf("%d", &num);
if (num < 0)
{
printf("Fibonacci of negative number is not possible.\n");
}
else
{
result = fibo(num);
printf("The %d number in fibonacci series is %d\n", num, result);
}
return 0;
}
int fibo(int num)
{
if (num == 0)
{
return 0;
}
else if (num == 1)
{
return 1;
}
else
{
return(fibo(num - 1) + fibo(num - 2));
}
}
 ETP 
 
 C Program to Find First N Fibonacci Numbers 
================================ EOPN
/* * C program to generate and print first N FIBONACCI numbers * in the series. 
================================ EOKW
--------------------------------
output:
$ cc pgm10.c
$ a.out
Enter the value of num
15
First 15 FIBONACCI numbers are ...
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
--------------------------------
#include <stdio.h>

void main()
{
int fib1 = 0, fib2 = 1, fib3, num, count = 0;

printf("Enter the value of num \n");
scanf("%d", &num);
printf("First %d FIBONACCI numbers are ...\n", num);
printf("%d\n", fib1);
printf("%d\n", fib2);
count = 2; /* fib1 and fib2 are already used */
while (count < num)
{
fib3 = fib1 + fib2;
count++;
printf("%d\n", fib3);
fib1 = fib2;
fib2 = fib3;
}
}
 ETP 
 
 C Program to Find the GCD and LCM of Two Integers 
================================ EOPN
/* * C program to find the GCD and LCM of two integers using Euclids' algorithm 
================================ EOKW
--------------------------------
output:
$ cc pgm11.c
$ a.out
Enter two numbers
30
40
GCD of 30 and 40 = 10
LCM of 30 and 40 = 120
--------------------------------
#include <stdio.h>

void main()
{
int num1, num2, gcd, lcm, remainder, numerator, denominator;

printf("Enter two numbers\n");
scanf("%d %d", &num1, &num2);
if (num1 > num2)
{
numerator = num1;
denominator = num2;
}
else
{
numerator = num2;
denominator = num1;
}
remainder = numerator % denominator;
while (remainder != 0)
{
numerator   = denominator;
denominator = remainder;
remainder   = numerator % denominator;
}
gcd = denominator;
lcm = num1 * num2 / gcd;
printf("GCD of %d and %d = %d\n", num1, num2, gcd);
printf("LCM of %d and %d = %d\n", num1, num2, lcm);
}
 ETP 
 
C Program to find HCF of a given Number using Recursion
================================ EOPN
/*
 * C Program to find HCF of a given Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm32.c
$ a.out
Enter the two numbers to find their HCF: 24 36
The HCF of 24 and 36 is 12.
--------------------------------

#include <stdio.h>
 
int hcf(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter the two numbers to find their HCF: ");
    scanf("%d%d", &a, &b);
    result = hcf(a, b);
    printf("The HCF of %d and %d is %d.\n", a, b, result);
}
 
int hcf(int a, int b)
{
    while (a != b)
    {
        if (a > b)
        {
            return hcf(a - b, b);
        }
        else
        {
            return hcf(a, b - a);
        }
    }
    return a;
}
 ETP 
 
C Program to find LCM of a Number using Recursion
================================ EOPN
/*
 * C Program to Find LCM of a Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm22.c
$ a.out
Enter two numbers: 456
12
The LCM of 456 and 12 is 456
 
$ a.out
Enter two numbers: 45 75
The LCM of 45 and 75 is 225
--------------------------------

#include <stdio.h>
 
int lcm(int, int);
 
int main()
{
    int a, b, result;
    int prime[100];
 
    printf("Enter two numbers: ");
    scanf("%d%d", &a, &b);
    result = lcm(a, b);
    printf("The LCM of %d and %d is %d\n", a, b, result);
    return 0;
}
 
int lcm(int a, int b)
{ 
    static int common = 1;
 
    if (common % a == 0 && common % b == 0)
    {
        return common;
    }
    common++;
    lcm(a, b);
    return common;
}
 ETP 
 
C Program to find GCD of given Numbers using Recursion
================================ EOPN
/*
 * C Program to find GCD of given Numbers using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ gcc gcd_recr.c -o gcd_recr
$ a.out
Enter the two numbers to find their GCD: 100 70
The GCD of 100 and 70 is 10.
--------------------------------

#include <stdio.h>
 
int gcd(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter the two numbers to find their GCD: ");
    scanf("%d%d", &a, &b);
    result = gcd(a, b);
    printf("The GCD of %d and %d is %d.\n", a, b, result);
}
 
int gcd(int a, int b)
{
    while (a != b)
    {
        if (a > b)
        {
            return gcd(a - b, b);
        }
        else
        {
            return gcd(a, b - a);
        }
    }
    return a;
}
 ETP 
 
C Program to find HCF of a given Number without using Recursion
================================ EOPN
/* * C Program to find HCF of a given Number without using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm31.c
$ a.out
Enter the two numbers to find their HCF: 24 36
The HCF of 24 and 36 is 12.
--------------------------------
#include <stdio.h>

int hcf(int, int);

int main()
{
int a, b, result;

printf("Enter the two numbers to find their HCF: ");
scanf("%d%d", &a, &b);
result = hcf(a, b);
printf("The HCF of %d and %d is %d.\n", a, b, result);

return 0;
}

int hcf(int a, int b)
{
while (a != b)
{
if (a > b)
{
a = a - b;
}
else
{
b = b - a;
}
}
return a;
}
 ETP 
 
 C Program to Calculate the Value of sin(x) 
================================ EOPN
/*
 * C program to find the value of sin(x) using the series
 * up to the given accuracy (without using user defined function)
 * also print sin(x) using library function.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm14.c -lm
$ a.out
Enter the value of x (in degrees)
60
Enter the accuracy for the result
0.86602540378443864676372317075294
Sum of the sine series         = 0.855862
Using Library function sin(60) = 0.866093
 
$ a.out
Enter the value of x (in degrees)
45
Enter the accuracy for the result
0.70710678118654752440084436210485
Sum of the sine series         = 0.704723
Using Library function sin(45) = 0.707179
--------------------------------

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
 
void main()
{
    int n, x1;
    float accuracy, term, denominator, x, sinx, sinval;
 
    printf("Enter the value of x (in degrees) \n");
    scanf("%f", &x);
    x1 = x;
    /*  Converting degrees to radians 
 ETP 
 
 C Program to Calculate the Value of cos(x) 
================================ EOPN
/*
 * C program to find the value of cos(x) using the series
 * up to the given accuracy (without using user defined function)
 * also print cos(x) using library function.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm15.c -lm
$ a.out
Enter the value of x (in degrees)
60
Enter the accuracy for the result
0.86602
Sum of the cosine series       = 0.451546
Using Library function cos(60) = 0.499882
 
$ a.out
Enter the value of x (in degrees)
45
Enter the accuracy for the result
0.7071
Sum of the cosine series       = 0.691495
Using Library function cos(45) = 0.707035
--------------------------------

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
 
void main()
{
    int n, x1;
    float accuracy, term, denominator, x, cosx, cosval;
 
    printf("Enter the value of x (in degrees) \n");
    scanf("%f", &x);
    x1 = x;
    /*  Converting degrees to radians 
 ETP 
 
 C Program to Calculate the Sum of cos(x) Series 
================================ EOPN
/*
 * C program to find the sum of cos(x) series
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm63.c -lm
$ a.out
Enter the number of the terms in a series
3
Enter the value of x(in degrees)
90
Sum of the cosine series =   -0.23
The value of cos(90) using library function = -0.000204
--------------------------------

#include <stdio.h>
#include <math.h>
 
void main()
{
    int n, x1, i, j;
    float x, sign, cosx, fact;
 
    printf("Enter the number of the terms in a series\n");
    scanf("%d", &n);
    printf("Enter the value of x(in degrees)\n");
    scanf("%f", &x);
    x1 = x;
    /*  Degrees to radians 
 ETP 
 
 C Program to Find the Sum of First N Natural Numbers 
================================ EOPN
/* * C program to find the sum of 'N' natural numbers 
================================ EOKW
--------------------------------
output:
$ cc pgm3.c
$ a.out
Enter an integer number
1300
Sum of first 1300 natural numbers = 845650
 
$ a.out
Enter an integer number
15
Sum of first 15 natural numbers = 120
--------------------------------
#include <stdio.h>

void main()
{
int i, num, sum = 0;

printf("Enter an integer number \n");
scanf ("%d", &num);
for (i = 1; i <= num; i++)
{
sum = sum + i;
}
printf ("Sum of first %d natural numbers = %d\n", num, sum);
}
 ETP 
 
 C Program to Check if a given Number is Prime number 
================================ EOPN
/* * C program to check whether a given number is prime or not * and output the given number with suitable message. 
================================ EOKW
--------------------------------
output:
 
Enter a number
23
23 is a prime number
 
 
Enter a number
15
15 is not a prime number
--------------------------------
#include <stdio.h>
#include <stdlib.h>

void main()
{
int num, j, flag;

printf("Enter a number \n");
scanf("%d", &num);

if (num <= 1)
{
printf("%d is not a prime numbers \n", num);
exit(1);
}
flag = 0;
for (j = 2; j <= num / 2; j++)
{
if ((num % j) == 0)
{
flag = 1;
break;
}
}
if (flag == 0)
printf("%d is a prime number \n", num);
else
printf("%d is not a prime number \n", num);
}
 ETP 
 
 C Program to Find Prime Numbers in a given Range 
================================ EOPN
#include <stdio.h>#include <stdlib.h> void main(){    int num1, num2, i, j, flag, temp, count = 0;     printf("Enter the value of num1 and num2 \n");    scanf("%d %d", &num1, &num2);    if (num2 < 2)    {        printf("There are no primes upto %d\n", num2);        exit(0);    }    printf("Prime numbers are \n");    temp = num1;    if ( num1 % 2 == 0)    {        num1++;    }    for (i = num1; i <= num2; i = i + 2)    {        flag = 0;        for (j = 2; j <= i / 2; j++)        {            if ((i % j) == 0)            {                flag = 1;                break;            }        }        if (flag == 0)        {            printf("%d\n", i);            count++;        }    }    printf("Number of primes between %d & %d = %d\n", temp, num2, count);}
================================ EOKW
--------------------------------
output:
Case:1
Enter the value of num1 and num2
70 85
Prime numbers are
71
73
79
83
Number of primes between 70 and 85 = 4
Case:2
Enter the value of num1 and num2
0 1
There are no primes upto 1
--------------------------------
 ETP 
 
 C Program to Calculate the Mean, Variance & Standard Deviation 
================================ EOPN
/*
 * C program to input real numbers and find the mean, variance
 * and standard deviation
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm23.c -lm
$ a.out
Enter the value of N
5
Enter 5 real numbers
34
88
32
12
10
Average of all elements = 35.20
variance of all elements = 794.56
Standard deviation = 28.19
--------------------------------

#include <stdio.h>
#include <math.h>
#define MAXSIZE 10
 
void main()
{
    float x[MAXSIZE];
    int  i, n;
    float average, variance, std_deviation, sum = 0, sum1 = 0;
 
    printf("Enter the value of N \n");
    scanf("%d", &n);
    printf("Enter %d real numbers \n", n);
    for (i = 0; i < n; i++)
    {
        scanf("%f", &x[i]);
    }
    /*  Compute the sum of all elements 
 ETP 
 
 C Program to Evaluate the given Polynomial Equation 
================================ EOPN
/*
 * C program to evaluate a given polynomial by reading its coefficients
 * in an array.
 * P(x) = AnXn + An-1Xn-1 + An-2Xn-2+... +A1X + A0
 *
 * The polynomial can be written as:
 * P(x) = A0 + X(A1 + X(A2 + X(A3 + X(Q4 + X(...X(An-1 + XAn))))
 * and evaluated starting from the inner loop
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm.c
$ a.out
Enter the order of the polynomial
2
Enter the value of x
2
Enter 3 coefficients
3
2
6
Given polynomial is:
 + 3x^2   + 2x^1   + 6x^0
Sum of the polynomial =  22.00
 
$ a.out
Enter the order of the polynomial
4
Enter the value of x
1
Enter 5 coefficients
3
-5
6
8
-9
Given polynomial is:
 + 3x^4   - 5x^3   + 6x^2   + 8x^1   - 9x^0
Sum of the polynomial =   3.00
--------------------------------

#include <stdio.h>
#include <stdlib.h>
#define MAXSIZE 10
 
void main()
{
    int array[MAXSIZE];
    int i, num, power;
    float x, polySum;
 
    printf("Enter the order of the polynomial \n");
    scanf("%d", &num);
    printf("Enter the value of x \n");
    scanf("%f", &x);
    /*  Read the coefficients into an array 
 ETP 
 
 C Program to Read a Coordinate Point and Determine its Quadrant 
================================ EOPN
/*
 * C program to accept a coordinate point in a XY coordinate system
 * and determine its quadrant
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm76.c
$ a.out
Enter the values for X and Y
20 30
point (-1079549476, -1079549480) lies in the First quandrant
 
$ a.out
Enter the values for X and Y
-30 -60
point (-1080802740, -1080802744) lies in the Third quandrant
 
$ a.out
Enter the values for X and Y
300 -8
point (-1078902004, -1078902008) lies in the Fourth quandrant
 
$ a.out
Enter the values for X and Y
-180 180
point (-1076456724, -1076456728) lies in the Second quandrant
--------------------------------

#include <stdio.h>
 
void main()
{
    int x, y;
 
    printf("Enter the values for X and Y\n");
    scanf("%d %d", &x, &y);
    if (x > 0 && y > 0)
        printf("point (%d, %d) lies in the First quandrant\n");
    else if (x < 0 && y > 0)
        printf("point (%d, %d) lies in the Second quandrant\n");
    else if (x < 0 && y < 0)
        printf("point (%d, %d) lies in the Third quandrant\n");
    else if (x > 0 && y < 0)
        printf("point (%d, %d) lies in the Fourth quandrant\n");
    else if (x == 0 && y == 0)
        printf("point (%d, %d) lies at the origin\n");
}
 ETP 
 
C Program to find Power of a Number using Recursion
================================ EOPN
/*
 * C Program to find Power of a Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm30.c
$ a.out
Enter a number: 456
Enter it's power: 3
456^3 is 94818816
--------------------------------

#include <stdio.h>
 
long power (int, int);
 
int main()
{
    int pow, num;
    long result;
 
    printf("Enter a number: ");
    scanf("%d", &num);
    printf("Enter it's power: ");
    scanf("%d", &pow);
    result = power(num, pow);
    printf("%d^%d is %ld", num, pow, result);
    return 0;
}
 
long power (int num, int pow)
{
    if (pow)
    {
        return (num * power(num, pow - 1));
    }
    return 1;
}
 ETP 
 
C Program to find the Factorial of a Number using Recursion
================================ EOPN
/*
 * C Program to find factorial of a given number using recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm5.c
$ a.out
Enter a number to find it's Factorial: 6
The Factorial of 6 is 720.
--------------------------------

#include <stdio.h>
 
int factorial(int);
 
int main()
{
    int num;
    int result;
 
    printf("Enter a number to find it's Factorial: ");
    scanf("%d", &num);
    if (num < 0)
    {
        printf("Factorial of negative number not possible\n");
    }
    else
    {
        result = factorial(num);
        printf("The Factorial of %d is %d.\n", num, result);
    }
    return 0;
}
int factorial(int num)
{
    if (num == 0 || num == 1)
    {
        return 1;
    }
    else
    {
        return(num * factorial(num - 1));
    }
}
 ETP 
 
C Program to Compute the Value of X ^ N 
================================ EOPN
/*
 * C program to compute the value of X ^ N given X and N as inputs
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm55.c -lm
$ a.out
Enter the values of X and N
2 5
X to the power N = 32
--------------------------------

#include <stdio.h>
#include <math.h>
 
long int power(int x, int n);
 
void main()
{
    long int x, n, xpown;
 
    printf("Enter the values of X and N \n");
    scanf("%ld %ld", &x, &n);
    xpown = power(x, n);
    printf("X to the power N = %ld\n", xpown);
}
/*  Recursive function to computer the X to power N 
 ETP 
 
C Program to Print the Factorial of a given Number
================================ EOPN
/*
 * C program to find the factorial of a given number
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm79.c
$ a.out
Enter the number
10
Factorial of 10 = 3628800
--------------------------------

 
#include <stdio.h>
void main()
{
    int i, fact = 1, num;
 
    printf("Enter the number \n");
    scanf("%d", &num);
    if (num <= 0)
        fact = 1;
    else
    {
        for (i = 1; i <= num; i++)
        {
            fact = fact * i;
        }
    }
    printf("Factorial of %d = %5d\n", num, fact);
}
 ETP 
 
C program to Calculate the value of nCr 
================================ EOPN
/*
 * C program to Calculate the value of nCr
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm12.c
$ a.out
Enter the value for N and R
5 2
 
The value of ncr is: 10
--------------------------------

#include <stdio.h>
 
int fact(int z);
 
void main()
{
    int n, r, ncr;
 
    printf("\n Enter the value for N and R \n");
    scanf("%d%d", &n, &r);
    ncr = fact(n) / (fact(r) * fact(n - r));
    printf("\n The value of ncr is: %d", ncr);
}
 
int fact(int z)
{
    int f = 1, i;
    if (z == 0)
    {
        return(f);
    }
    else
    {
        for (i = 1; i <= z; i++)
    {
            f = f * i;
    }
    }
    return(f);
}
 ETP 
 
C Program to Find & Display Multiplication Table 
================================ EOPN
/* * C Program to Find & Display Multiplication table 
================================ EOKW
--------------------------------
output:
Output:
 
Enter the Number:6
Multiplication table of 6:
--------------------------
 6 x 1 = 6
 6 x 2 = 12
 6 x 3 = 18
 6 x 4 = 24
 6 x 5 = 30
 6 x 6 = 36
 6 x 7 = 42
 6 x 8 = 48
 6 x 9 = 54
 6 x 10 = 60
--------------------------------
#include <stdio.h>

int main()
{
int number, i = 1;

printf(" Enter the Number:");
scanf("%d", &number);
printf("Multiplication table of %d:\n ", number);
printf("--------------------------\n");
while (i <= 10)
{
printf(" %d x %d = %d \n ", number, i, number * i);
i++;
}
return 0;
}
 ETP 
 
C Program to Find out the Sum of Series 1^2 + 2^2 + …   + n^2 
================================ EOPN
/*
 * C Program to find the sum of series 1^2 + 2^2 + …. + n^2.
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm18.c
$ a.out
Enter maximum values of series number: 4
Sum of the above given series : 1^2 + 2^2 + 3^2 + 4^2 = 30
--------------------------------

#include <stdio.h>
 
int main()
{
    int number, i;
    int sum = 0;
 
    printf("Enter maximum values of series number: ");
    scanf("%d", &number);
    sum = (number * (number + 1) * (2 * number + 1 )) / 6;
    printf("Sum of the above given series : ");
    for (i = 1; i <= number; i++)
    {
        if (i != number)
            printf("%d^2 + ", i);
        else
            printf("%d^2 = %d ", i, sum);
    }
    return 0;
}
 ETP 
 
C Program to Find the Sum of Series 1 + 1/2 + 1/3 + 1/4 + … + 1/N
================================ EOPN
/*
 * C Program to find the Sum of Series 1 + 1/2 + 1/3 + 1/4 + ... + 1/N
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm.c
$ a.out
 
enter the number 4
 
1 + (1/2.000000) +  (1/3.000000) +  (1/4.000000)
The sum of the given series is 2.08
--------------------------------

#include <stdio.h>
 
void main()
{
    double number, sum = 0, i;
 
    printf("\n enter the number ");
    scanf("%lf", &number);
    for (i = 1; i <= number; i++)
    {
        sum = sum + (1 / i);
        if (i == 1)
            printf("\n 1 +");
        else if (i == number)
            printf(" (1 / %lf)", i);
        else
            printf(" (1 / %lf) + ", i);
    }
    printf("\n The sum of the given series is %.2lf", sum);
}
 ETP 
 
C Program to Find Sum of the Series 1/1! + 2/2! + 3/3! + ……1/N!
================================ EOPN
/*
 * C Program to Find find Sum of the Series 1/1! + 2/2! + 3/3! + ……1/N!
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm20.c
$ a.out
 
Enter the value:  5
Sum of the above series = 2.708333
--------------------------------

#include <stdio.h>
 
double sumseries(double);
 
main()
{
    double number,sum;
    printf("\n Enter the value:  ");
    scanf("%lf", &number);
    sum = sumseries(number);
    printf("\n Sum of the above series = %lf ", sum);
}
 
double sumseries(double m)
{
    double sum2 = 0, f = 1, i;
    for (i = 1; i <= m; i++)
    {
        f = f * i;
        sum2 = sum2 +(i / f);
    }
    return(sum2);
}
 ETP 
 
C Program to Find the Sum of A.P Series
================================ EOPN
/*
 * C Program to Find the Sum of A.P Series
 
================================ EOKW
--------------------------------
output:
 
Output:
$cc pgm21.c
$ a.out
Enter the first term value of the A.P. series: 1
Enter the total numbers in the A.P. series: 5
Enter the common difference of A.P. series: 2
Sum of the A.P series is: 1 + 3 + 5 + 7 + 9 = 25
--------------------------------

#include <stdio.h>
#include <math.h>
 
int main()
{
     int a, d, n, i, tn;
     int sum = 0;
 
     printf("Enter the first term value of the A.P. series: ");
     scanf("%d", &a);
     printf("Enter the total numbers in the A.P. series: ");
     scanf("%d", &n);
     printf("Enter the common difference of A.P. series: ");
     scanf("%d", &d);
     sum = (n * (2 * a + (n - 1)* d ))/ 2;
     tn = a + (n - 1) * d;
     printf("Sum of the A.P series is: ");
     for (i = a; i <= tn; i = i + d )
     {
          if (i != tn)
               printf("%d + ", i);
          else
               printf("%d = %d ", i, sum);
     }
     return 0;
}
 ETP 
 
C Program to Find the Sum of G.P Series
================================ EOPN
/*
 * C Program to Find the Sum of G.P Series
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm22.c -lm
$ a.out
Enter the first term of the G.P. series: 3
Enter the total numbers in the G.P. series: 7
Enter the common ratio of G.P. series: 2
last_term term of G.P.: 192.000000
Sum of the G.P.: 765.000000
--------------------------------

#include <stdio.h>
#include <math.h>
 
int main()
{
    float a, r, i, last_term, sum = 0;
    int n;
 
    printf("Enter the first term of the G.P. series: ");
    scanf("%f", &a);
    printf("Enter the total numbers in the G.P. series: ");
    scanf("%d", &n);
    printf("Enter the common ratio of G.P. series: ");
    scanf("%f", &r);
    sum = (a *(1 - pow(r, n + 1))) / (1 - r);
    last_term = a * pow(r, n - 1);
    printf("last_term term of G.P.: %f", last_term);
    printf("\n Sum of the G.P.: %f", sum);
    return 0;
}
 ETP 
 
C Program to Find the Sum of H.P Series
================================ EOPN
/*
 * C Program to Find the Sum of H.P Series
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm23.c
$ a.out
1 + 1 / 2 + 1 / 3 +......+1 / n
Enter the value of n
5
the Sum of H.P Series is = 2.283334
--------------------------------

#include <stdio.h>
 
void main()
{
    int n;
    float i, sum, term;
 
    printf("1 + 1 / 2 + 1 / 3 +......+1 / n \n");
    printf("Enter the value of n \n");
    scanf("%d", &n);
    sum = 0;
    for (i = 1; i <= n; i++)
    {
        term = 1 / i;
        sum = sum + term;
    }
    printf("the Sum of H.P Series is = %f", sum);
}
 ETP 
 
 C Program to Calculate the Area of a Triangle 
================================ EOPN
/*
 * C program to find the area of a triangle, given three sides
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm1.c -lm
$ a.out
Enter the values of a, b and c
12 10 8
Area of a triangle = 39
--------------------------------

#include <stdio.h>
#include <math.h>
 
void main()
{
    int s, a, b, c, area;
 
    printf("Enter the values of a, b and c \n");
    scanf("%d %d %d", &a, &b, &c);
    /* compute s 
 ETP 
 
 C Program to Calculate the Area of a Circle 
================================ EOPN
/*
 * C program to find the area of a circle, given the radius
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm2.c -lm
$ a.out
Enter the radius of a circle
30
Area of a circle = 2827.80
--------------------------------

#include <stdio.h>
#include <math.h>
#define PI 3.142
 
void main()
{
    float radius, area;
 
    printf("Enter the radius of a circle \n");
    scanf("%f", &radius);
    area = PI * pow(radius, 2);
    printf("Area of a circle = %5.2f\n", area);
}
 ETP 
 
C Program to Find the Area of Right angled Triangle
================================ EOPN
/*
 * C Program to Find Area of a Right Angled Triangle
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm24.c
$ a.out
Enter height and width of the given triangle:
 10 15
Area of right angled triangle is: 75.000
--------------------------------

#include <stdio.h>
 
int main()
{
    float height, width;
    float area;
 
    printf("Enter height and width of the given triangle:\n ");
    scanf("%f%f", &height, &width);
    area = 0.5 * height * width;
    printf("Area of right angled triangle is: %.3f\n", area);
    return 0;
}
 ETP 
 
C Program to Find the Area of Trapezium 
================================ EOPN
/*
 * C Program to Find Area of Trapezium
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm25.c
$ a.out
Enter the value for two bases and height of the trapezium :
10 15 20
Area of the trapezium is: 250.000
--------------------------------

#include <stdio.h>
 
int main()
{
    float a, b, h;
    float area;
 
    printf("Enter the value for two bases & height of the trapezium: \n");
    scanf("%f%f%f", &a, &b, &h);
    area = 0.5 * (a + b) * h ;
    printf("Area of the trapezium is: %.3f", area);
    return 0;
}
 ETP 
 
C Program to Find the Area of Rhombus 
================================ EOPN
/*
 * C Program to Find Area of rhombus
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm26.c
$ a.out
Enter diagonals of the given rhombus:
 30 40
Area of rhombus is: 600.000
--------------------------------

#include <stdio.h>
 
int main()
{
    float diagonal1, diagonal2;
    float area;
 
    printf("Enter diagonals of the given rhombus: \n ");
    scanf("%f%f", &diagonal1, &diagonal2);
    area = 0.5 * diagonal1 * diagonal2;
    printf("Area of rhombus is: %.3f \n", area);
    return 0;
}
 ETP 
 
C Program to Find the Area of Parallelogram 
================================ EOPN
/*
 * C Program to Find Area of Parallelogram
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm27.c
$ a.out
Enter base and altitude of the given Parallelogram:
 17 19
Area of Parallelogram is: 323.000
--------------------------------

#include <stdio.h>
 
int main()
{
    float base, altitude;
    float area;
 
    printf("Enter base and altitude of the given Parallelogram: \n ");
    scanf("%f%f", &base, &altitude);
    area = base * altitude;
    printf("Area of Parallelogram is: %.3f\n", area);
    return 0;
}
 ETP 
 
 C Program to Compute the Surface Area & Volume of a Cube 
================================ EOPN
/*
 * C program to compute the surface area and volume of a cube
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm45.c -lm
$ a.out
Enter the length of a side
34
Surface area = 6936.00 and Volume = 39304.00
--------------------------------

#include <stdio.h>
#include <math.h>
 
void main()
{
    float side, surfacearea, volume;
 
    printf("Enter the length of a side \n");
    scanf("%f", &side);
    surfacearea = 6.0 * side * side;
    volume = pow(side, 3);
    printf("Surface area = %6.2f and Volume = %6.2f \n", surfacearea,
     volume);
}
 ETP 
 
 C Program to Find the Areas of Different Geometrical Figures  
================================ EOPN
/*
 * C program to find the areas of different geometrical shapes such as
 * circle, square, rectangle etc using switch statements.
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm77.c
$ a.out
-------------------------
 1 --> Circle
 2 --> Rectangle
 3 --> Triangle
 4 --> Square
-------------------------
Enter the Figure code
1
Enter the radius
30
Area of a circle = 2827.800049
 
$ a.out
-------------------------
 1 --> Circle
 2 --> Rectangle
 3 --> Triangle
 4 --> Square
-------------------------
Enter the Figure code
2
Enter the breadth and length
20 30
Area of a Reactangle = 600.000000
 
$ a.out
-------------------------
 1 --> Circle
 2 --> Rectangle
 3 --> Triangle
 4 --> Square
-------------------------
Enter the Figure code
3
Enter the base and height
45 80
Area of a Triangle = 1800.000000
 
$ a.out
-------------------------
 1 --> Circle
 2 --> Rectangle
 3 --> Triangle
 4 --> Square
-------------------------
Enter the Figure code
4
Enter the side
100
Area of a Square=10000.000000
--------------------------------

#include <stdio.h>
 
void main()
{
    int fig_code;
    float side, base, length, breadth, height, area, radius;
 
    printf("-------------------------\n");
    printf(" 1 --> Circle\n");
    printf(" 2 --> Rectangle\n");
    printf(" 3 --> Triangle\n");
    printf(" 4 --> Square\n");
    printf("-------------------------\n");
    printf("Enter the Figure code\n");
    scanf("%d", &fig_code);
    switch(fig_code)
    {
    case 1:
        printf("Enter the radius\n");
        scanf("%f", &radius);
        area = 3.142 * radius * radius;
        printf("Area of a circle = %f\n", area);
        break;
    case 2:
        printf("Enter the breadth and length\n");
        scanf("%f %f", &breadth, &length);
        area = breadth * length;
        printf("Area of a Reactangle = %f\n", area);
        break;
    case 3:
        printf("Enter the base and height\n");
        scanf("%f %f", &base, &height);
        area = 0.5 * base * height;
        printf("Area of a Triangle = %f\n", area);
        break;
    case 4:
        printf("Enter the side\n");
        scanf("%f", &side);
        area = side * side;
        printf("Area of a Square=%f\n", area);
        break;
    default:
        printf("Error in figure code\n");
        break;
    }
}
 ETP 
 
 C Program to Find the Volume and Surface Area of cylinder 
================================ EOPN
/*
 * C Program to Find the Volume and Surface Area of cylinder
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm29.c -lm
$ a.out
Enter  value for  radius and height of a cylinder :
15 17
Surface area of cylinder is: 2880.000
Volume of cylinder is : 11475.000
--------------------------------

#include <stdio.h>
#include <math.h>
 
int main()
{
 
    float radius, height;
    float surface_area, volume;
 
    printf("Enter  value for  radius and height of a cylinder : \n");
    scanf("%f%f", &radius, &height);
    surface_area = 2 * (22 / 7) * radius * (radius + height);
    volume = (22 / 7) * radius * radius * height;
    printf("Surface area of cylinder is: %.3f", surface_area);
    printf("\n Volume of cylinder is : %.3f", volume);
    return 0;
}
 ETP 
 
C Program to Find the Volume and Surface Area of Cuboids
================================ EOPN
/*
 * C Program to Find the Volume and Surface Area of Cuboids
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm28.c -lm
$ a.out
Enter value of width, length & height of the cuboids :
 22 23 24
Surface area of cuboids is: 3172.000
Volume of cuboids is : 12144.000
Space diagonal of cuboids is : 39.862
--------------------------------

#include <stdio.h>
#include <math.h>
 
int main()
{
    float width, length, height;
    float surfacearea, volume, space_diagonal;
 
    printf("Enter value of width, length & height of the cuboids:\n");
    scanf("%f%f%f", &width, &length, &height);
    surfacearea = 2 *(width * length + length * height +
    height * width);
    volume = width * length * height;
    space_diagonal = sqrt(width * width + length * length +
    height * height);
    printf("Surface area of cuboids is: %.3f", surfacearea);
    printf("\n Volume of cuboids is : %.3f", volume);
    printf("\n Space diagonal of cuboids is : %.3f", space_diagonal);
    return 0;
}
 ETP 
 
C Program to Find the Surface Area and Volume of a Cone
================================ EOPN
/*
 * C Program to Find the volume and surface area of cone
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm31.c -lm
$ a.out
Enter value of radius and height of a cone :
 6 9
Surface area of cone is: 302.700
Volume of cone is : 324.000
--------------------------------

#include <stdio.h>
#include <math.h>
 
int main()
{
 
    float radius, height;
    float surface_area, volume;
 
    printf("Enter value of radius and height of a cone :\n ");
    scanf("%f%f", &radius, &height);
    surface_area = (22 / 7) * radius * (radius + sqrt(radius * radius + height * height));
    volume = (1.0/3) * (22 / 7) * radius * radius * height;
    printf("Surface area of cone is: %.3f", surface_area);
    printf("\n Volume of cone is : %.3f", volume);
    return 0;
}
 ETP 
 
C Program to Find the Volume and Surface Area of Sphere
================================ EOPN
/*
 * C Program to Find Volume and Surface Area of Sphere
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm30.c
$ a.out
Enter radius of the sphere :
40
Surface area of sphere is: 19200.000
Volume of sphere is : 256000.000
--------------------------------

 #include <stdio.h>
#include <math.h>
 
int main()
{
 
    float radius;
    float surface_area, volume;
 
    printf("Enter radius of the sphere : \n");
    scanf("%f", &radius);
    surface_area =  4 * (22/7) * radius * radius;
    volume = (4.0/3) * (22/7) * radius * radius * radius;
    printf("Surface area of sphere is: %.3f", surface_area);
    printf("\n Volume of sphere is : %.3f", volume);
    return 0;
}
 ETP 
 
C Program to Find the Perimeter of a Circle, Rectangle and Triangle
================================ EOPN
/*
 * C Program to Find the Perimeter of a Circle, Rectangle and Triangle
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm32.c -lm
$ a.out
 Perimeter of rectangle
---------------------------
 
Enter width and length of the rectangle : 12 13
Perimeter of rectangle is: 50.000
 
Perimeter of triangle
---------------------------
 
Enter the size of all sides of the triangle : 12 16 18
Perimeter of triangle is: 46.000
 
Perimeter of circle
---------------------------
 
Enter the radius of the circle : 10
Perimeter of circle is: 60.000
 
Perimeter of equilateral triangle
---------------------------
 
Enter any side of the equilateral triangle : 19 34
Perimeter of equilateral triangle is: 57.000
 
Perimeter of right angled triangle
---------------------------
 
Enter the width and height of the right angled triangle : 5 7
Perimeter of right angled triangle is: 73.366
--------------------------------

#include <stdio.h>
#include <math.h>
 
int main()
{
    float radius, length, width, a, b, c, height;
    int n;
    float perimeter;
 
    //Perimeter of rectangle
    printf(" \n Perimeter of rectangle \n");
    printf("---------------------------\n");
    printf("\n Enter width and length of the rectangle : ");
    scanf("%f%f", &width,& length);
    perimeter = 2 * (width + length);
    printf("Perimeter of rectangle is: %.3f", perimeter);
 
    //Perimeter of triangle
    printf("\n Perimeter of triangle n");
    printf("---------------------------n");
    printf("\n Enter the size of all sides of the triangle : ");
    scanf("%f%f%f", &a, &b, &c);
    perimeter = a + b + c;
    printf("Perimeter of triangle is: %.3f", perimeter);
 
    //Perimeter of circle
    printf(" \n Perimeter of circle \n");
    printf("---------------------------\n");
    printf("\n Enter the radius of the circle : ");
    scanf("%f", &radius);
    perimeter = 2 * (22 / 7) * radius;
    printf("Perimeter of circle is: %.3f", perimeter);
 
    //Perimeter of equilateral triangle
    printf(" \n Perimeter of equilateral triangle \n");
    printf("---------------------------\n");
    printf("\n Enter any side of the equilateral triangle : ");
    scanf("%f", &a);
    perimeter = 3 * a;
    printf("Perimeter of equilateral triangle is: %.3f", perimeter);
 
    //Perimeter of right angled triangle
    printf(" \n Perimeter of right angled triangle \n");
    printf("---------------------------\n");
    printf("\n Enter the width and height of the right angled triangle : ");
    scanf("%f%f", &width, &height);
    perimeter = width + height + sqrt(width * width + height * height);
    printf("Perimeter of right angled triangle is: %.3f", perimeter);
    return 0;
}
 ETP 
 
C Program to Display Floyd’s Triangle
================================ EOPN
/*
 * C Program to Display Floyd’s triangle
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm36.c
$ a.out
floyds triangle is
1
 
2 3
 
4 5 6
 
7 8 9 10
 
11 12 13 14 15
 
16 17 18 19 20 21
--------------------------------

#include <stdio.h>
 
main( )
{
    int i, j, k = 1;
 
    printf("floyds triangle is\n");
    for( i = 1; k <= 20; ++i )
    {
        for( j = 1; j <= i; ++j )
        printf( "%d ", k++ );
        printf( "\n\n" );
    }
    return 0;
}
 ETP 
 
C Program to Display Pascal triangle
================================ EOPN
/*
 * C Program to Display Pascal triangle
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm37.c
$ a.out
 
enter the number of rows:2
                             1
                           1   1
--------------------------------

#include <stdio.h>
 
void main()
{
    int array[15][15], i, j, rows, num = 25, k;
 
    printf("\n enter the number of rows:");
    scanf("%d", &rows);
    for (i = 0; i < rows; i++)
    {
        for (k = num - 2 * i; k >= 0; k--)
            printf(" ");
        for (j = 0; j <= i; j++)
        {
                if (j == 0 || i == j)
        {
                    array[i][j] = 1;
                }
                else
                {
                    array[i][j] = array[i - 1][j - 1] + array[i - 1][j];
        }
        printf("%4d", array[i][j]);
            }
            printf("\n");
    }
}
 ETP 
 
C Program to Calculate the Value of nPr
================================ EOPN
/*
 * C program to Calculate the Value of nPr
 
================================ EOKW
--------------------------------
output:
 
Output:
$ cc pgm13.c
$ a.out
40320
Enter value for n and r
5 4
 
Permutation values is = 120
--------------------------------

#include <stdio.h>
 
void main(void)
{
   printf("%d\n", fact(8));
   int n, r;
   printf("Enter value for n and r\n");
   scanf("%d%d", &n, &r);
   int npr = fact(n) / fact(n - r);
   printf("\n Permutation values is = %d", npr);
}
 
int fact(int x)
{
   if (x <= 1)
       return 1;
   return x * fact(x - 1);
}
 ETP 
 
C Program for Depth First Binary Tree Search using Recursion
================================ EOPN
/* * C Program for Depth First Binary Tree Search using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm34.c
$ a.out
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 5
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 4
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 7
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 8
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 6
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 2
2  4  3  6  8  7  5  
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
void DFS(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Perform DFS Traversal\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
DFS(head);
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default:
printf("Not a valid input, try again\n");
}
} while (choice != 3);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

void DFS(struct node *head)
{
if (head)
{
if (head->left)
{
DFS(head->left);
}
if (head->right)
{
DFS(head->right);
}
printf("%d  ", head->a);
}
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Traverse the Tree Recursively
================================ EOPN
/* * C Program to Traverse the Tree Recursively 
================================ EOKW
--------------------------------
output:
$ pgm36.c
$ a.out
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 5
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 4
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 6
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 2
2   3   4   5   6   
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 3
5   3   2   4   6   
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 4
2   4   3   6   5   
Enter your choice:
1. Insert
2. Traverse via infix
3. Traverse via prefix
4. Traverse via postfix
5. Exit
Choice: 5
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
void infix(struct node *);
void postfix(struct node *);
void prefix(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Traverse via infix\n3.Traverse via prefix\n4. Traverse via postfix\n5. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
infix(head);
break;
case 3:
prefix(head);
break;
case 4:
postfix(head);
break;
case 5:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default: printf("Not a valid input, try again\n");
}
} while (choice != 5);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

void infix(struct node *head)
{
if (head)
{
infix(head->left);
printf("%d   ", head->a);
infix(head->right);
}
}

void prefix(struct node *head)
{
if (head)
{
printf("%d   ", head->a);
prefix(head->left);
prefix(head->right);
}
}

void postfix(struct node *head)
{
if (head)
{
postfix(head->left);
postfix(head->right);
printf("%d   ", head->a);
}
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Reverse a Stack using Recursion
================================ EOPN
/* * C Program to Reverse a Stack using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm40.c
$ a.out
Enter length of list: 10
 
The sequence of contents in stack
1  2  3  4  5  6  7  8  9  10  
Inversing the contents of the stack
 
The contents in stack after reversal
10  9  8  7  6  5  4  3  2  1
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void stack_reverse(struct node **, struct node **);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nThe sequence of contents in stack\n");
display(head);
printf("\nInversing the contents of the stack\n");
if (head != NULL)
{
stack_reverse(&head, &(head->next));
}
printf("\nThe contents in stack after reversal\n");
display(head);
delete(&head);

return 0;
}

void stack_reverse(struct node **head, struct node **head_next)
{
struct node *temp;

if (*head_next != NULL)
{
temp = (*head_next)->next;
(*head_next)->next = (*head);
*head = *head_next;
*head_next = temp;
stack_reverse(head, head_next);
}
}

void display(struct node *head)
{
if (head != NULL)
{
printf("%d  ", head->a);
display(head->next);
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to find the Length of the String using Recursion 
================================ EOPN
/* * Recursive C program to find length of a linked list 
================================ EOKW
--------------------------------
output:
Enter the string:
Sanfoundry C Programming
The length of the given string is: 24
 
Enter the string:
Programming Examples
The length of the given string is: 20
--------------------------------
#include <stdio.h>

int find_len (char [], int);

int main ()
{
char str[100];
int len = 0;

printf ("Enter the string: \n");
scanf ("%[^\n]s", str);

len = find_len (str, 0);

printf ("The length of the given string is: %d\n", len);
return 0;
}

int find_len (char str[], int index)
{
static int l = 0;

if (str[index] == '\0')
return l;
else
l ++;

find_len (str, index + 1);
}
 ETP 
 
C Program to Implement Selection Sort Recursively
================================ EOPN
/* * C Program to Implement Selection Sort Recursively 
================================ EOKW
--------------------------------
output:
$ cc pgm18.c
$ a.out
Enter the size of the list: 5
Enter the elements in list:
23
45
64
12
34
The sorted list in ascending order is
12  23  34  45  64
--------------------------------
#include <stdio.h>

void selection(int [], int, int, int, int);

int main()
{
int list[30], size, temp, i, j;

printf("Enter the size of the list: ");
scanf("%d", &size);
printf("Enter the elements in list:\n");
for (i = 0; i < size; i++)
{
scanf("%d", &list[i]);
}
selection(list, 0, 0, size, 1);
printf("The sorted list in ascending order is\n");
for (i = 0; i < size; i++)
{
printf("%d  ", list[i]);
}

return 0;
}

void selection(int list[], int i, int j, int size, int flag)
{
int temp;

if (i < size - 1)
{
if (flag)
{
j = i + 1;
}
if (j < size)
{
if (list[i] > list[j])
{
temp = list[i];
list[i] = list[j];
list[j] = temp;
}
selection(list, i, j + 1, size, 0);
}
selection(list, i + 1, 0, size, 1);
}
}
 ETP 
 
C Program to Input Few Numbers & Perform Merge Sort on them using Recursion
================================ EOPN
/* * C Program to Input Few Numbers & Perform Merge Sort on them using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm28.c
$ a.out
Enter total number of elements:5
Enter the elements:
12
36
22
76
54
After merge sort:
12   22   36   54   76
--------------------------------

#include <stdio.h>

void mergeSort(int [], int, int, int);
void partition(int [],int, int);

int main()
{
int list[50];
int i, size;

printf("Enter total number of elements:");
scanf("%d", &size);
printf("Enter the elements:\n");
for(i = 0; i < size; i++)
{
scanf("%d", &list[i]);
}
partition(list, 0, size - 1);
printf("After merge sort:\n");
for(i = 0;i < size; i++)
{
printf("%d   ",list[i]);
}

return 0;
}

void partition(int list[],int low,int high)
{
int mid;

if(low < high)
{
mid = (low + high) / 2;
partition(list, low, mid);
partition(list, mid + 1, high);
mergeSort(list, low, mid, high);
}
}

void mergeSort(int list[],int low,int mid,int high)
{
int i, mi, k, lo, temp[50];

lo = low;
i = low;
mi = mid + 1;
while ((lo <= mid) && (mi <= high))
{
if (list[lo] <= list[mi])
{
temp[i] = list[lo];
lo++;
}
else
{
temp[i] = list[mi];
mi++;
}
i++;
}
if (lo > mid)
{
for (k = mi; k <= high; k++)
{
temp[i] = list[k];
i++;
}
}
else
{
for (k = lo; k <= mid; k++)
{
temp[i] = list[k];
i++;
}
}

for (k = low; k <= high; k++)
{
list[k] = temp[k];
}
}
 ETP 
 
C Program to find the Nth Fibonacci Number using Recursion
================================ EOPN
/* * C Program to find the nth number in Fibonacci series using recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm9.c
$ a.out
Enter the nth number in fibonacci series: 8
The 8 number in fibonacci series is 21
 
$ a.out
Enter the nth number in fibonacci series: 12
The 12 number in fibonacci series is 144
--------------------------------
#include <stdio.h>
int fibo(int);

int main()
{
int num;
int result;

printf("Enter the nth number in fibonacci series: ");
scanf("%d", &num);
if (num < 0)
{
printf("Fibonacci of negative number is not possible.\n");
}
else
{
result = fibo(num);
printf("The %d number in fibonacci series is %d\n", num, result);
}
return 0;
}
int fibo(int num)
{
if (num == 0)
{
return 0;
}
else if (num == 1)
{
return 1;
}
else
{
return(fibo(num - 1) + fibo(num - 2));
}
}
 ETP 
 
C Program to find the Biggest Number in an Array of Numbers using Recursion
================================ EOPN
     /*     * C Program to find the Biggest Number in an Array of Numbers using      * Recursion     
================================ EOKW
--------------------------------
output:
Enter size of the list:8
Printing the list:
7   6   1   3   1   7   2   4
The largest number in the list is: 7
--------------------------------

#include <stdio.h>
int large(int[], int, int);

int main()
{

int size;
int largest;
int list[20];
int i;

printf("Enter size of the list:");
scanf("%d", &size);

printf("Printing the list:\n");
for (i = 0; i < size ; i++)
{
list[i] = rand() % size;
printf("%d \t", list[i]);
}

if (size == 0)
{
printf("Empty list\n");
}

else
{
largest = list[0];
largest = large(list, size - 1, largest);
printf("\nThe largest number in the list is: %d\n", largest);
}

}

int large(int list[], int position, int largest)
{

if (position == 0)
return largest;

if (position > 0)
{
if (list[position] > largest)
{
largest = list[position];
}
return large(list, position - 1, largest);
}

}
 ETP 
 
C Program to find Sum of Digits of a Number using Recursion
================================ EOPN
/*  
 * C Program to find Sum of Digits of a Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm25.c
$ a.out
Enter the number: 2345
Sum of digits in 2345 is 14
--------------------------------

#include <stdio.h>
 
int sum (int a);
 
int main()
{
    int num, result;
 
    printf("Enter the number: ");
    scanf("%d", &num);
    result = sum(num);
    printf("Sum of digits in %d is %d\n", num, result);
    return 0;
}
 
int sum (int num)
{
    if (num != 0)
    {
        return (num % 10 + sum (num / 10));
    }
    else
    {
       return 0;
    }
}
 ETP 
 
C Program to find Sum of N Numbers using Recursion
================================ EOPN
/*  
 * C Program to find Sum of N Numbers using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm33.c
$ a.out
Enter the Nth number: 3
Sum of first N numbers is 6
 
$ a.out
Enter the Nth number: 5
Sum of first N numbers is 15
--------------------------------

#include <stdio.h>
 
void display_sum(int);
 
int main()
{
    int num;
 
    printf("Enter the Nth number: ");
    scanf("%d", &num);
    display_sum(num);
    return 0;
}
 
void display_sum(int num)
{
    static int sum = 0;
 
    if (num == 0)
    {
        printf("Sum of first N numbers is %d\n", sum);
        return;
    }
    else
    {
        sum += num;
        display_sum(--num);
    }
}
 ETP 
 
C Program to Perform Matrix Multiplication using Recursion
================================ EOPN
/* * C Program to Perform Matrix Multiplication using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm23.c
$ a.out
Enter rows and columns for Matrix A respectively: 2
2
Enter rows and columns for Matrix B respectively: 2
2
Enter elements in Matrix A:
12 56
45 78
 
Enter elements in Matrix B:
2 6
5 8
On matrix multiplication of A and B the result is:
304  520  
480  894
--------------------------------
#include <stdio.h>

void multiply(int, int, int [][10], int, int, int [][10], int [][10]);
void display(int, int, int[][10]);

int main()
{
int a[10][10], b[10][10], c[10][10] = {0};
int m1, n1, m2, n2, i, j, k;

printf("Enter rows and columns for Matrix A respectively: ");
scanf("%d%d", &m1, &n1);
printf("Enter rows and columns for Matrix B respectively: ");
scanf("%d%d", &m2, &n2);
if (n1 != m2)
{
printf("Matrix multiplication not possible.\n");
}
else
{
printf("Enter elements in Matrix A:\n");
for (i = 0; i < m1; i++)
for (j = 0; j < n1; j++)
{
scanf("%d", &a[i][j]);
}
printf("\nEnter elements in Matrix B:\n");
for (i = 0; i < m2; i++)
for (j = 0; j < n2; j++)
{
scanf("%d", &b[i][j]);
}
multiply(m1, n1, a, m2, n2, b, c);
}
printf("On matrix multiplication of A and B the result is:\n");
display(m1, n2, c);
}

void multiply (int m1, int n1, int a[10][10], int m2, int n2, int b[10][10], int c[10][10])
{
static int i = 0, j = 0, k = 0;

if (i >= m1)
{
return;
}
else if (i < m1)
{
if (j < n2)
{
if (k < n1)
{
c[i][j] += a[i][k] * b[k][j];
k++;
multiply(m1, n1, a, m2, n2, b, c);
}
k = 0;
j++;
multiply(m1, n1, a, m2, n2, b, c);
}
j = 0;
i++;
multiply(m1, n1, a, m2, n2, b, c);
}
}

void display(int m1, int n2, int c[10][10])
{
int i, j;

for (i = 0; i < m1; i++)
{
for (j = 0; j < n2; j++)
{
printf("%d  ", c[i][j]);
}
printf("\n");
}
}
 ETP 
 
C Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
/* * Recursive C program to reverse nodes of a linked list and display  * them 
================================ EOKW
--------------------------------
output:
$ cc pgm.c
$ a.out
LinkedList : 4 3 2 1 
LinkedList in reverse order : 1 2 3 4
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int data;
struct node *next;
};

void print_reverse_recursive (struct node *);
void print (struct node *);
void create_new_node (struct node *, int );

//Driver Function
int main ()
{
struct node *head = NULL;
insert_new_node (&head, 1);
insert_new_node (&head, 2);
insert_new_node (&head, 3);
insert_new_node (&head, 4);
printf ("LinkedList : ");
print (head);
printf ("\nLinkedList in reverse order : ");
print_reverse_recursive (head);
printf ("\n");
return 0;
}

//Recursive Reverse
void print_reverse_recursive (struct node *head)
{
if (head == NULL)
{
return;
}

//Recursive call first
print_reverse_recursive (head -> next);
//Print later
printf ("%d ", head -> data);
}

//Print the linkedlist normal
void print (struct node *head)
{
if (head == NULL)
{
return;
}
printf ("%d ", head -> data);
print (head -> next);
}

//New data added in the start
void insert_new_node (struct node ** head_ref, int new_data)
{
struct node * new_node = (struct node *) malloc (sizeof (struct node));
new_node -> data = new_data;
new_node -> next = (*head_ref);
(*head_ref) = new_node;
}
 ETP 
 
C Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
/* * Recursive C program to display members of a linked list 
================================ EOKW
--------------------------------
output:
$ cc pgm15.c
$ a.out
9    8    7    6    5    4    3    2    1    0
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node*);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
display(head);
delete(&head);
return 0;
}

void generate(struct node **head)
{
int num = 10, i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void display(struct node *head)
{
printf("%d    ", head->a);
if (head->next == NULL)
{
return;
}
display(head->next);
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
/* * C program to find the number of occurences of a given number in a  * list 
================================ EOKW
--------------------------------
output:
$ cc pgm13.c
$ a.out
Enter the size of the list: 7
Printing the list:
1    4    2    5    1    3    3
Enter the key to find it's occurence: 3
3 occurs for 2 times.
--------------------------------
#include <stdio.h>

void occur(int [], int, int, int, int *);

int main()
{
int size, key, count = 0;
int list[20];
int i;

printf("Enter the size of the list: ");
scanf("%d", &size);
printf("Printing the list:\n");
for (i = 0; i < size; i++)
{
list[i] = rand() % size;
printf("%d    ", list[i]);
}
printf("\nEnter the key to find it's occurence: ");
scanf("%d", &key);
occur(list, size, 0, key, &count);
printf("%d occurs for %d times.\n", key, count);
return 0;
}

void occur(int list[], int size, int index, int key, int *count)
{
if (size == index)
{
return;
}
if (list[index] == key)
{
*count += 1;
}
occur(list, size, index + 1, key, count);
}
 ETP 
 
C Program find the Length of the Linked List using Recursion
================================ EOPN
/* * C program to find the length of a string 
================================ EOKW
--------------------------------
output:
$ cc pgm17.c
$ a.out
Enter a word to count it's length: 5
The number of characters in 5 are 1.
 
$ a.out
Enter a word to count it's length: sanfoundry
The number of characters in sanfoundry are 10.
--------------------------------
#include <stdio.h>

int length(char [], int);
int main()
{
char word[20];
int count;

printf("Enter a word to count it's length: ");
scanf("%s", word);
count = length(word, 0);
printf("The number of characters in %s are %d.\n", word, count);
return 0;
}

int length(char word[], int index)
{
if (word[index] == '\0')
{
return 0;
}
return (1 + length(word, index + 1));
}
 ETP 
 
C Program to Perform Binary Search using Recursion
================================ EOPN
/* * C Program to Perform Binary Search using Recursion 
================================ EOKW
--------------------------------
output:
If the input array is {1, 2, 3, 4, 5, 6}
and the key to be searched for is 6
then the expected output will be "Search Successful".
--------------------------------

#include <stdio.h>

void binary_search(int [], int, int, int);
void bubble_sort(int [], int);

int main()
{
int key, size, i;
int list[25];

printf("Enter size of a list: ");
scanf("%d", &size);
printf("Enter elements\n");
for(i = 0; i < size; i++)
{
scanf("%d",&list[i]);
}
bubble_sort(list, size);
printf("\n");
printf("Enter key to search\n");
scanf("%d", &key);
binary_search(list, 0, size, key);

}

void bubble_sort(int list[], int size)
{
int temp, i, j;
for (i = 0; i < size; i++)
{
for (j = i; j < size; j++)
{
if (list[i] > list[j])
{
temp = list[i];
list[i] = list[j];
list[j] = temp;
}
}
}
}

void binary_search(int list[], int lo, int hi, int key)
{
int mid;

if (lo > hi)
{
printf("Key not found\n");
return;
}
mid = (lo + hi) / 2;
if (list[mid] == key)
{
printf("Key found\n");
}
else if (list[mid] > key)
{
binary_search(list, lo, mid - 1, key);
}
else if (list[mid] < key)
{
binary_search(list, mid + 1, hi, key);
}
}
 ETP 
 
C Program to Perform Quick Sort on a set of Entries from a File using Recursion
================================ EOPN
/** C Program to Perform Quick Sort on a set of Entries from a File * using Recursion
================================ EOKW
--------------------------------
output:
$ cc pgm29.c
$ a.out
Enter the number of elements: 6
Enter the elements to be sorted:
67
45
24
98
12
38
After applying quick sort
12 24 38 45 67 98
--------------------------------
#include <stdio.h>

void quicksort (int [], int, int);

int main()
{
int list[50];
int size, i;

printf("Enter the number of elements: ");
scanf("%d", &size);
printf("Enter the elements to be sorted:\n");
for (i = 0; i < size; i++)
{
scanf("%d", &list[i]);
}
quicksort(list, 0, size - 1);
printf("After applying quick sort\n");
for (i = 0; i < size; i++)
{
printf("%d ", list[i]);
}
printf("\n");

return 0;
}
void quicksort(int list[], int low, int high)
{
int pivot, i, j, temp;
if (low < high)
{
pivot = low;
i = low;
j = high;
while (i < j)
{
while (list[i] <= list[pivot] && i <= high)
{
i++;
}
while (list[j] > list[pivot] && j >= low)
{
j--;
}
if (i < j)
{
temp = list[i];
list[i] = list[j];
list[j] = temp;
}
}
temp = list[j];
list[j] = list[pivot];
list[pivot] = temp;
quicksort(list, low, j - 1);
quicksort(list, j + 1, high);
}
}
 ETP 
 
C Program to Reverse the String using Recursion
================================ EOPN
/*
 * C Program to Reverse the String using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm12.c
$ a.out
Enter a string to reverse: malayalam
The string after reversing is: malayalam
 
$ a.out
Enter a string to reverse: cprogramming
The string after reversing is: gnimmargorpc
--------------------------------

#include <stdio.h>
#include <string.h>
 
void reverse(char [], int, int);
int main()
{
    char str1[20];
    int size;
 
    printf("Enter a string to reverse: ");
    scanf("%s", str1);
    size = strlen(str1);
    reverse(str1, 0, size - 1);
    printf("The string after reversing is: %s\n", str1);
    return 0;
}
 
void reverse(char str1[], int index, int size)
{
    char temp;
    temp = str1[index];
    str1[index] = str1[size - index];
    str1[size - index] = temp;
    if (index == size / 2)
    {
        return;
    }
    reverse(str1, index + 1, size);
}
 ETP 
 
C Program to find Reverse of a Number using Recursion
================================ EOPN
/*  
 * C program to find the reverse of a number using recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm34.c
$ a.out
Enter an integer number to reverse: 1234
The reverse of 1234 is 4321.
--------------------------------

#include <stdio.h>
#include <math.h>
 
int rev(int, int);
 
int main()
{
    int num, result;
    int length = 0, temp;
 
    printf("Enter an integer number to reverse: ");
    scanf("%d", &num);
    temp = num;
    while (temp != 0)
    {
        length++;
        temp = temp / 10;
    }
    result = rev(num, length);
    printf("The reverse of %d is %d.\n", num, result);
    return 0;
}
 
int rev(int num, int len)
{
    if (len == 1)
    {
        return num;
    }
    else
    {
        return (((num % 10) * pow(10, len - 1)) + rev(num / 10, --len));
    }
}
 ETP 
 
C Program to Solve Tower-of-Hanoi Problem using Recursion
================================ EOPN
/* * C program for Tower of Hanoi using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm11.c
$ a.out
Enter the number of disks : 3
The sequence of moves involved in the Tower of Hanoi are :
 
Move disk 1 from peg A to peg C
Move disk 2 from peg A to peg B
Move disk 1 from peg C to peg B
Move disk 3 from peg A to peg C
Move disk 1 from peg B to peg A
Move disk 2 from peg B to peg C
Move disk 1 from peg A to peg C
--------------------------------
#include <stdio.h>

void towers(int, char, char, char);

int main()
{
int num;

printf("Enter the number of disks : ");
scanf("%d", &num);
printf("The sequence of moves involved in the Tower of Hanoi are :\n");
towers(num, 'A', 'C', 'B');
return 0;
}
void towers(int num, char frompeg, char topeg, char auxpeg)
{
if (num == 1)
{
printf("\n Move disk 1 from peg %c to peg %c", frompeg, topeg);
return;
}
towers(num - 1, frompeg, auxpeg, topeg);
printf("\n Move disk %d from peg %c to peg %c", num, frompeg, topeg);
towers(num - 1, auxpeg, topeg, frompeg);
}
 ETP 
 
C Program to Copy One String to Another using Recursion
================================ EOPN
/*
 * C Program to Copy One String to Another using Recursion
 
================================ EOKW
--------------------------------
output:
$ gcc recursive-copy.c -o recursive-copy
$ ./recursive-copy
 
Enter string to copy: Welcome to Sanfoundry
Copying success.
 
The first string is: Welcome to Sanfoundry
The second string is: Welcome to Sanfoundry
--------------------------------

#include <stdio.h>
 
void copy(char [], char [], int);
 
int main()
{
    char str1[20], str2[20];
 
    printf("Enter string to copy: ");
    scanf("%[^\n]s", str1);
    copy(str1, str2, 0);
    printf("Copying success.\n");
    printf("The first string is: %s\n", str1);
    printf("The second string is: %s\n", str2);
    return 0;
}
 
void copy(char str1[], char str2[], int index)
{
    str2[index] = str1[index];
    // printf ("INDEX IS %d\n", index);
    if (str1[index] == '\0')
        return;
    copy(str1, str2, index + 1);
}
 ETP 
 
C Program to Check whether a given String is Palindrome or not using Recursion
================================ EOPN
/*  
 * C Program to Check whether a given String is Palindrome or not 
 * using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ gcc palindrome.c -o palindrome
$ a.out
Enter a word to check if it is a palindrome
malayalam
The entered word is a palindrome
--------------------------------

#include <stdio.h>
#include <string.h>
 
void check(char [], int);
 
int main()
{
    char word[15];
 
    printf("Enter a word to check if it is a palindrome\n");
    scanf("%s", word);
    check(word, 0);
 
    return 0;
}
 
void check(char word[], int index)
{
    int len = strlen(word) - (index + 1);
    if (word[index] == word[len])
    {
        if (index + 1 == len || index == len)
        {
            printf("The entered word is a palindrome\n");
            return;
        }
        check(word, index + 1);
    }
    else
    {
        printf("The entered word is not a palindrome\n");
    }
}
 ETP 
 
C Program to find whether a Number is Prime or Not using Recursion
================================ EOPN
/*
 * C Program to find whether a Number is Prime or Not using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm24.c
$ a.out
Enter a number: 456
456 is not a prime number
 
$ a.out
Enter a number: 89
89 is a prime number
--------------------------------

#include <stdio.h>
 
int primeno(int, int);
 
int main()
{
    int num, check;
    printf("Enter a number: ");
    scanf("%d", &num);
    check = primeno(num, num / 2);
    if (check == 1)
    {
        printf("%d is a prime number\n", num);
    }
    else
    {
        printf("%d is not a prime number\n", num);
    }
    return 0;
}
 
int primeno(int num, int i)
{
    if (i == 1)
    {
        return 1;
    }
    else
    {
       if (num % i == 0)
       {
         return 0;
       }
       else
       {
         return primeno(num, i - 1);
       }       
    }
}
 ETP 
 
C Program to find the Factorial of a Number using Recursion
================================ EOPN
/*
 * C Program to find factorial of a given number using recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm5.c
$ a.out
Enter a number to find it's Factorial: 6
The Factorial of 6 is 720.
--------------------------------

#include <stdio.h>
 
int factorial(int);
 
int main()
{
    int num;
    int result;
 
    printf("Enter a number to find it's Factorial: ");
    scanf("%d", &num);
    if (num < 0)
    {
        printf("Factorial of negative number not possible\n");
    }
    else
    {
        result = factorial(num);
        printf("The Factorial of %d is %d.\n", num, result);
    }
    return 0;
}
int factorial(int num)
{
    if (num == 0 || num == 1)
    {
        return 1;
    }
    else
    {
        return(num * factorial(num - 1));
    }
}
 ETP 
 
C Program to find LCM of a Number using Recursion
================================ EOPN
/*
 * C Program to Find LCM of a Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm22.c
$ a.out
Enter two numbers: 456
12
The LCM of 456 and 12 is 456
 
$ a.out
Enter two numbers: 45 75
The LCM of 45 and 75 is 225
--------------------------------

#include <stdio.h>
 
int lcm(int, int);
 
int main()
{
    int a, b, result;
    int prime[100];
 
    printf("Enter two numbers: ");
    scanf("%d%d", &a, &b);
    result = lcm(a, b);
    printf("The LCM of %d and %d is %d\n", a, b, result);
    return 0;
}
 
int lcm(int a, int b)
{ 
    static int common = 1;
 
    if (common % a == 0 && common % b == 0)
    {
        return common;
    }
    common++;
    lcm(a, b);
    return common;
}
 ETP 
 
C Program to find GCD of given Numbers using Recursion
================================ EOPN
/*
 * C Program to find GCD of given Numbers using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ gcc gcd_recr.c -o gcd_recr
$ a.out
Enter the two numbers to find their GCD: 100 70
The GCD of 100 and 70 is 10.
--------------------------------

#include <stdio.h>
 
int gcd(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter the two numbers to find their GCD: ");
    scanf("%d%d", &a, &b);
    result = gcd(a, b);
    printf("The GCD of %d and %d is %d.\n", a, b, result);
}
 
int gcd(int a, int b)
{
    while (a != b)
    {
        if (a > b)
        {
            return gcd(a - b, b);
        }
        else
        {
            return gcd(a, b - a);
        }
    }
    return a;
}
 ETP 
 
C Program to find HCF of a given Number using Recursion
================================ EOPN
/*
 * C Program to find HCF of a given Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm32.c
$ a.out
Enter the two numbers to find their HCF: 24 36
The HCF of 24 and 36 is 12.
--------------------------------

#include <stdio.h>
 
int hcf(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter the two numbers to find their HCF: ");
    scanf("%d%d", &a, &b);
    result = hcf(a, b);
    printf("The HCF of %d and %d is %d.\n", a, b, result);
}
 
int hcf(int a, int b)
{
    while (a != b)
    {
        if (a > b)
        {
            return hcf(a - b, b);
        }
        else
        {
            return hcf(a, b - a);
        }
    }
    return a;
}
 ETP 
 
C Program to find Product of 2 Numbers using Recursion
================================ EOPN
/*  
 * C Program to find Product of 2 Numbers using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm20.c
$ a.out
Enter two numbers to find their product: 176 340
Product of 176 and 340 is 59840
--------------------------------

#include <stdio.h>
 
int product(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter two numbers to find their product: ");
    scanf("%d%d", &a, &b);
    result = product(a, b);
    printf("Product of %d and %d is %d\n", a, b, result);
    return 0;
}
 
int product(int a, int b)
{
    if (a < b)
    {
        return product(b, a);
    }
    else if (b != 0)
    {
        return (a + product(a, b - 1));
    }
    else
    {
        return 0;
    }
}
 ETP 
 
C Program to find Power of a Number using Recursion
================================ EOPN
/*
 * C Program to find Power of a Number using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm30.c
$ a.out
Enter a number: 456
Enter it's power: 3
456^3 is 94818816
--------------------------------

#include <stdio.h>
 
long power (int, int);
 
int main()
{
    int pow, num;
    long result;
 
    printf("Enter a number: ");
    scanf("%d", &num);
    printf("Enter it's power: ");
    scanf("%d", &pow);
    result = power(num, pow);
    printf("%d^%d is %ld", num, pow, result);
    return 0;
}
 
long power (int num, int pow)
{
    if (pow)
    {
        return (num * power(num, pow - 1));
    }
    return 1;
}
 ETP 
 
C Program to Print Binary Equivalent of an Integer using Recursion
================================ EOPN
/*  
 * C Program to Print Binary Equivalent of an Integer using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ gcc binary_recr.c -o binary_recr
$ a.out
Enter a decimal number: 10
The binary equivalent of 10 is 1010
--------------------------------

#include <stdio.h>
 
int binary_conversion(int);
 
int main()
{
   int num, bin;
 
   printf("Enter a decimal number: ");
   scanf("%d", &num);
   bin = binary_conversion(num);
   printf("The binary equivalent of %d is %d\n", num, bin);
}
 
int binary_conversion(int num)
{
    if (num == 0)
    {
        return 0;
    }
    else
    {
        return (num % 2) + 10 * binary_conversion(num / 2);
    }
}
 ETP 
 
C Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
/* * C Program to Print the Alternate Nodes in a Linked List using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc alter_display.c -o alter_display
$ a.out
Enter length of list: 10
 
Displaying the alternate nodes
1  3  5  7  9
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nDisplaying the alternate nodes\n");
display(head);
delete(&head);

return 0;
}

void display(struct node *head)
{
static flag = 0;
if(head != NULL)
{
if (!(flag % 2))
{
printf("%d  ", head->a);
}
flag++;
display(head->next);
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program to Convert a Number Decimal System to Binary System using Recursion
================================ EOPN
/*  
 * C Program to Convert a Number Decimal System to Binary System using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm31.c
$ a.out
Enter a decimal number: 10
The binary equivalent of 10 is 1010.
--------------------------------

#include <stdio.h>
 
int convert(int);
 
int main()
{
    int dec, bin;
 
    printf("Enter a decimal number: ");
    scanf("%d", &dec);
    bin = convert(dec);
    printf("The binary equivalent of %d is %d.\n", dec, bin);
 
    return 0;
}
 
int convert(int dec)
{
    if (dec == 0)
    {
        return 0;
    }
    else
    {
        return (dec % 2 + 10 * convert(dec / 2));
    }
}
 ETP 
 
C Program to find the First Capital Letter in a String using Recursion
================================ EOPN
/*
 * C Program to find the first capital letter in a string using 
 * Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm32.c
$ a.out
Enter a string to find it's first capital letter: iloveC
The first capital letter in iloveC is C.
--------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
 
char caps_check(char *);
 
int main()
{
    char string[20], letter;
 
    printf("Enter a string to find it's first capital letter: ");
    scanf("%s", string);
    letter = caps_check(string);
    if (letter == 0)
    {
        printf("No capital letter is present in %s.\n", string);
    }
    else
    {
        printf("The first capital letter in %s is %c.\n", string, letter);    }
        return 0;
    }
    char caps_check(char *string)
    {
        static int i = 0;
        if (i < strlen(string))
        {
            if (isupper(string[i]))
            {
                return string[i];
            }
            else
            {
                i = i + 1;
                return caps_check(string);
            }
        }
        else return 0;
    }
 ETP 
 
C Program to Search an Element in a Tree Non-Recursively
================================ EOPN
/* * C Program to Traverse the Tree Non-Recursively 
================================ EOKW
--------------------------------
output:
$ cc pgm37.c
$ a.out
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 1
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 
4
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 1
Key found in tree
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 6
Key not found
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
printf("Enter key to search: ");
scanf("%d", &key);
flag = search(head, key);
if (flag)
{
printf("Key found in tree\n");
}
else
{
printf("Key not found\n");
}
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default: printf("Not a valid input, try again\n");
}
} while (choice != 3);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

int search(struct node *head, int key)
{
while (head != NULL)
{
if (key > head->a)
{
head = head->right;
}
else if (key < head->a)
{
head = head->left;
}
else
{
return 1;
}
}
return 0;
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to Traverse the Tree Non-Recursively
================================ EOPN
/* * C Program to Traverse the Tree Non-Recursively 
================================ EOKW
--------------------------------
output:
$ cc pgm37.c
$ a.out
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 1
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 1
Enter element to insert: 
4
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 1
Key found in tree
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 2
Enter key to search: 6
Key not found
 
Enter your choice:
1. Insert
2. Search
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
};

void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
printf("Enter key to search: ");
scanf("%d", &key);
flag = search(head, key);
if (flag)
{
printf("Key found in tree\n");
}
else
{
printf("Key not found\n");
}
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default: printf("Not a valid input, try again\n");
}
} while (choice != 3);
return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
if (num >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

int search(struct node *head, int key)
{
while (head != NULL)
{
if (key > head->a)
{
head = head->right;
}
else if (key < head->a)
{
head = head->left;
}
else
{
return 1;
}
}
return 0;
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
/* * C Program for Depth First Binary Tree Search without using  * Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm33.c
$ a.out
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 5
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 3
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 2
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 4
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 1
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 7
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 6
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 1
Enter element to insert: 8
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 2
On DFS traversal we get:
1  2  4  3  6  8  7  5  
 
Enter your choice:
1. Insert
2. Perform DFS Traversal
3. Exit
Choice: 3
Memory Cleared
PROGRAM TERMINATED
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *left;
struct node *right;
int visited;
};

void generate(struct node **, int);
void DFS(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int choice = 0, num, flag = 0, key;

do
{
printf("\nEnter your choice:\n1. Insert\n2. Perform DFS Traversal\n3. Exit\nChoice: ");
scanf("%d", &choice);
switch(choice)
{
case 1:
printf("Enter element to insert: ");
scanf("%d", &num);
generate(&head, num);
break;
case 2:
DFS(head);
break;
case 3:
delete(&head);
printf("Memory Cleared\nPROGRAM TERMINATED\n");
break;
default:
printf("Not a valid input, try again\n");
}
} while (choice != 3);

return 0;
}

void generate(struct node **head, int num)
{
struct node *temp = *head, *prev = *head;

if (*head == NULL)
{
*head = (struct node *)malloc(sizeof(struct node));
(*head)->a = num;
(*head)->visited = 0;
(*head)->left = (*head)->right = NULL;
}
else
{
while (temp != NULL)
{
if (num > temp->a)
{
prev = temp;
temp = temp->right;
}
else
{
prev = temp;
temp = temp->left;
}
}
temp = (struct node *)malloc(sizeof(struct node));
temp->a = num;
temp->visited = 0;
if (temp->a >= prev->a)
{
prev->right = temp;
}
else
{
prev->left = temp;
}
}
}

void DFS(struct node *head)
{
struct node *temp = head, *prev;

printf("On DFS traversal we get:\n");
while (temp && !temp->visited)
{
if (temp->left && !temp->left->visited)
{
temp = temp->left;
}
else if (temp->right && !temp->right->visited)
{
temp = temp->right;
}
else
{
printf("%d  ", temp->a);
temp->visited = 1;
temp = head;
}
}
}

void delete(struct node **head)
{
if (*head != NULL)
{
if ((*head)->left)
{
delete(&(*head)->left);
}
if ((*head)->right)
{
delete(&(*head)->right);
}
free(*head);
}
}
 ETP 
 
C Program to find HCF of a given Number without using Recursion
================================ EOPN
/* * C Program to find HCF of a given Number without using Recursion 
================================ EOKW
--------------------------------
output:
$ cc pgm31.c
$ a.out
Enter the two numbers to find their HCF: 24 36
The HCF of 24 and 36 is 12.
--------------------------------
#include <stdio.h>

int hcf(int, int);

int main()
{
int a, b, result;

printf("Enter the two numbers to find their HCF: ");
scanf("%d%d", &a, &b);
result = hcf(a, b);
printf("The HCF of %d and %d is %d.\n", a, b, result);

return 0;
}

int hcf(int a, int b)
{
while (a != b)
{
if (a > b)
{
a = a - b;
}
else
{
b = b - a;
}
}
return a;
}
 ETP 
 
C Program to Solve the Magic Squares Puzzle without using Recursion
================================ EOPN
/*
 * C Program to Solve the Magic Squares Puzzle without using 
 * Recursion
 
================================ EOKW
--------------------------------
output:
$ cc pgm27.c
$ a.out
Enter the size: 6
Magic square works for an odd numbered size
 
$ a.out
Enter the size: 5
17  24  1  8  15  
23  5  7  14  16  
4  6  13  20  22  
10  12  19  21  3  
11  18  25  2  9
--------------------------------

#include <stdio.h>
 
void magicsq(int, int [][10]);
 
int main( )
{
    int size;
    int a[10][10];
 
    printf("Enter the size: ");
    scanf("%d", &size);
    if (size % 2 == 0)
    {
        printf("Magic square works for an odd numbered size\n");
    }
    else
    {
        magicsq(size, a);
    }
    return 0;
}
 
void magicsq(int size, int a[][10])
{
    int sqr = size * size;
    int i = 0, j = size / 2, k;
 
    for (k = 1; k <= sqr; ++k) 
    {
        a[i][j] = k;
        i--;
        j++;
 
        if (k % size == 0) 
        { 
            i += 2; 
            --j; 
        }
        else 
        {
            if (j == size) 
            {
                j -= size;
            }
            else if (i < 0)
            {
                i += size;
            }
        }
    }
    for (i = 0; i < size; i++)
    {
        for (j = 0; j < size; j++)
        {
            printf("%d  ", a[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}
 ETP 
 
C Program to Convert Binary Code of a Number into its Equivalent Gray’s Code without using Recursion
================================ EOPN
/*  
 * C Program to Convert Binary Code of a Number into its Equivalent 
 * Gray's Code without using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm26.c -lm
$ a.out
Enter a binary number: 1111001010
The gray code of 1111001010 is 1000101111
--------------------------------

#include <stdio.h>
#include <math.h>
 
int bintogray(int);
 
int main ()
{
    int bin, gray;
 
    printf("Enter a binary number: ");
    scanf("%d", &bin);
    gray = bintogray(bin);
    printf("The gray code of %d is %d\n", bin, gray);
    return 0;
}
 
int bintogray(int bin)
{
    int a, b, result = 0, i = 0;
 
    while (bin != 0)
    {
        a = bin % 10;
        bin = bin / 10;
        b = bin % 10;
        if ((a && !b) || (!a && b))
        {
            result = result + pow(10, i);
        }
        i++;
    }
    return result;
}
 ETP 
 
C Program to find Product of 2 Numbers without using Recursion
================================ EOPN
/*  
 * C Program to find Product of 2 Numbers without using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm19.c
$ a.out
Enter two numbers to find their product:  89  458
Product of 89 and 458 is 40762
--------------------------------

 
#include <stdio.h>
 
int product(int, int);
 
int main()
{
    int a, b, result;
 
    printf("Enter two numbers to find their product: ");
    scanf("%d%d", &a, &b);
    result = product(a, b);
    printf("Product of %d and %d is %d\n", a, b, result);
    return 0;
}
 
int product(int a, int b)
{
    int temp = 0;
 
    while (b != 0)
    {
        temp += a;
        b--;
    }
    return temp;
}
 ETP 
 
C Program to Convert Binary Code of a Number into its Equivalent Gray’s Code using Recursion
================================ EOPN
/* 
 * C Program to Convert Binary Code of a Number into its Equivalent 
 * Gray's Code using Recursion
 
================================ EOKW
--------------------------------
output:
 
$ cc pgm21.c
$ a.out
Enter a binary number:  1011101
The gray code of 1011101 is 1110011
--------------------------------

#include <stdio.h>
 
int bintogray(int);
 
int main ()
{
    int bin, gray;
 
    printf("Enter a binary number: ");
    scanf("%d", &bin);
    gray = bintogray(bin);
    printf("The gray code of %d is %d\n", bin, gray);
    return 0;
}
 
int bintogray(int bin)
{
    int a, b, result = 0, i = 0;
 
    if (!bin)
    {
        return 0;
    }
    else
    {
        a = bin % 10;
        bin = bin / 10;
        b = bin % 10;
        if ((a && !b) || (!a && b))
        {
            return (1 + 10 * bintogray(bin));
        }
        else
        {
            return (10 * bintogray(bin));
        }
    }
}
 ETP 
 
C Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
/* * C Program to Print the Alternate Nodes in a Linked List without  * using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc alter_iter.c -o alter_iter
$ a.out
Enter length of list: 20
 
Displaying the alternate nodes
1  3  5  7  9  11  13  15  17  19
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node *);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
printf("\nDisplaying the alternate nodes\n");
display(head);
delete(&head);

return 0;
}

void display(struct node *head)
{
int flag = 0;

while(head != NULL)
{
if (!(flag % 2))
{
printf("%d  ", head->a);
}
flag++;
head = head->next;
}
}

void generate(struct node **head)
{
int num, i;
struct node *temp;

printf("Enter length of list: ");
scanf("%d", &num);
for (i = num; i > 0; i--)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}}
 ETP 
 
C Program find the Length of the Linked List without using Recursion
================================ EOPN
/* * C Program find the Length of the Linked List without using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc numbernode.c -o numbernode
$ a.out
The number of nodes are: 10
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};


void generate(struct node **);
int length(struct node*);
void delete(struct node **);

int main()
{
struct node *head = NULL;
int count;

generate(&head);
count = length(head);
printf("The number of nodes are: %d\n", count);
delete(&head);

return 0;
}

void generate(struct node **head)
{
/* for unknown number of nodes use num = rand() % 20; */
int num = 10, i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

int length(struct node *head)
{
int num = 0;
while (head != NULL)
{
num += 1;
head = head->next;
}
return num;
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
C Program Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
/* * C Program Count the Number of Occurrences of an Element in the Linked List  * without using Recursion 
================================ EOKW
--------------------------------
output:
$ gcc occurnumber.c -o occurnumber
$ a.out
Enter the size of the list: 10
Printing the list:
3    6    7    5    3    5    6    2    9    1   
Enter the key to find it's occurence: 3
3 occurs for 2 times.
--------------------------------
#include <stdio.h>

int occur(int [], int, int);

int main()
{
int size, key, count;
int list[20];
int i;

printf("Enter the size of the list: ");
scanf("%d", &size);
printf("Printing the list:\n");
for (i = 0; i < size; i++)
{
list[i] = rand() % size;
printf("%d    ", list[i]);
}
printf("\nEnter the key to find it's occurence: ");
scanf("%d", &key);
count = occur(list, size, key);
printf("%d occurs for %d times.\n", key, count);
return 0;
}

int occur(int list[], int size, int key)
{
int i, count = 0;

for (i = 0; i < size; i++)
{
if (list[i] == key)
{
count += 1;
}
}
return count;
}
 ETP 
 
C Program to Display all the Nodes in a Linked List without using Recursion
================================ EOPN
/* * C Program to Display all the Nodes in a Linked List without using  * Recursion 
================================ EOKW
--------------------------------
output:
$ gcc linkdisplay.c -o linkdisplay
$ a.out
9   8   7   6   5   4   3   2   1   0
--------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node
{
int a;
struct node *next;
};

void generate(struct node **);
void display(struct node*);
void delete(struct node **);

int main()
{
struct node *head = NULL;

generate(&head);
display(head);
delete(&head);
return 0;
}

void generate(struct node **head)
{
int num = 10, i;
struct node *temp;

for (i = 0; i < num; i++)
{
temp = (struct node *)malloc(sizeof(struct node));
temp->a = i;
if (*head == NULL)
{
*head = temp;
(*head)->next = NULL;
}
else
{
temp->next = *head;
*head = temp;
}
}
}

void display(struct node *head)
{
while (head != NULL)
{
printf("%d   ", head->a);
head = head->next;
}
printf("\n");
}

void delete(struct node **head)
{
struct node *temp;
while (*head != NULL)
{
temp = *head;
*head = (*head)->next;
free(temp);
}
}
 ETP 
 
