Python Program to Read a Linked List in Reverse
================================ EOPN
Python Program to Read a Linked List in Reverse
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 5
Enter data item: 3
Enter data item: 10
Enter data item: 2
The linked list: 2 10 3 5 

Case 2:
How many elements would you like to add? 1
Enter data item: 8
The linked list: 8 

Case 3:
How many elements would you like to add? 3
Enter data item: 1
Enter data item: 2
Enter data item: 3
The linked list: 3 2 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    node = Node(data)
    a_llist.insert_at_beg(node)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Create a Linked List & Display the Elements in the List
================================ EOPN
Python Program to Create a Linked List & Display the Elements in the List
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: -2
Enter data item: 1
Enter data item: 5
Enter data item: 0
The linked list: 3 -2 1 5 0 

Case 2:
How many elements would you like to add? 1
Enter data item: 6
The linked list: 6 

Case 3:
How many elements would you like to add? 4
Enter data item: 2
Enter data item: 9
Enter data item: 3
Enter data item: 2
The linked list: 2 9 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Search for an Element in the Linked List using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 5
5 is at index 1.

Case 2:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 7
7 is at index 4.

Case 3:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 4
4 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        return self.find_index_helper(key, 0, self.head)

    def find_index_helper(self, key, start, node):
        if node is None:
            return -1

        if node.data == key:
            return start
        else:
            return self.find_index_helper(key, start + 1, node.next)

a_llist = LinkedList()
for data in [3, 5, 0, 10, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 9
9 is at index 4.

Case 2:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 11
11 is at index 5.

Case 3:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 3
3 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        current = self.head

        index = 0
        while current:
            if current.data == key:
                return index
            current = current.next
            index = index + 1

        return -1

a_llist = LinkedList()
for data in [4, -3, 1, 0, 9, 11]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: 8
Enter data item: 14
Enter data item: 2
Enter data item: 1
The reversed linked list: 1 2 14 8 3 

Case 2:
How many elements would you like to add? 1
Enter data item: 3
The reversed linked list: 3 

Case 3:
How many elements would you like to add? 2
Enter data item: 0
Enter data item: 1
The reversed linked list: 1 0
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        self.display_reversed_helper(self.head)

    def display_reversed_helper(self, current):
        if current is None:
            return

        self.display_reversed_helper(current.next)
        print(current.data, end = ' ')

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 3
Enter data item: 7
Enter data item: 2
Enter data item: 1
The linked list: 7 2 1 

Case 2:
How many elements would you like to add? 1
Enter data item: 2
The linked list: 2 

Case 3:
How many elements would you like to add? 5
Enter data item: 4
Enter data item: 2
Enter data item: 3
Enter data item: 5
Enter data item: 1
The linked list: 4 2 3 5 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        self.display_helper(self.head)

    def display_helper(self, current):
        if current is None:
            return

        print(current.data, end = ' ')
        self.display_helper(current.next)

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOPN
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 7
Enter data item: 2
Enter data item: 1
Enter data item: 9
The reversed linked list: 9 1 2 7 

Case 2:
How many elements would you like to add? 1
Enter data item: 5
The reversed linked list: 5 

Case 3:
How many elements would you like to add? 2
Enter data item: 3
Enter data item: 1
The reversed linked list: 1 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        end_node = None

        while end_node != self.head:
            current = self.head
            while current.next != end_node:
                current = current.next
            print(current.data, end = ' ')
            end_node = current

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Find the Length of the Linked List using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 4 10
The length of the linked list is 3.

Case 2:
Please enter the elements in the linked list: 7
The length of the linked list is 1.

Case 3:
Please enter the elements in the linked list: 3 4 1 -1 3 9
The length of the linked list is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        return self.length_helper(self.head)

    def length_helper(self, current):
        if current is None:
            return 0
        return 1 + self.length_helper(current.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Find the Length of the Linked List without using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 8 1
The length of the linked list is 2.

Case 2:
Please enter the elements in the linked list: 
The length of the linked list is 0.

Case 3:
Please enter the elements in the linked list: 7 5 9 12
The length of the linked list is 4.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        current = self.head
        length = 0
        while current:
            length = length + 1
            current = current.next
        return length

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 3
3 occurs 2 time(s) in the list.

Case 2:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 7
7 occurs 4 time(s) in the list.

Case 3:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 2
2 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        return self.count_helper(self.head, key)

    def count_helper(self, current, key):
        if current is None:
            return 0

        if current.data == key:
            return 1 + self.count_helper(current.next, key)
        else:
            return self.count_helper(current.next, key)

a_llist = LinkedList()
for data in [7, 3, 7, 4, 7, 11, 4, 0, 3, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 5
5 occurs 3 time(s) in the list.

Case 2:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 3
3 occurs 1 time(s) in the list.

Case 3:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 7
7 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        current = self.head

        count = 0
        while current:
            if current.data == key:
                count = count + 1
            current = current.next

        return count

a_llist = LinkedList()
for data in [5, 1, 3, 5, 5, 15, 4, 9, 2]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 1 40 3 10
The alternate nodes of the linked list: 7 1 3 

Case 2:
Please enter the elements in the linked list: 4 9 1
The alternate nodes of the linked list: 4 1 

Case 3:
Please enter the elements in the linked list: 3
The alternate nodes of the linked list: 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        self.alternate_helper(self.head)

    def alternate_helper(self, current):
        if current is None:
            return
        print(current.data, end = ' ')
        if current.next:
            self.alternate_helper(current.next.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 4 1 9 10 3
The alternate nodes of the linked list: 7 4 9 3 

Case 2:
Please enter the elements in the linked list: 1 2
The alternate nodes of the linked list: 1 

Case 3:
Please enter the elements in the linked list: 9
The alternate nodes of the linked list: 9
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            if current.next is not None:
                current = current.next.next
            else:
                break

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Implement a Stack using Linked List
================================ EOPN
Python Program to Implement a Stack using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 15
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Popped value:  15
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Stack:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node

    def pop(self):
        if self.head is None:
            return None
        else:
            popped = self.head.data
            self.head = self.head.next
            return popped

a_stack = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        a_stack.push(int(do[1]))
    elif operation == 'pop':
        popped = a_stack.pop()
        if popped is None:
            print('Stack is empty.')
        else:
            print('Popped value: ', int(popped))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue Data Structure using Linked List
================================ EOPN
Python Program to Implement Queue Data Structure using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 5
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  5
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.last = None

    def enqueue(self, data):
        if self.last is None:
            self.head = Node(data)
            self.last = self.head
        else:
            self.last.next = Node(data)
            self.last = self.last.next

    def dequeue(self):
        if self.head is None:
            return None
        else:
            to_return = self.head.data
            self.head = self.head.next
            return to_return

a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        dequeued = a_queue.dequeue()
        if dequeued is None:
            print('Queue is empty.')
        else:
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Binary Tree using Linked List
================================ EOPN
Python Program to Implement Binary Tree using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 5 left of 3
inorder traversal of binary tree: 5 3 
What would you like to do? insert 2 right of 5
inorder traversal of binary tree: 5 2 3 
What would you like to do? insert 11 right of 3
inorder traversal of binary tree: 5 2 3 11 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 left of 2
inorder traversal of binary tree: 4 2 1 3 
What would you like to do? insert 5 right of 2
inorder traversal of binary tree: 4 2 5 1 3 
What would you like to do? insert 6 left of 3
inorder traversal of binary tree: 4 2 5 1 6 3 
What would you like to do? insert 7 right of 3
inorder traversal of binary tree: 4 2 5 1 6 3 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether 2 Linked Lists are Same
================================ EOPN
Python Program to Check whether 2 Linked Lists are Same
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 5 8 10 12
Please enter the elements in the second linked list: 5 8 10 12
The two linked lists are the same.

Case 2:
Please enter the elements in the first linked list: 12 3 4 5 0
Please enter the elements in the second linked list: 12 3
The two linked list are not the same.

Case 3:
Please enter the elements in the first linked list: 4 1
Please enter the elements in the second linked list: 2 19 4
The two linked list are not the same.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def is_equal(llist1, llist2):
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        if current1.data != current2.data:
            return False
        current1 = current1.next
        current2 = current2.next
    if current1 is None and current2 is None:
        return True
    else:
        return False


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

if is_equal(llist1, llist2):
    print('The two linked lists are the same.')
else:
    print('The two linked list are not the same.', end = '')
 ETP  
 
Python Program to Detect the Cycle in a Linked List
================================ EOPN
Python Program to Detect the Cycle in a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3
Enter the index [0-2] of the node to which you want the last node to point (enter nothing to make it point to None): 0
The linked list has a cycle.

Case 2:
Please enter the elements in the linked list: 4 5
Enter the index [0-1] of the node to which you want the last node to point (enter nothing to make it point to None): 1
The linked list has a cycle.

Case 3:
Please enter the elements in the linked list: 9 1 4 5
Enter the index [0-3] of the node to which you want the last node to point (enter nothing to make it point to None): 
The linked list does not have a cycle.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            current = current.next
            if current is None:
                return None
        return current


def has_cycle(llist):
    slow = llist.head
    fast = llist.head
    while (fast != None and fast.next != None):
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

length = len(data_list)
if length != 0:
    values = '0-' + str(length - 1)
    last_ptr = input('Enter the index [' + values + '] of the node'
                     ' to which you want the last node to point'
                     ' (enter nothing to make it point to None): ').strip()
    if last_ptr == '':
        last_ptr = None
    else:
        last_ptr = a_llist.get_node(int(last_ptr))
        a_llist.last_node.next = last_ptr

if has_cycle(a_llist):
    print('The linked list has a cycle.')
else:
    print('The linked list does not have a cycle.')
 ETP  
 
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOPN
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the doubly linked list: 5 10 9 3
The largest element is 10.

Case 2:
Please enter the elements in the doubly linked list: 
The list is empty.

Case 3:
Please enter the elements in the doubly linked list: 234 10 4 200
The largest element is 234.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def append(self, data):
        self.insert_at_end(Node(data))

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            new_node.prev = self.last
            self.last.next = new_node
            self.last = new_node


def find_largest(dllist):
    if dllist.first is None:
        return None
    largest = dllist.first.data
    current = dllist.first.next
    while current:
        if current.data > largest:
            largest = current.data
        current = current.next
    return largest


a_dllist = DoublyLinkedList()

data_list = input('Please enter the elements in the doubly linked list: ').split()
for data in data_list:
    a_dllist.append(int(data))

largest = find_largest(a_dllist)
if largest:
    print('The largest element is {}.'.format(largest))
else:
    print('The list is empty.')
 ETP  
 
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOPN
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 9 10 15
Please enter the elements in the second linked list: 2 5 4
The sum linked list: 3 14 14 15 

Case 2:
Please enter the elements in the first linked list: 3 4 5
Please enter the elements in the second linked list: 
The sum linked list: 3 4 5 

Case 3:
Please enter the elements in the first linked list: 7 10
Please enter the elements in the second linked list: 6 5 4 3 2
The sum linked list: 13 15 4 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next


def add_linked_lists(llist1, llist2):
    sum_llist = LinkedList()
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        sum = current1.data + current2.data
        sum_llist.append(sum)
        current1 = current1.next
        current2 = current2.next
    if current1 is None:
        while current2:
            sum_llist.append(current2.data)
            current2 = current2.next
    else:
        while current1:
            sum_llist.append(current1.data)
            current1 = current1.next
    return sum_llist



llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

sum_llist = add_linked_lists(llist1, llist2)

print('The sum linked list: ', end = '')
sum_llist.display()
 ETP  
 
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOPN
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 4 5 1 3 10
Please enter the elements in the second linked list: 8 3 40 1
The element that appears first in the first linked list that is common to both is 1.

Case 2:
Please enter the elements in the first linked list: 1 4 5
Please enter the elements in the second linked list: 3 10
The two lists have no common elements.

Case 3:
Please enter the elements in the first linked list: 6 8 9
Please enter the elements in the second linked list: 7 10 6 4 9 8
The element that appears first in the first linked list that is common to both is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def first_common(llist1, llist2):
    current1 = llist1.head
    while current1:
        data = current1.data
        current2 = llist2.head
        while current2:
            if data == current2.data:
                return data
            current2 = current2.next
        current1 = current1.next
    return None


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

common = first_common(llist1, llist2)

if common:
    print('The element that appears first in the first linked list that'
          ' is common to both is {}.'.format(common))
else:
    print('The two lists have no common elements.')
 ETP  
 
Python Program to Remove Duplicates from a Linked List
================================ EOPN
Python Program to Remove Duplicates from a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 5 2 1 4 5 4 5
The list with duplicates removed: 
1 5 2 4 

Case 2:
Please enter the elements in the linked list: 3 4 1
The list with duplicates removed: 
3 4 1 

Case 3:
Please enter the elements in the linked list: 1 3 3 14 5 1 0
The list with duplicates removed: 
1 3 14 5 0
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        data = current1.data
        current2 = current1.next
        while current2:
            if current2.data == data:
                llist.remove(current2)
            current2 = current2.next
        current1 = current1.next


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

remove_duplicates(a_llist)

print('The list with duplicates removed: ')
a_llist.display()
 ETP  
 
Python Program to Reverse a Linked List
================================ EOPN
Python Program to Reverse a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 30 4
The reversed list: 
4 30 1 7 

Case 2:
Please enter the elements in the linked list: 3
The reversed list: 
3 

Case 3:
Please enter the elements in the linked list: 1 2
The reversed list: 
2 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist):
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    while after:
        current.next = before
        before = current
        current = after
        after = after.next
    current.next = before
    llist.head = current


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

reverse_llist(a_llist)

print('The reversed list: ')
a_llist.display()
 ETP  
 
Python Program to Reverse only First N Elements of a Linked List
================================ EOPN
Python Program to Reverse only First N Elements of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7
Enter the number of elements you want to reverse in the list: 4
The new list: 
4 3 2 1 5 6 7 

Case 2:
Please enter the elements in the linked list: 7 2 4
Enter the number of elements you want to reverse in the list: 1
The new list: 
7 2 4 

Case 3:
Please enter the elements in the linked list: 8 3 2
Enter the number of elements you want to reverse in the list: 3
The new list: 
2 3 8
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist, n):
    if n == 0:
        return
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    for i in range(n):
        current.next = before
        before = current
        current = after
        if after is None:
            break
        after = after.next
    llist.head.next = current
    llist.head = before


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))
n = int(input('Enter the number of elements you want to reverse in the list: '))

reverse_llist(a_llist, n)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Print Middle most Node of a Linked List
================================ EOPN
Python Program to Print Middle most Node of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7 8
The two middle elements are 4 and 5.

Case 2:
Please enter the elements in the linked list: 5
The middle element is 5.

Case 3:
Please enter the elements in the linked list: 3 1 0 4 2
The middle element is 0.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def print_middle(llist):
    current = llist.head
    length = 0
    while current:
        current = current.next
        length = length + 1

    current = llist.head
    for i in range((length - 1)//2):
        current = current.next

    if current:
        if length % 2 == 0:
            print('The two middle elements are {} and {}.'
                .format(current.data, current.next.data))
        else:
            print('The middle element is {}.'.format(current.data))
    else:
        print('The list is empty.')


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_middle(a_llist)
 ETP  
 
Python Program to Print Nth Node from the last of a Linked List
================================ EOPN
Python Program to Print Nth Node from the last of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 10 20 40 50 60
The nth element from the end will be printed. Please enter n: 3
The nth element from the end: 40

Case 2:
Please enter the elements in the linked list: 4 23 3
The nth element from the end will be printed. Please enter n: 1
The nth element from the end: 3

Case 3:
Please enter the elements in the linked list: 1 2
The nth element from the end will be printed. Please enter n: 2
The nth element from the end: 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def length_llist(llist):
    length = 0
    current = llist.head
    while current:
        current = current.next
        length = length + 1
    return length


def return_n_from_last(llist, n):
    l = length_llist(llist)
    current = llist.head
    for i in range(l - n):
        current = current.next
    return current.data


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

n = int(input('The nth element from the end will be printed. Please enter n: '))
value = return_n_from_last(a_llist, n)

print('The nth element from the end: {}'.format(value))
 ETP  
 
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOPN
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 2 3 4 5
Please enter the elements in the second linked list: 3 4 5 6 7 8
Their union: 
1 2 3 4 5 6 7 8 
Their intersection: 
3 4 5 

Case 2:
Please enter the elements in the first linked list: 
Please enter the elements in the second linked list: 7 8
Their union: 
7 8 
Their intersection: 

Case 3:
Please enter the elements in the first linked list: 8 4 2 1 10 3 4 7 8
Please enter the elements in the second linked list: 5 6 3 4 3 2 5 2 8
Their union: 
8 4 2 1 10 3 7 5 6 
Their intersection: 
8 4 2 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def duplicate(self):
        copy = LinkedList()
        current = self.head
        while current:
            node = Node(current.data)
            copy.insert_at_end(node)
            current = current.next
        return copy

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        current2 = current1.next
        data = current1.data
        while current2:
            temp = current2
            current2 = current2.next
            if temp.data == data:
                llist.remove(temp)
        current1 = current1.next


def find_union(llist1, llist2):
    if llist1.head is None:
        union = llist2.duplicate()
        remove_duplicates(union)
        return union
    if llist2.head is None:
        union = llist1.duplicate()
        remove_duplicates(union)
        return union

    union = llist1.duplicate()
    last_node = union.head
    while last_node.next is not None:
        last_node = last_node.next
    llist2_copy = llist2.duplicate()
    last_node.next = llist2_copy.head
    remove_duplicates(union)

    return union


def find_intersection(llist1, llist2):
    if (llist1.head is None or llist2.head is None):
        return LinkedList()

    intersection = LinkedList()
    current1 = llist1.head
    while current1:
        current2 = llist2.head
        data = current1.data
        while current2:
            if current2.data == data:
                node = Node(data)
                intersection.insert_at_end(node)
                break
            current2 = current2.next
        current1 = current1.next
    remove_duplicates(intersection)

    return intersection


a_llist1 = LinkedList()
a_llist2 = LinkedList()
data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist1.insert_at_end(node)
data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist2.insert_at_end(node)

union = find_union(a_llist1, a_llist2)
intersection = find_intersection(a_llist1, a_llist2)

print('Their union: ')
union.display()
print()
print('Their intersection: ')
intersection.display()
print()
 ETP  
 
Python Program to Solve Josephus Problem using Linked List
================================ EOPN
Python Program to Solve Josephus Problem using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Input number of people: 5
The kth person will be executed. Input k: 3
The person at position 4 won't be killed.

Case 2:
Input number of people: 15
The kth person will be executed. Input k: 7
The person at position 5 won't be killed.

Case 3:
Input number of people: 8
The kth person will be executed. Input k: 2
The person at position 1 won't be killed.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        node = Node(data)
        self.insert_at_end(node)

    def get_node(self, index, start):
        if self.head is None:
            return None
        current = start
        for i in range(index):
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next


def has_one_node(cllist):
    if cllist.head.next == cllist.head:
        return True
    else:
        return False


def get_josephus_solution(cllist, k):
    if cllist.head is None:
        return None
    start = cllist.head
    while not has_one_node(cllist):
        to_remove = cllist.get_node(k - 1, start)
        start = to_remove.next
        cllist.remove(to_remove)
    return cllist.head.data


a_cllist = CircularLinkedList()
n = int(input('Input number of people: '))
k = int(input('The kth person will be executed. Input k: '))
for i in range(1, n + 1):
    a_cllist.append(i)

ans = get_josephus_solution(a_cllist, k)
print('The person at position {} won\'t be killed.'.format(ans))
 ETP  
 
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOPN
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
Please enter the two indices of the two elements that you want to exchange: 0 1
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 5 1
Please enter the two indices of the two elements that you want to exchange: 1 2
The new list: 
4 1 5 

Case 3:
Please enter the elements in the linked list: 3 1 30 4 5 10 23
Please enter the two indices of the two elements that you want to exchange: 2 5
The new list: 
3 1 10 4 5 30 23
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def interchange(llist, n, m):
    node1 = llist.get_node(n)
    node2 = llist.get_node(m)
    prev_node1 = llist.get_prev_node(node1)
    prev_node2 = llist.get_prev_node(node2)
    if prev_node1 is not None:
        prev_node1.next = node2
    else:
        llist.head = node2
    if prev_node2 is not None:
        prev_node2.next = node1
    else:
        llist.head = node1
    temp = node2.next
    node2.next = node1.next
    node1.next = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

ans = input('Please enter the two indices of the two elements that'
            ' you want to exchange: ').split()
n = int(ans[0])
m = int(ans[1])

interchange(a_llist, n, m)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOPN
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 1 0 4 30 12
The new list: 
12 30 4 0 3 1 

Case 2:
Please enter the elements in the linked list: 1 2
The new list: 
2 1 

Case 3:
Please enter the elements in the linked list: 1 2 3 4 5
The new list: 
4 2 1 3 5
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next


def move_even_before_odd(llist):
    current = llist.head
    while current:
        temp = current.next
        if current.data % 2 == 0:
            llist.remove(current)
            llist.insert_at_beg(current)
        current = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

move_even_before_odd(a_llist)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOPN
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
The nodes at indices n and n+1 will be interchanged. Please enter n: 0
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 1 5
The nodes at indices n and n+1 will be interchanged. Please enter n: 2
The new list: 
5 1 4 

Case 3:
Please enter the elements in the linked list: 3 18 40 1 6
The nodes at indices n and n+1 will be interchanged. Please enter n: 3
The new list: 
3 18 40 6 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def append(self, data):
        self.insert_at_end(Node(data))

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break

def interchange(llist, n):
    current = llist.get_node(n)
    current2 = current.next
    if current2.next != current:
        before = llist.get_prev_node(current)
        after = current2.next
        before.next = current2
        current2.next = current
        current.next = after
    if llist.head == current:
        llist.head = current2
    elif llist.head == current2:
        llist.head = current


a_cllist = CircularLinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_cllist.append(int(data))

n = int(input('The nodes at indices n and n+1 will be interchanged.'
              ' Please enter n: '))

interchange(a_cllist, n)

print('The new list: ')
a_cllist.display()
 ETP  
 
Python Program to Illustrate the Operations of Singly Linked List
================================ EOPN
Python Program to Illustrate the Operations of Singly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 3 at end
The list: 7 3 
What would you like to do? insert 1 after 0
The list: 7 1 3 
What would you like to do? insert 9 before 2
The list: 7 1 9 3 
What would you like to do? remove 2
The list: 7 1 3 
What would you like to do? insert 12 at end
The list: 7 1 3 12 
What would you like to do? remove 0
The list: 1 3 12 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 after 0
No such index.
The list: 
What would you like to do? insert 3 at end
The list: 3 
What would you like to do? insert 1 after 0
The list: 3 1 
What would you like to do? insert 2 before 1
The list: 3 2 1 
What would you like to do? insert 0 at end
The list: 3 2 1 0 
What would you like to do? remove 3
The list: 3 2 1 
What would you like to do? remove 2
The list: 3 2 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_llist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_llist.insert_at_beg(new_node)
            elif position == 'end':
                a_llist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_llist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_llist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_llist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_llist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_llist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOPN
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 8 1 8 7
The linked lists is palindromic.

Case 2:
Please enter the elements in the linked list: 1 2 3 3 2 1
The linked list is palindromic.

Case 3:
Please enter the elements in the linked list: 1 4 5 4 5 1
The linked list is not palindromic.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def is_palindrome(llist):
    start = llist.head
    end = llist.last_node
    while (start != end and end.next != start):
        if start.data != end.data:
            return False
        start = start.next
        end = llist.get_prev_node(end)
    return True


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

if is_palindrome(a_llist):
    print('The linked list is palindromic.')
else:
    print('The linked list is not palindromic.')
 ETP  
 
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOPN
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 3 40 1
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 7.

Case 2:
Please enter the elements in the linked list: 3
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 3.

Case 3:
Please enter the elements in the linked list: 1 2
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 1.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def convert_to_circular(llist):
    if llist.last_node:
        llist.last_node.next = llist.head


def print_last_node_points_to(llist):
    last = llist.last_node
    if last is None:
        print('List is empty.')
        return
    if last.next is None:
        print('Last node points to None.')
    else:
        print('Last node points to element with data {}.'.format(last.next.data))


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_last_node_points_to(a_llist)

print('Converting linked list to a circular linked list...')
convert_to_circular(a_llist)

print_last_node_points_to(a_llist)
 ETP  
 
Python Program to Implement Circular Doubly Linked List
================================ EOPN
Python Program to Implement Circular Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 at beg
The list: 3 
What would you like to do? insert 5 at end
The list: 3 5 
What would you like to do? insert 1 after 0
The list: 3 1 5 
What would you like to do? insert 2 after 2
The list: 3 1 5 2 
What would you like to do? remove 0
The list: 1 5 2 
What would you like to do? remove 2
The list: 1 5 
What would you like to do? remove 1
The list: 1 
What would you like to do? remove 0
The list: 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 10 at end
The list: 10 
What would you like to do? insert 1 at beg
The list: 1 10 
What would you like to do? insert 5 before 0
The list: 1 10 5 
What would you like to do? insert 9 at beg
The list: 9 1 10 5 
What would you like to do? remove 3
The list: 9 1 10 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class CircularDoublyLinkedList:
    def __init__(self):
        self.first = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            current = current.next
            if current == self.first:
                return None
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        new_node.next = ref_node.next
        new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        self.insert_after(ref_node.prev, new_node)

    def insert_at_end(self, new_node):
        if self.first is None:
            self.first = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            self.insert_after(self.first.prev, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.first = new_node

    def remove(self, node):
        if self.first.next == self.first:
            self.first = None
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
            if self.first == node:
                self.first = node.next

    def display(self):
        if self.first is None:
            return
        current = self.first
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.first:
                break


a_cdllist = CircularDoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cdllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cdllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cdllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cdllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cdllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cdllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cdllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cdllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Demonstrate Circular Single Linked List
================================ EOPN
Python Program to Demonstrate Circular Single Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 1 before 0
The list: 7 1 
What would you like to do? insert 10 after 0
The list: 7 10 1 
What would you like to do? insert 3 at end
The list: 7 10 1 3 
What would you like to do? remove 2
The list: 7 10 3 
What would you like to do? remove 0
The list: 10 3 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 1 at beg
The list: 1 
What would you like to do? insert 3 after 2
No such index.
The list: 1 
What would you like to do? remove 1
No such index.
The list: 1 
What would you like to do? insert 6 after 0
The list: 1 6 
What would you like to do? remove 0
The list: 6 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.head = new_node

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break


a_cllist = CircularLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOPN
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 at beg
The list: 5 
What would you like to do? insert 3 at beg
The list: 3 5 
What would you like to do? insert 1 at end
The list: 3 5 1 
What would you like to do? insert 10 after 1
The list: 3 5 10 1 
What would you like to do? insert 0 before 2
The list: 3 5 0 10 1 
What would you like to do? remove 4
The list: 3 5 0 10 
What would you like to do? remove 1
The list: 3 0 10 
What would you like to do? remove 5
No such index.
The list: 3 0 10 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 2 at beg
The list: 2 
What would you like to do? insert 3 before 0
The list: 3 2 
What would you like to do? remove 0
The list: 2 
What would you like to do? remove 0
The list: 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        if ref_node.next is None:
            self.last = new_node
        else:
            new_node.next = ref_node.next
            new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        new_node.next = ref_node
        if ref_node.prev is None:
            self.first = new_node
        else:
            new_node.prev = ref_node.prev
            new_node.prev.next = new_node
        ref_node.prev = new_node

    def insert_at_beg(self, new_node):
        if self.first is None:
            self.first = new_node
            self.last = new_node
        else:
            self.insert_before(self.first, new_node)

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            self.insert_after(self.last, new_node)

    def remove(self, node):
        if node.prev is None:
            self.first = node.next
        else:
            node.prev.next = node.next

        if node.next is None:
            self.last = node.prev
        else:
            node.next.prev = node.prev

    def display(self):
        current = self.first
        while current:
            print(current.data, end = ' ')
            current = current.next


a_dllist = DoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_dllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_dllist.insert_at_beg(new_node)
            elif position == 'end':
                a_dllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_dllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_dllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_dllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_dllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_dllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Stack
================================ EOPN
Python Program to Implement a Stack
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? push 5
push <value>
pop
quit
What would you like to do? pop
Popped value:  5
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? push 1
push <value>
pop
quit
What would you like to do? pop
Popped value:  1
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Reverse a Stack using Recursion
================================ EOPN
Python Program to Reverse a Stack using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements to push: 7 3 1 5
The stack:
5
1
3
7
After reversing:
7
3
1
5

Case 2:
Please enter the elements to push: 3
The stack:
3
After reversing:
3

Case 3:
Please enter the elements to push: 1 2
The stack:
2
1
After reversing:
1
2
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def display(self):
        for data in reversed(self.items):
            print(data)

def insert_at_bottom(s, data):
    if s.is_empty():
        s.push(data)
    else:
        popped = s.pop()
        insert_at_bottom(s, data)
        s.push(popped)


def reverse_stack(s):
    if not s.is_empty():
        popped = s.pop()
        reverse_stack(s)
        insert_at_bottom(s, popped)


s = Stack()
data_list = input('Please enter the elements to push: ').split()
for data in data_list:
    s.push(int(data))

print('The stack:')
s.display()
reverse_stack(s)
print('After reversing:')
s.display()
 ETP  
 
Python Program to Implement Stack using One Queue
================================ EOPN
Python Program to Implement Stack using One Queue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? push 3
What would you like to do? push 5
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.q = Queue()

    def is_empty(self):
        return self.q.is_empty()

    def push(self, data):
        self.q.enqueue(data)

    def pop(self):
        for _ in range(self.q.get_size() - 1):
            dequeued = self.q.dequeue()
            self.q.enqueue(dequeued)
        return self.q.dequeue()


class Queue:
    def __init__(self):
        self.items = []
        self.size = 0

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.size += 1
        self.items.append(data)

    def dequeue(self):
        self.size -= 1
        return self.items.pop(0)

    def get_size(self):
        return self.size


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Stack Using Two Queues
================================ EOPN
Python Program to Implement Stack Using Two Queues
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? pop
Popped value:  2
What would you like to do? quit

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 5
What would you like to do? push 0
What would you like to do? pop
Popped value:  0
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def is_empty(self):
        return self.queue2.is_empty()

    def push(self, data):
        self.queue1.enqueue(data)
        while not self.queue2.is_empty():
            x = self.queue2.dequeue()
            self.queue1.enqueue(x)
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        return self.queue2.dequeue()

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue
================================ EOPN
Python Program to Implement Queue
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  1
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


q = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        q.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if q.is_empty():
            print('Queue is empty.')
        else:
            print('Dequeued value: ', q.dequeue())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dequeue
================================ EOPN
Python Program to Implement Dequeue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 3
What would you like to do? append 4
What would you like to do? appendleft 2
What would you like to do? appendleft 1
What would you like to do? pop
Popped value from right:  4
What would you like to do? popleft
Popped value from left:  1
What would you like to do? pop
Popped value from right:  3
What would you like to do? popleft
Popped value from left:  2
What would you like to do? pop
Dequeue is empty.
What would you like to do? quit

Case 2:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? pop
Popped value from right:  2
What would you like to do? pop
Popped value from right:  1
What would you like to do? appendleft 1
What would you like to do? appendleft 2
What would you like to do? pop
Popped value from right:  1
What would you like to do? pop
Popped value from right:  2
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? popleft
Popped value from left:  1
What would you like to do? popleft
Popped value from left:  2
What would you like to do? quit
--------------------------------
class Dequeue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def append(self, data):
        self.items.append(data)

    def append_left(self, data):
        self.items.insert(0, data)

    def pop(self):
        return self.items.pop()

    def pop_left(self):
        return self.items.pop(0)


q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queues using Stacks
================================ EOPN
Python Program to Implement Queues using Stacks
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? enqueue 8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 2
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  1
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.inbox = Stack()
        self.outbox = Stack()

    def is_empty(self):
        return (self.inbox.is_empty() and self.outbox.is_empty())

    def enqueue(self, data):
        self.inbox.push(data)

    def dequeue(self):
        if self.outbox.is_empty():
            while not self.inbox.is_empty():
                popped = self.inbox.pop()
                self.outbox.push(popped)
        return self.outbox.pop()


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if a_queue.is_empty():
            print('Queue is empty.')
        else:
            dequeued = a_queue.dequeue()
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check String is Palindrome using Stack
================================ EOPN
Python Program to Check String is Palindrome using Stack
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the string: madam
The string is a palindrome.

Case 2:
Please enter the string: racecar
The string is a palindrome.

Case 3:
Please enter the string: palace
The string is not a palindrome.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
text = input('Please enter the string: ')

for character in text:
    s.push(character)

reversed_text = ''
while not s.is_empty():
    reversed_text = reversed_text + s.pop()

if text == reversed_text:
    print('The string is a palindrome.')
else:
    print('The string is not a palindrome.')
 ETP  
 
Python Program to Check if Expression is correctly Parenthesized
================================ EOPN
Python Program to Check if Expression is correctly Parenthesized
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the expression: (3 + 4 * (1 + (2))/(7 * (8 + 9)))
Expression is correctly parenthesized.

Case 2:
Please enter the expression: (a + b))(3)
Expression is not correctly parenthesized.

Case 3:
Please enter the expression: (4 + (3 * 2)
Expression is not correctly parenthesized.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
exp = input('Please enter the expression: ')

for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False

if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')
 ETP  
 
Python Program to Implement Linear Search
================================ EOPN
Python Program to Implement Linear Search
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 4 3 2 1 10 11 2
The number to search for: 1
1 was found at index 4.

Case 2:
Enter the list of numbers: 5 2 1 5 -3
The number to search for: 2
2 was found at index 1.

Case 3:
Enter the list of numbers: 3 5 6
The number to search for: 2
2 was not found.
--------------------------------
def linear_search(alist, key):
    """Return index of key in alist. Return -1 if key not present."""
    for i in range(len(alist)):
        if alist[i] == key:
            return i
    return -1


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = linear_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search without Recursion
================================ EOPN
Python Program to Implement Binary Search without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 3 5 10 12 15 20
The number to search for: 12
12 was found at index 3.

Case 2:
Enter the sorted list of numbers: -3 0 1 5 6 7 8
The number to search for: 2
2 was not found.

Case 3:
Enter the sorted list of numbers: 5
The number to search for: 5
5 was found at index 0.
--------------------------------
def binary_search(alist, key):
    """Search key in alist[start... end - 1]."""
    start = 0
    end = len(alist)
    while start < end:
        mid = (start + end)//2
        if alist[mid] > key:
            end = mid
        elif alist[mid] < key:
            start = mid + 1
        else:
            return mid
    return -1


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search with Recursion
================================ EOPN
Python Program to Implement Binary Search with Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 4 5 6 7 8 9 10
The number to search for: 9
9 was found at index 5.

Case 2:
Enter the sorted list of numbers: 3 4 5 10
The number to search for: 8
8 was not found.

Case 3:
Enter the sorted list of numbers: 7
The number to search for: 7
7 was found at index 0.
--------------------------------
def binary_search(alist, start, end, key):
    """Search key in alist[start... end - 1]."""
    if not start < end:
        return -1

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, mid + 1, end, key)
    elif alist[mid] > key:
        return binary_search(alist, start, mid, key)
    else:
        return mid


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, 0, len(alist), key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 10 2 -1 0 2
The ith smallest element will be found. Enter i: 2
Result: 0.

Case 2:
Enter the list of numbers: 7
The ith smallest element will be found. Enter i: 1
Result: 7.

Case 3:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 5.
--------------------------------
def select(alist, start, end, i):
    """Find ith smallest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[start... pivot]
    k = pivot - start + 1

    if i < k:
        return select(alist, start, pivot, i)
    elif i > k:
        return select(alist, pivot + 1, end, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 10 7 2 -2
The ith smallest element will be found. Enter i: 2
Result: 7.

Case 2:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 1.

Case 3:
Enter the list of numbers: 3
The ith smallest element will be found. Enter i: 1
Result: 3.
--------------------------------
def select(alist, start, end, i):
    """Find ith largest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[pivot... end - 1]
    k = end - pivot

    if i < k:
        return select(alist, pivot + 1, end, i)
    elif i > k:
        return select(alist, start, pivot, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Implement Bubble Sort 
================================ EOPN
Python Program to Implement Bubble Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 38 10 5
Sorted list: [2, 4, 5, 10, 38]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7 3 1 -5 2 10
Sorted list: [-5, 1, 2, 3, 7, 10]
--------------------------------
def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Selection Sort
================================ EOPN
Python Program to Implement Selection Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 4 5 2 6
Sorted list: [1, 2, 3, 4, 5, 6]

Case 2:
Enter the list of numbers: 2 10 5 38 1 7
Sorted list: [1, 2, 5, 7, 10, 38]

Case 3:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]
--------------------------------
def selection_sort(alist):
    for i in range(0, len(alist) - 1):
        smallest = i
        for j in range(i + 1, len(alist)):
            if alist[j] < alist[smallest]:
                smallest = j
        alist[i], alist[smallest] = alist[smallest], alist[i]


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
selection_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Insertion Sort
================================ EOPN
Python Program to Implement Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 4 1 5 8 0
Sorted list: [0, 1, 2, 4, 5, 8]

Case 2:
Enter the list of numbers: 5 4 3 2 0 -1
Sorted list: [-1, 0, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3 4 1 4 5 0 7
Sorted list: [0, 1, 3, 4, 4, 5, 7]
--------------------------------
def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Merge Sort
================================ EOPN
Python Program to Implement Merge Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 8 2 5 1 3
Sorted list: [1, 1, 2, 3, 3, 5, 5, 8]

Case 2:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)

def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Quicksort
================================ EOPN
Python Program to Implement Quicksort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 8 10 3 0 4
Sorted list: [0, 2, 3, 4, 5, 8, 10]

Case 2:
Enter the list of numbers: 7 4 3 2 1
Sorted list: [1, 2, 3, 4, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def quicksort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        p = partition(alist, start, end)
        quicksort(alist, start, p)
        quicksort(alist, p + 1, end)


def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
quicksort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Heapsort
================================ EOPN
Python Program to Implement Heapsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 2 2 1 0 -2 5 7
Sorted list: [-2, 0, 1, 2, 2, 3, 5, 7]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def heapsort(alist):
    build_max_heap(alist)
    for i in range(len(alist) - 1, 0, -1):
        alist[0], alist[i] = alist[i], alist[0]
        max_heapify(alist, index=0, size=i)

def parent(i):
    return (i - 1)//2

def left(i):
    return 2*i + 1

def right(i):
    return 2*i + 2

def build_max_heap(alist):
    length = len(alist)
    start = parent(length - 1)
    while start >= 0:
        max_heapify(alist, index=start, size=length)
        start = start - 1

def max_heapify(alist, index, size):
    l = left(index)
    r = right(index)
    if (l < size and alist[l] > alist[index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[r] > alist[largest]):
        largest = r
    if (largest != index):
        alist[largest], alist[index] = alist[index], alist[largest]
        max_heapify(alist, largest, size)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
heapsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Counting Sort
================================ EOPN
Python Program to Implement Counting Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 4 1 3 6 1 8
Sorted list: [1, 1, 1, 2, 3, 4, 6, 8]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 4 3 2
Sorted list: [2, 3, 4, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 1
Sorted list: [1]
--------------------------------
def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)

    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1

    return result


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
 Python Program to Implement Radix Sort 
================================ EOPN
 Python Program to Implement Radix Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 38 20 1 3 4 0 2 5 1 3 8 2 9 10
Sorted list: [0, 1, 1, 2, 2, 3, 3, 4, 5, 8, 9, 10, 20, 38]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 3
Sorted list: [3]
--------------------------------
def radix_sort(alist, base=10):
    if alist == []:
        return

    def key_factory(digit, base):
        def key(alist, index):
            return ((alist[index]//(base**digit)) % base)
        return key
    largest = max(alist)
    exp = 0
    while base**exp <= largest:
        alist = counting_sort(alist, base - 1, key_factory(exp, base))
        exp = exp + 1
    return alist

def counting_sort(alist, largest, key):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[key(alist, i)] = c[key(alist, i)] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)
    for i in range(len(alist) - 1, -1, -1):
        result[c[key(alist, i)]] = alist[i]
        c[key(alist, i)] = c[key(alist, i)] - 1

    return result

alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = radix_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Bucket Sort
================================ EOPN
Python Program to Implement Bucket Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 5 10 3 5 7
Sorted list: [1, 2, 3, 5, 5, 7, 10]

Case 2:
Enter the list of (nonnegative) numbers: 8 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7, 8]

Case 3:
Enter the list of (nonnegative) numbers: 5
Sorted list: [5]
--------------------------------
def bucket_sort(alist):
    largest = max(alist)
    length = len(alist)
    size = largest/length

    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(alist[i]/size)
        if j != length:
            buckets[j].append(alist[i])
        else:
            buckets[length - 1].append(alist[i])

    for i in range(length):
        insertion_sort(buckets[i])

    result = []
    for i in range(length):
        result = result + buckets[i]

    return result

def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = bucket_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Gnome Sort
================================ EOPN
Python Program to Implement Gnome Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 3 2 51 38 1 10 3 0 7 8
Sorted list: [0, 1, 2, 2, 3, 3, 7, 8, 10, 38, 51]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7
Sorted list: [7]
--------------------------------
def gnome_sort(alist):
    for pos in range(1, len(alist)):
        while (pos != 0 and alist[pos] < alist[pos - 1]):
            alist[pos], alist[pos - 1] = alist[pos - 1], alist[pos]
            pos = pos - 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
gnome_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Cocktail Shaker Sort
================================ EOPN
Python Program to Implement Cocktail Shaker Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 18 5 2 10 0 7 4
Sorted list: [0, 2, 3, 4, 5, 7, 10, 18]

Case 2:
Enter the list of numbers: 6 5 4 3 2
Sorted list: [2, 3, 4, 5, 6]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def cocktail_shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    upper = len(alist) - 1
    lower = 0

    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1

        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
cocktail_shaker_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Comb Sort
================================ EOPN
Python Program to Implement Comb Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 8 4 3 7 10 23 4 5
Sorted list: [2, 3, 4, 4, 5, 7, 8, 10, 23]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3
Sorted list: [3]
--------------------------------
def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    gap = len(alist)
    shrink = 1.3

    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)

        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False

        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Shell Sort
================================ EOPN
Python Program to Implement Shell Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 3 1 10
Sorted list: [1, 2, 3, 5, 10]

Case 2:
Enter the list of numbers: 7 6 5 4
Sorted list: [4, 5, 6, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def gaps(size):
    # uses the gap sequence 2^k - 1: 1, 3, 7, 15, 31, ...
    length = size.bit_length()
    for k in range(length - 1, 0, -1):
        yield 2**k - 1


def shell_sort(alist):
    def insertion_sort_with_gap(gap):
        for i in range(gap, len(alist)):
            temp = alist[i]
            j = i - gap
            while (j >= 0 and temp < alist[j]):
                alist[j + gap] = alist[j]
                j = j - gap
            alist[j + gap] = temp

    for g in gaps(len(alist)):
        insertion_sort_with_gap(g)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
shell_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Introsort
================================ EOPN
Python Program to Implement Introsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 2 3 10 9 3 7 2 1 0 9
Sorted list: [0, 1, 2, 2, 3, 3, 3, 5, 7, 9, 9, 10]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 5
Sorted list: [5]
--------------------------------
def introsort(alist):
    maxdepth = (len(alist).bit_length() - 1)*2
    introsort_helper(alist, 0, len(alist), maxdepth)

def introsort_helper(alist, start, end, maxdepth):
    if end - start <= 1:
        return
    elif maxdepth == 0:
        heapsort(alist, start, end)
    else:
        p = partition(alist, start, end)
        introsort_helper(alist, start, p + 1, maxdepth - 1)
        introsort_helper(alist, p + 1, end, maxdepth - 1)

def partition(alist, start, end):
    pivot = alist[start]
    i = start - 1
    j = end

    while True:
        i = i + 1
        while alist[i] < pivot:
            i = i + 1
        j = j - 1
        while alist[j] > pivot:
            j = j - 1

        if i >= j:
            return j

        swap(alist, i, j)

def swap(alist, i, j):
    alist[i], alist[j] = alist[j], alist[i]

def heapsort(alist, start, end):
    build_max_heap(alist, start, end)
    for i in range(end - 1, start, -1):
        swap(alist, start, i)
        max_heapify(alist, index=0, start=start, end=i)

def build_max_heap(alist, start, end):
    def parent(i):
        return (i - 1)//2
    length = end - start
    index = parent(length - 1)
    while index >= 0:
        max_heapify(alist, index, start, end)
        index = index - 1

def max_heapify(alist, index, start, end):
    def left(i):
        return 2*i + 1
    def right(i):
        return 2*i + 2

    size = end - start
    l = left(index)
    r = right(index)
    if (l < size and alist[start + l] > alist[start + index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[start + r] > alist[start + largest]):
        largest = r
    if largest != index:
        swap(alist, start + largest, start + index)
        max_heapify(alist, largest, start, end)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
introsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Binary Insertion Sort
================================ EOPN
Python Program to Implement Binary Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 7 10 3 5 2 1 8 9
Sorted list: [1, 2, 2, 3, 5, 5, 7, 8, 9, 10]

Case 2:
Enter the list of numbers: 7 5 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5, 5, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def binary_insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        pos = binary_search(alist, temp, 0, i) + 1

        for k in range(i, pos, -1):
            alist[k] = alist[k - 1]

        alist[pos] = temp

def binary_search(alist, key, start, end):
    '''If key is in the list at index p, then return p.
    If there are multiple such keys in the list, then return the index of any one.
    If key is not in the list and a < key < b where a and b are elements in the list, then return the index of a.
    If key is not in the list and key < a where a is the first element in the list, then return -1.
    Only elements with indexes start to end - 1 inclusive are considered.
    '''
    if end - start <= 1:
        if key < alist[start]:
            return start - 1
        else:
            return start

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, key, mid, end)
    elif alist[mid] > key:
        return binary_search(alist, key, start, mid)
    else:
        return mid


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
binary_insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Sort using a Binary Search Tree
================================ EOPN
Python Program to Sort using a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 3 4 5 6 1 7 9 10 3
Sorted list: 1 2 3 3 4 4 5 6 7 9 10 

Case 2:
Enter the list of numbers: 6 5 4 3 2 1
Sorted list: 1 2 3 4 5 6 

Case 3:
Enter the list of numbers: 5
Sorted list: 5
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key <= node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)


bstree = BSTree()

alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
for x in alist:
    bstree.add(x)
print('Sorted list: ', end='')
bstree.inorder()
 ETP  
 
Python Program for Depth First Binary Tree Search using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 5
What would you like to do? insert 7 right of 5
What would you like to do? dfs
depth-first search traversal:
entering 1...
entering 2...
entering 4...
at 4...
leaving 4...
at 2...
entering 5...
entering 6...
at 6...
leaving 6...
at 5...
entering 7...
at 7...
leaving 7...
leaving 5...
leaving 2...
at 1...
entering 3...
at 3...
leaving 3...
leaving 1...

What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 4 left of 3
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 4
What would you like to do? dfs
depth-first search traversal:
entering 3...
entering 4...
entering 6...
at 6...
leaving 6...
at 4...
leaving 4...
at 3...
entering 5...
at 5...
leaving 5...
leaving 3...

What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def depth_first(self):
        print('entering {}...'.format(self.key))
        if self.left is not None:
            self.left.depth_first()
        print('at {}...'.format(self.key))
        if self.right is not None:
            self.right.depth_first()
        print('leaving {}...'.format(self.key))


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('depth-first search traversal:')
        if btree is not None:
            btree.depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? dfs
pre-order dfs traversal: 1 2 4 5 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? insert 8 left of 7
What would you like to do? insert 10 right of 7
What would you like to do? dfs
pre-order dfs traversal: 3 6 7 8 10 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def preorder_depth_first(self):
        s = Stack()
        s.push(self)
        while (not s.is_empty()):
            node = s.pop()
            print(node.key, end=' ')
            if node.right is not None:
                s.push(node.right)
            if node.left is not None:
                s.push(node.left)


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


btree = BinaryTree()

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('pre-order dfs traversal: ', end='')
        if btree is not None:
            btree.preorder_depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOPN
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? inorder 1
nth term of inorder traversal: 2
What would you like to do? inorder 2
nth term of inorder traversal: 1
What would you like to do? inorder 3
nth term of inorder traversal: 3
What would you like to do? inorder 4
index exceeds maximum possible index.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 3 left of 1
What would you like to do? insert 7 right of 1
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 5
What would you like to do? inorder 1
nth term of inorder traversal: 3
What would you like to do? inorder 2
nth term of inorder traversal: 6
What would you like to do? inorder 3
nth term of inorder traversal: 5
What would you like to do? inorder 4
nth term of inorder traversal: 1
What would you like to do? inorder 5
nth term of inorder traversal: 7
What would you like to do? inorder 6
index exceeds maximum possible index.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_nth(self, n):
        return self.inorder_nth_helper(n, [])

    def inorder_nth_helper(self, n, inord):
        if self.left is not None:
            temp = self.left.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp
        inord.append(self)
        if n == len(inord):
            return self
        if self.right is not None:
            temp = self.right.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('inorder <index>')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'inorder':
        if btree is not None:
            index = int(do[1].strip().lower())
            node = btree.inorder_nth(index)
            if node is not None:
                print('nth term of inorder traversal: {}'.format(node.key))
            else:
                print('index exceeds maximum possible index.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOPN
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 1 at rot
What would you like to do? largest
Largest element: 1
What would you like to do? insert 2 left of 1
What would you like to do? largest
Largest element: 2
What would you like to do? insert 3 right of 1
What would you like to do? largest
Largest element: 3
What would you like to do? insert 10 left of 3
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 3 at root
What would you like to do? insert 5 left of 3
What would you like to do? insert 2 right of 3
What would you like to do? largest
Largest element: 5
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_largest(self):
        # largest will be a single element list
        # this is a workaround to reference an integer
        largest = []
        self.inorder_largest_helper(largest)
        return largest[0]

    def inorder_largest_helper(self, largest):
        if self.left is not None:
            self.left.inorder_largest_helper(largest)
        if largest == []:
            largest.append(self.key)
        elif largest[0] < self.key:
            largest[0] = self.key
        if self.right is not None:
            self.right.inorder_largest_helper(largest)

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'largest':
        if btree is None:
            print('Tree is empty.')
        else:
            print('Largest element: {}'.format(btree.inorder_largest()))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOPN
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 2
What would you like to do? add 5 below 1
What would you like to do? add 6 below 1
What would you like to do? dfs
Post-order traversal: 3 4 2 5 6 1 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 3 at root
What would you like to do? add 5 below 3
What would you like to do? add 2 below 3
What would you like to do? add 1 below 5
What would you like to do? add 6 below 5
What would you like to do? dfs
Post-order traversal: 1 6 5 2 3 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def postorder(self):
        for child in self.children:
            child.postorder()
        print(self.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'dfs':
        print('Post-order traversal: ', end='')
        tree.postorder()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOPN
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 left of 3
What would you like to do? insert 6 right of 3
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 4 5 6 
BFS traversal of mirror: 
1 3 2 6 5 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 
BFS traversal of mirror: 
1 
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 
BFS traversal of mirror: 
1 3 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def mirror_copy(self):
        mirror = BinaryTree(self.key)
        if self.right is not None:
            mirror.left = self.right.mirror_copy()
        if self.left is not None:
            mirror.right = self.left.mirror_copy()
        return mirror

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            if popped.left is not None:
                queue.append(popped.left)
            if popped.right is not None:
                queue.append(popped.right)
            print(popped.key, end=' ')


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('mirror')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'mirror':
        if btree is not None:
            print('Creating mirror copy...')
            mirror = btree.mirror_copy()
            print('BFS traversal of original tree: ')
            btree.bfs()
            print()
            print('BFS traversal of mirror: ')
            mirror.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOPN
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOKW
--------------------------------
output:
Case 1:
Input post-order traversal: 4 5 2 8 6 7 3 1
Input in-order traversal: 4 2 5 1 6 8 3 7
Binary tree constructed.
Verifying:
Post-order traversal: 4 5 2 8 6 7 3 1 
In-order traversal: 4 2 5 1 6 8 3 7 

Case 2:
Input post-order traversal: 2 1 3
Input in-order traversal: 2 3 1
Binary tree constructed.
Verifying:
Post-order traversal: 2 1 3 
In-order traversal: 2 3 1
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def postorder(self):
        if self.left is not None:
            self.left.postorder()
        if self.right is not None:
            self.right.postorder()
        print(self.key, end=' ')


def construct_btree(postord, inord):
    if postord == [] or inord == []:
        return None
    key = postord[-1]
    node = BinaryTree(key)
    index = inord.index(key)
    node.left = construct_btree(postord[:index], inord[:index])
    node.right = construct_btree(postord[index:-1], inord[index + 1:])
    return node


postord = input('Input post-order traversal: ').split()
postord = [int(x) for x in postord]
inord = input('Input in-order traversal: ').split()
inord = [int(x) for x in inord]

btree = construct_btree(postord, inord)
print('Binary tree constructed.')
print('Verifying:')
print('Post-order traversal: ', end='')
btree.postorder()
print()
print('In-order traversal: ', end='')
btree.inorder()
print()
 ETP  
 
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOPN
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 5
What would you like to do? add 1
What would you like to do? add 10
What would you like to do? add 7
What would you like to do? add 3
What would you like to do? inorder
Inorder traversal: 1 3 5 7 10 
What would you like to do? remove 3
What would you like to do? remove 7
What would you like to do? inorder
Inorder traversal: 1 5 10 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 1 10 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 2
What would you like to do? add 8
What would you like to do? inorder
Inorder traversal: 2 8 
What would you like to do? add 5
What would you like to do? inorder
Inorder traversal: 2 5 8 
What would you like to do? remove 2
What would you like to do? remove 8
What would you like to do? inorder
Inorder traversal: 5 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def replace_node_of_parent(self, new_node):
        if self.parent is not None:
            if new_node is not None:
                new_node.parent = self.parent
            if self.parent.left == self:
                self.parent.left = new_node
            elif self.parent.right == self:
                self.parent.right = new_node
        else:
            self.key = new_node.key
            self.left = new_node.left
            self.right = new_node.right
            if new_node.left is not None:
                new_node.left.parent = self
            if new_node.right is not None:
                new_node.right.parent = self

    def find_min(self):
        current = self
        while current.left is not None:
            current = current.left
        return current

    def remove(self):
        if (self.left is not None and self.right is not None):
            successor = self.right.find_min()
            self.key = successor.key
            successor.remove()
        elif self.left is not None:
            self.replace_node_of_parent(self.left)
        elif self.right is not None:
            self.replace_node_of_parent(self.right)
        else:
            self.replace_node_of_parent(None)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def remove(self, key):
        to_remove = self.search(key)
        if (self.root == to_remove
            and self.root.left is None and self.root.right is None):
            self.root = None
        else:
            to_remove.remove()

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('remove <key>')
print('inorder')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    elif operation == 'remove':
        key = int(do[1])
        bstree.remove(key)
    elif operation == 'inorder':
        print('Inorder traversal: ', end='')
        bstree.inorder()
        print()
    elif operation == 'quit':
        break
 ETP  
 
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOPN
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 3
What would you like to do? add 2
What would you like to do? add 10
What would you like to do? add 4
What would you like to do? smallest
Smallest element: 2
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 10
What would you like to do? smallest
Smallest element: 10
What would you like to do? largest
Largest element: 10
What would you like to do? add 4
What would you like to do? add 12
What would you like to do? smallest
Smallest element: 4
What would you like to do? largest
Largest element: 12
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)

    def get_smallest(self):
        if self.root is not None:
            current = self.root
            while current.left is not None:
                current = current.left
            return current.key

    def get_largest(self):
        if self.root is not None:
            current = self.root
            while current.right is not None:
                current = current.right
            return current.key


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('smallest')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    if operation == 'smallest':
        smallest = bstree.get_smallest()
        print('Smallest element: {}'.format(smallest))
    if operation == 'largest':
        largest = bstree.get_largest()
        print('Largest element: {}'.format(largest))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Leaf Node in a Tree
================================ EOPN
Python Program to Count Number of Leaf Node in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of leaf nodes: 2
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 2 at root
What would you like to do? add 7 below 2
What would you like to do? add 8 below 7
What would you like to do? add 9 below 8
What would you like to do? count
Number of leaf nodes: 1
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_leaf_nodes(self):
        leaf_nodes = []
        self.count_leaf_nodes_helper(leaf_nodes)
        return len(leaf_nodes)

    def count_leaf_nodes_helper(self, leaf_nodes):
        if self.children == []:
            leaf_nodes.append(self)
        else:
            for child in self.children:
                child.count_leaf_nodes_helper(leaf_nodes)


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_leaf_nodes()
            print('Number of leaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 right of 2
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? count
Number of nodes in tree: 4
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? count
Number of nodes in tree: 0
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? count
Number of nodes in tree: 1
inorder traversal of binary tree: 1 
What would you like to do? insert 2 right of 1
inorder traversal of binary tree: 1 2 
What would you like to do? count
Number of nodes in tree: 2
inorder traversal of binary tree: 1 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def count_nodes(node):
    if node is None:
        return 0
    return 1 + count_nodes(node.left) + count_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('count')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'count':
        print('Number of nodes in tree: {}'.format(count_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOPN
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? border
Border of tree: 
1 2 3 
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? border
Border of tree: 
1 2 4 5 6 7 3 
What would you like to do? insert 8 left of 4
What would you like to do? insert 9 right of 4
What would you like to do? insert 10 left of 5
What would you like to do? insert 11 right of 5
What would you like to do? insert 12 left of 6
What would you like to do? insert 13 right of 6
What would you like to do? insert 14 left of 7
What would you like to do? insert 15 right of 7
What would you like to do? border
Border of tree: 
1 2 4 8 9 10 11 12 13 14 15 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 left of 2
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? insert 6 right of 4
What would you like to do? insert 7 right of 1
What would you like to do? insert 8 right of 7
What would you like to do? border
Border of tree: 
1 2 3 5 6 8 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left_boundary(self):
        current = self
        while True:
            if current.left is not None:
                print(current.key, end=' ')
                current = current.left
            elif current.right is not None:
                print(current.key, end=' ')
                current = current.right
            else:
                break

    def print_right_boundary(self):
        if self.right is not None:
            self.right.print_right_boundary()
            print(self.key, end=' ')
        elif self.left is not None:
            self.left.print_right_boundary()
            print(self.key, end=' ')


    def print_leaves(self):
        if self.left is not None:
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
        if (self.left is None
            and self.right is None):
            print(self.key, end=' ')

    def print_border(self):
        print(self.key, end=' ')
        if self.left is not None:
            self.left.print_left_boundary()
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
            self.right.print_right_boundary()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('border')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'border':
        if btree is not None:
            print('Border of tree: ')
            btree.print_border()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOPN
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? count
Number of nonleaf nodes: 0
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of nonleaf nodes: 1
What would you like to do? add 4 below 2
What would you like to do? count
Number of nonleaf nodes: 2
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 3
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 3
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 6 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 7 below 6
What would you like to do? count
Number of nonleaf nodes: 5
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_nonleaf_nodes(self):
        nonleaf_count = 0
        if self.children != []:
            nonleaf_count = 1
        for child in self.children:
            nonleaf_count = nonleaf_count + child.count_nonleaf_nodes()
        return nonleaf_count


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_nonleaf_nodes()
            print('Number of nonleaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of all Nodes in a Tree
================================ EOPN
Python Program to Find the Sum of all Nodes in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? sum
Tree is empty.
What would you like to do? add 3 at root
What would you like to do? sum
Sum of all nodes: 3
What would you like to do? add 4 below 3
What would you like to do? sum
Sum of all nodes: 7
What would you like to do? add 5 below 3
What would you like to do? add 10 below 4
What would you like to do? sum
Sum of all nodes: 22
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 1
What would you like to do? add 5 below 2
What would you like to do? add 6 below 3
What would you like to do? add 7 below 4
What would you like to do? sum
Sum of all nodes: 28
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def sum_nodes(self):
        summation = self.key
        for child in self.children:
            summation = summation + child.sum_nodes()
        return summation


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('sum')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'sum':
        if tree is None:
            print('Tree is empty.')
        else:
            summation = tree.sum_nodes()
            print('Sum of all nodes: {}'.format(summation))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOPN
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 2
What would you like to do? add 5 below 2
What would you like to do? display
BFS traversal display: 1 2 3 4 5 
What would you like to do? remove 1
What would you like to do? display
BFS traversal display: 4 2 3 5 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 4 2 3 
What would you like to do? remove 4
What would you like to do? display
BFS traversal display: 2 3 
What would you like to do? remove 3
What would you like to do? remove 2
What would you like to do? display
Tree is empty.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 9 below 7
What would you like to do? add 11 below 9
What would you like to do? add 12 below 7
What would you like to do? display
BFS traversal display: 5 7 9 12 11 
What would you like to do? remove 9
What would you like to do? display
BFS traversal display: 5 7 11 12 
What would you like to do? remove 12
What would you like to do? display
BFS traversal display: 5 7 11 
What would you like to do? remove 7
What would you like to do? display
BFS traversal display: 5 11 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 11 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None, parent=None):
        self.key = data
        self.children = []
        self.parent = parent

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def remove(self):
        parent = self.parent
        index = parent.children.index(self)
        parent.children.remove(self)
        for child in reversed(self.children):
            parent.children.insert(index, child)
            child.parent = parent

    def bfs_display(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('remove <data>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            new_node.parent = ref_node
            ref_node.add(new_node)

    elif operation == 'remove':
        data = int(do[1])
        to_remove = tree.search(data)
        if tree == to_remove:
            if tree.children == []:
                tree = None
            else:
                leaf = tree.children[0]
                while leaf.children != []:
                    leaf = leaf.children[0]
                leaf.parent.children.remove(leaf)
                leaf.parent = None
                leaf.children = tree.children
                tree = leaf
        else:
            to_remove.remove()

    elif operation == 'display':
        if tree is not None:
            print('BFS traversal display: ', end='')
            tree.bfs_display()
            print()
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOPN
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 1 at root
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 0 left of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 2 right of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 3 left of 2
What would you like to do? bst
Tree is not a binary search tree.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 5 at root
What would you like to do? insert 1 left of 5
What would you like to do? insert 10 right of 5
What would you like to do? insert 0 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 15 right of 10
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def is_bst_p(self):
        if self.left is not None:
            if self.key < self.left.key:
                return False
            elif not self.left.is_bst_p():
                return False
        if self.right is not None:
            if self.key > self.right.key:
                return False
            elif not self.right.is_bst_p():
                return False
        return True


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('bst')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'bst':
        if btree is not None:
            if btree.is_bst_p():
                print('Tree is a binary search tree.')
            else:
                print('Tree is not a binary search tree.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOPN
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? paths
Tree is empty.
What would you like to do? add 1 at root
What would you like to do? paths
1 
What would you like to do? add 2 below 1
What would you like to do? paths
1 2 
What would you like to do? add 3 below 1
What would you like to do? paths
1 2 
1 3 
What would you like to do? add 4 below 1
What would you like to do? paths
1 2 
1 3 
1 4 
What would you like to do? add 8 below 2
What would you like to do? paths
1 2 8 
1 3 
1 4 
What would you like to do? add 7 below 2
What would you like to do? paths
1 2 8 
1 2 7 
1 3 
1 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? add 1 at root
What would you like to do? add 10 below 1
What would you like to do? add 11 below 10
What would you like to do? add 12 below 11
What would you like to do? add 20 below 1
What would you like to do? add 21 below 20
What would you like to do? add 30 below 1
What would you like to do? paths
1 10 11 12 
1 20 21 
1 30 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def print_all_paths_to_leaf(self):
        self.print_all_paths_to_leaf_helper([])

    def print_all_paths_to_leaf_helper(self, path_till_now):
        path_till_now.append(self.key)
        if self.children == []:
            for key in path_till_now:
                print(key, end=' ')
            print()
        else:
            for child in self.children:
                child.print_all_paths_to_leaf_helper(path_till_now[:])


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('paths')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'paths':
        if tree is None:
            print('Tree is empty.')
        else:
            tree.print_all_paths_to_leaf()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print only Nodes in Left SubTree
================================ EOPN
Python Program to Print only Nodes in Left SubTree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? left
Nodes of left subtree: 4 2 5 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 10 at root
What would you like to do? left
Nodes of left subtree: 
What would you like to do? insert 1 right of 10
What would you like to do? insert 2 left of 10
What would you like to do? insert 3 right of 2
What would you like to do? left
Nodes of left subtree: 2 3 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left(self):
        if self.left is not None:
            self.left.inorder()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('left')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'left':
        print('Nodes of left subtree: ', end='')
        if btree is not None:
            btree.print_left()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOPN
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 1 2 
What would you like to do? add 3 below 1
What would you like to do? add 10 below 2
What would you like to do? add 12 below 2
What would you like to do? add 14 below 3
What would you like to do? add 7 below 14
What would you like to do? bfs
BFS traversal: 1 2 3 10 12 14 7 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 8 below 5
What would you like to do? add 4 below 7
What would you like to do? add 3 below 7
What would you like to do? add 1 below 8
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 5 7 8 4 3 1 2 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('bfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'bfs':
        if tree is None:
            print('Tree is empty.')
        else:
            print('BFS traversal: ', end='')
            tree.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 7 left of 3
inorder traversal of binary tree: 7 3 
What would you like to do? sum
Sum of nodes in tree: 10
inorder traversal of binary tree: 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 2 at root
inorder traversal of binary tree: 2 
What would you like to do? insert 10 left of 2
inorder traversal of binary tree: 10 2 
What would you like to do? insert 1 right of 2
inorder traversal of binary tree: 10 2 1 
What would you like to do? insert 5 left of 1
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? sum
Sum of nodes in tree: 18
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def sum_nodes(node):
    if node is None:
        return 0
    return node.key + sum_nodes(node.left) + sum_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('sum')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'sum':
        print('Sum of nodes in tree: {}'.format(sum_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Graph
================================ EOPN
Python Program to Implement Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? display
Vertices: 1 2 
Edges: 

What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 

What would you like to do? add edge 1 3
What would you like to do? add edge 3 1
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 
(src=1, dest=3, weight=1) 
(src=3, dest=1, weight=1) 

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 4 5
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 

What would you like to do? add edge 5 4
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 
(src=5, dest=4, weight=1) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> [weight]')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    if len(do) == 5:
                        weight = int(do[4])
                        g.add_edge(src, dest, weight)
                    else:
                        g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Breadth-First Search on a Graph
================================ EOPN
Python Program to Implement Breadth-First Search on a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add vertex 9
What would you like to do? add vertex 10
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 1 5
What would you like to do? add edge 2 6
What would you like to do? add edge 3 7
What would you like to do? add edge 3 8
What would you like to do? add edge 4 8
What would you like to do? add edge 8 10
What would you like to do? add edge 5 10
What would you like to do? add edge 6 9
What would you like to do? add edge 9 10
What would you like to do? bfs 1
Breadth-first Traversal: 1 3 2 5 7 8 6 10 9 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bfs 1
Breadth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 
What would you like to do? bfs 2
Breadth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? bfs 2
Breadth-first Traversal: 2 1 
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 3 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def display_bfs(vertex):
    """Display BFS Traversal starting at vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        print(current.get_key(), end=' ')
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('bfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'bfs':
        key = int(do[1])
        print('Breadth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_bfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1, 4]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 5 4
What would you like to do? reachable 4
All nodes reachable from 4: [4]
What would you like to do? reachable 5
All nodes reachable from 5: [4, 5]
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2, 3]
What would you like to do? reachable 3
All nodes reachable from 3: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_all_reachable_nodes(vertex):
    """Return set containing all vertices reachable from vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)
    return visited


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 5 1
What would you like to do? add edge 4 2
What would you like to do? components
Component 1: [5, 2, 4, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
Vertex already exists.
What would you like to do? components
Component 1: [2, 3, 1]
Component 2: [4]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        component[current] = label
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            component_vertices = [v.get_key() for v in component
                                  if component[v] == label]
            print('Component {}:'.format(label), component_vertices)



    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOPN
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
What would you like to do? add edge 1 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 1): 3 1
Vertex 2 (distance 1): 2 1
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? add edge 4 5
What would you like to do? add edge 4 6
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 3): 5 4 2 1
Vertex 6 (distance 3): 6 4 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? add edge 2 6
What would you like to do? add edge 1 5
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 1): 5 1
Vertex 6 (distance 2): 6 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        # dictionary containing destination vertices mapped to the weight of the
        # edge with which they are joined to this vertex
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_shortest_paths(src):
    """Returns tuple of two dictionaries: (parent, distance)

    parent contains vertices mapped to their parent vertex in the shortest
    path from src to that vertex.
    distance contains vertices mapped to their shortest distance from src.
    """
    parent = {src: None}
    distance = {src: 0}

    visited = set()
    q = Queue()
    q.enqueue(src)
    visited.add(src)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                distance[dest] = distance[current] + 1
                q.enqueue(dest)
    return (parent, distance)

g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('shortest <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        src = g.get_vertex(key)
        parent, distance = find_shortest_paths(src)

        print('Path from destination vertices to source vertex {}:'.format(key))
        for v in parent:
            print('Vertex {} (distance {}): '.format(v.get_key(), distance[v]),
                  end='')
            while parent[v] is not None:
                print(v.get_key(), end = ' ')
                v = parent[v]
            print(src.get_key()) # print source vertex

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 2 4
What would you like to do? add edge 2 5
What would you like to do? add edge 6 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 6 2
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_cycle_present(vertex, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {vertex: None}
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                q.enqueue(dest)
            else:
                if parent[current] is not dest:
                    return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 5 6
What would you like to do? add edge 6 7
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 7 1
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    visited.add(vertex)
    q = Queue()
    q.enqueue(vertex)
    while not q.is_empty():
        current = q.dequeue()

        next_colour = 1 - colour[current] # switch colour
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                colour[dest] = next_colour
                q.enqueue(dest)
            else:
                if colour[dest] != next_colour:
                    return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 3 5
What would you like to do? add edge 1 6
What would you like to do? add edge 6 2
What would you like to do? dfs 1
Depth-first Traversal: 1 6 2 3 4 5 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 1 2 
What would you like to do? dfs 2
Depth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? dfs 2
Depth-first Traversal: 2 3 4 1 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def display_dfs(v):
    """Display DFS traversal starting at vertex v."""
    display_dfs_helper(v, set())


def display_dfs_helper(v, visited):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes."""
    visited.add(v)
    print(v.get_key(), end=' ')
    for dest in v.get_neighbours():
        if dest not in visited:
            display_dfs_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? add edge 3 7
What would you like to do? dfs 1
Depth-first Traversal: 1 5 6 2 3 7 4 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


def display_dfs(v):
    visited = set()
    s = Stack()
    s.push(vertex)
    while not s.is_empty():
        current = s.pop()
        if current in visited:
            continue
        print(current.get_key(), end=' ')
        visited.add(current)
        for dest in current.get_neighbours():
            if dest not in visited:
                s.push(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print DFS Numbering of a Graph
================================ EOPN
Python Program to Print DFS Numbering of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Visiting 3... discovered time = 3
Visiting 4... discovered time = 4
Leaving 4... finished time = 5
Leaving 3... finished time = 6
Leaving 2... finished time = 7
Visiting 5... discovered time = 8
Visiting 6... discovered time = 9
Leaving 6... finished time = 10
Leaving 5... finished time = 11
Leaving 1... finished time = 12

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Leaving 1... finished time = 2

What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Leaving 2... finished time = 3
Leaving 1... finished time = 4

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to

def dfs(v, pre, post):
    """Display DFS traversal starting at vertex v. Stores pre and post times in
    dictionaries pre and post."""
    dfs_helper(v, set(), pre, post, [0])

def dfs_helper(v, visited, pre, post, time):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes, dictionaries pre and post to store
    discovered and finished times and the one-element list time to keep track of
    current time."""
    visited.add(v)
    time[0] = time[0] + 1
    pre[v] = time[0]
    print('Visiting {}... discovered time = {}'.format(v.get_key(), time[0]))
    for dest in v.get_neighbours():
        if dest not in visited:
            dfs_helper(dest, visited, pre, post, time)
    time[0] = time[0] + 1
    post[v] = time[0]
    print('Leaving {}... finished time = {}'.format(v.get_key(), time[0]))


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ')
        vertex = g.get_vertex(key)
        pre = dict()
        post = dict()
        dfs(vertex, pre, post)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 4 5
What would you like to do? add edge 5 6
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 4
All nodes reachable from 4: [6, 4, 5]
What would you like to do? reachable 7
All nodes reachable from 7: [7]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def find_all_reachable_nodes(v):
    """Return set containing all vertices reachable from vertex."""
    reachable = set()
    find_all_reachable_nodes_helper(v, reachable)
    return reachable


def find_all_reachable_nodes_helper(v, visited):
    """Add all vertices visited by DFS traversal starting at v to the set visited."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            find_all_reachable_nodes_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [2, 1]
Component 2: [3]
Component 3: [4]
Component 4: [5]
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 1 5
What would you like to do? components
Component 1: [2, 5, 1]
Component 2: [4, 3]
What would you like to do? add edge 2 4
What would you like to do? components
Component 1: [4, 2, 5, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? components
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? components
Component 1: [1]
Component 2: [2]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [1, 2]
What would you like to do? add vertex 3
What would you like to do? components
Component 1: [1, 2]
Component 2: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    label_all_reachable_helper(vertex, set(), component, label)


def label_all_reachable_helper(vertex, visited, component, label):
    """Set component[v] = label for all v in the component containing
    vertex. Uses set visited to keep track of nodes alread visited."""
    visited.add(vertex)
    component[vertex] = label
    for dest in vertex.get_neighbours():
        if dest not in visited:
            label_all_reachable_helper(dest, visited, component, label)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            print('Component {}:'.format(label),
                  [v.get_key() for v in component if component[v] == label])


    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 5 1
What would you like to do? add edge 6 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 5
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    return is_bipartite_helper(vertex, visited, colour)


def is_bipartite_helper(v, visited, colour):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited. Uses dictionary colour to keep
    track of colour of each vertex."""
    visited.add(v)
    next_colour = 1 - colour[v] # switch colour
    for dest in v.get_neighbours():
        if dest not in visited:
            colour[dest] = next_colour
            if not is_bipartite_helper(dest, visited, colour):
                return False
        else:
            if colour[dest] != next_colour:
                return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add vertex 5
What would you like to do? add edge 4 5
What would you like to do? add edge 5 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(v, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {v: None}
    return is_cycle_present_helper(v, visited, parent)


def is_cycle_present_helper(v, visited, parent):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited. Uses dictionary parent to keep
    track of parents of nodes in the DFS tree."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            parent[dest] = v
            if is_cycle_present_helper(dest, visited, parent):
                return True
        else:
            if parent[v] is not dest:
                return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 4
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 3 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(graph):
    """Return True if cycle is present in the graph."""
    on_stack = set()
    visited = set()
    for v in graph:
        if v not in visited:
            if is_cycle_present_helper(v, visited, on_stack):
                return True
    return False


def is_cycle_present_helper(v, visited, on_stack):
    """Return True if the DFS traversal starting at vertex v detects a
    cycle. Uses set visited to keep track of nodes that have been visited. Uses
    set on_stack to keep track of nodes that are 'on the stack' of the recursive
    calls."""
    if v in on_stack:
        return True
    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if is_cycle_present_helper(dest, visited, on_stack):
                return True
    on_stack.remove(v)
    visited.add(v)
    return False


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_edge_exist(v1, v2):
                    g.add_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        if is_cycle_present(g):
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOPN
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? topological
Topological Sorting: [3, 2, 1]
What would you like to do? add edge 1 2
What would you like to do? topological
Topological Sorting: [3, 1, 2]
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 4 5
What would you like to do? topological
Topological Sorting: [7, 6, 4, 5, 1, 2, 3]
What would you like to do? add edge 4 6
What would you like to do? topological
Topological Sorting: [7, 4, 5, 6, 1, 2, 3]
What would you like to do? add edge 5 7
What would you like to do? topological
Topological Sorting: [4, 5, 7, 6, 1, 2, 3]
What would you like to do? add edge 3 4
What would you like to do? topological
Topological Sorting: [1, 2, 3, 4, 5, 7, 6]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? topological
Topological Sorting: [1]
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add edge 3 2
What would you like to do? topological
Graph is not a DAG.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def get_topological_sorting(graph):
    """Return a topological sorting of the DAG. Return None if graph is not a DAG."""
    tlist = []
    visited = set()
    on_stack = set()
    for v in graph:
        if v not in visited:
            if not get_topological_sorting_helper(v, visited, on_stack, tlist):
                return None
    return tlist


def get_topological_sorting_helper(v, visited, on_stack, tlist):
    """Perform DFS traversal starting at vertex v and store a topological
    sorting of the DAG in tlist. Return False if it is found that the graph is
    not a DAG. Uses set visited to keep track of already visited nodes."""
    if v in on_stack:
        # graph has cycles and is therefore not a DAG.
        return False

    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if not get_topological_sorting_helper(dest, visited, on_stack, tlist):
                return False
    on_stack.remove(v)
    visited.add(v)
    tlist.insert(0, v.get_key()) # prepend node key to tlist
    return True


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('topological')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'topological':
        tlist = get_topological_sorting(g)
        if tlist is not None:
            print('Topological Sorting: ', end='')
            print(tlist)
        else:
            print('Graph is not a DAG.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOPN
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 80
What would you like to do? add edge 3 4 70
What would you like to do? add edge 2 5 20
What would you like to do? add edge 2 3 6
What would you like to do? add edge 5 6 50
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? shortest 1
Distances from 1: 
Distance to 6: 45
Distance to 3: 16
Distance to 4: 86
Distance to 5: 30
Distance to 2: 10
Distance to 7: 40
Distance to 1: 0

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 20
What would you like to do? add edge 3 4 30
What would you like to do? add edge 1 4 100
What would you like to do? shortest 1
Distances from 1: 
Distance to 2: 10
Distance to 4: 60
Distance to 3: 30
Distance to 1: 0
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('shortest <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = dijkstra(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Bellman-Ford Algorithm
================================ EOPN
Python Program to Implement Bellman-Ford Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 8 8
What would you like to do? add edge 2 6 2
What would you like to do? add edge 3 2 1
What would you like to do? add edge 3 4 1
What would you like to do? add edge 4 5 3
What would you like to do? add edge 5 6 -1
What would you like to do? add edge 6 3 -2
What would you like to do? add edge 7 2 -4
What would you like to do? add edge 7 6 -1
What would you like to do? add edge 8 7 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 5: 9
Distance to 6: 7
Distance to 7: 9
Distance to 2: 5
Distance to 1: 0
Distance to 8: 8
Distance to 3: 5
Distance to 4: 6

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0

What would you like to do? add vertex 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 2: inf

What would you like to do? add edge 1 2 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 3 -1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 2

What would you like to do? add edge 3 2 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 1

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('bellman-ford <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'bellman-ford':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = bellman_ford(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Floyd-Warshall Algorithm
================================ EOPN
Python Program to Implement Floyd-Warshall Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 1 3 8
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 5 -> 4 -> 3 -> 2 (distance 1)
From 1 to 3: 1 -> 5 -> 4 -> 3 (distance -3)
From 1 to 4: 1 -> 5 -> 4 (distance 2)
From 1 to 5: 1 -> 5 (distance -4)
From 2 to 1: 2 -> 4 -> 1 (distance 3)
From 2 to 3: 2 -> 4 -> 3 (distance -4)
From 2 to 4: 2 -> 4 (distance 1)
From 2 to 5: 2 -> 4 -> 1 -> 5 (distance -1)
From 3 to 1: 3 -> 2 -> 4 -> 1 (distance 7)
From 3 to 2: 3 -> 2 (distance 4)
From 3 to 4: 3 -> 2 -> 4 (distance 5)
From 3 to 5: 3 -> 2 -> 4 -> 1 -> 5 (distance 3)
From 4 to 1: 4 -> 1 (distance 2)
From 4 to 2: 4 -> 3 -> 2 (distance -1)
From 4 to 3: 4 -> 3 (distance -5)
From 4 to 5: 4 -> 1 -> 5 (distance -2)
From 5 to 1: 5 -> 4 -> 1 (distance 8)
From 5 to 2: 5 -> 4 -> 3 -> 2 (distance 5)
From 5 to 3: 5 -> 4 -> 3 (distance 1)
From 5 to 4: 5 -> 4 (distance 6)
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 -7
What would you like to do? add edge 1 3 5
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 2 (distance 10)
From 1 to 3: 1 -> 2 -> 3 (distance 3)
From 2 to 3: 2 -> 3 (distance -7)
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def floyd_warshall(g):
    """Return dictionaries distance and next_v.

    distance[u][v] is the shortest distance from vertex u to v.
    next_v[u][v] is the next vertex after vertex v in the shortest path from u
    to v. It is None if there is no path between them. next_v[u][u] should be
    None for all u.

    g is a Graph object which can have negative edge weights.
    """
    distance = {v:dict.fromkeys(g, float('inf')) for v in g}
    next_v = {v:dict.fromkeys(g, None) for v in g}

    for v in g:
        for n in v.get_neighbours():
            distance[v][n] = v.get_weight(n)
            next_v[v][n] = n

    for v in g:
         distance[v][v] = 0
         next_v[v][v] = None

    for p in g: 
        for v in g:
            for w in g:
                if distance[v][w] > distance[v][p] + distance[p][w]:
                    distance[v][w] = distance[v][p] + distance[p][w]
                    next_v[v][w] = next_v[v][p]

    return distance, next_v


def print_path(next_v, u, v):
    """Print shortest path from vertex u to v.

    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u
    in the shortest path from u to v. It is None if there is no path between
    them. next_v[u][u] should be None for all u.

    u and v are Vertex objects.
    """
    p = u
    while (next_v[p][v]):
        print('{} -> '.format(p.get_key()), end='')
        p = next_v[p][v]
    print('{} '.format(v.get_key()), end='')


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('floyd-warshall')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'floyd-warshall':
        distance, next_v = floyd_warshall(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                if next_v[start][end]:
                    print('From {} to {}: '.format(start.get_key(),
                                                    end.get_key()),
                            end = '')
                    print_path(next_v, start, end)
                    print('(distance {})'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Transitive Closure of a Graph
================================ EOPN
Python Program to Find Transitive Closure of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
transitive-closure
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
2, 2
What would you like to do? add edge 1 2 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
2, 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
1, 3
2, 2
2, 3
3, 3
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
transitive-closure
display
quit
What would you like to do? add vertex 0
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 0 1
What would you like to do? add edge 0 2
What would you like to do? add edge 1 2
What would you like to do? add edge 2 0
What would you like to do? add edge 2 3
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
0, 0
0, 1
0, 2
0, 3
1, 0
1, 1
1, 2
1, 3
2, 0
2, 1
2, 2
2, 3
3, 3
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def transitive_closure(g):
    """Return dictionary reachable.

    reachable[u][v] = True iff there is a path from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    reachable = {v:dict.fromkeys(g, False) for v in g}

    for v in g:
        for n in v.get_neighbours():
            reachable[v][n] = True

    for v in g:
         reachable[v][v] = True

    for p in g: 
        for v in g:
            for w in g:
                if reachable[v][p] and reachable[p][w]:
                    reachable[v][w] = True

    return reachable


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('transitive-closure')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'transitive-closure':
        reachable = transitive_closure(g)
        print('All pairs (u, v) such that there is a path from u to v: ')
        for start in g:
            for end in g:
                if reachable[start][end]:
                    print('{}, {}'.format(start.get_key(), end.get_key()))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 3 18
What would you like to do? add edge 1 2 10
What would you like to do? add edge 3 4 70
What would you like to do? add edge 3 2 6
What would you like to do? add edge 2 5 20
What would you like to do? add edge 5 6 10
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 7 
Edges: 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=2, dest=3, weight=6) 
(src=3, dest=2, weight=6) 
(src=3, dest=4, weight=70) 
(src=4, dest=3, weight=70) 
(src=5, dest=6, weight=10) 
(src=5, dest=2, weight=20) 
(src=6, dest=5, weight=10) 
(src=6, dest=7, weight=5) 
(src=7, dest=6, weight=5) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 100
What would you like to do? add edge 1 3 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=10) 
(src=1, dest=3, weight=50) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=50) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_prim(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    # if graph is empty
    if not g:
        return mst

    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    nearest_neighbour = {}
    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    smallest_distance = {}
    # v is in unvisited iff v has not been added to the MST
    unvisited = set(g)

    u = next(iter(g)) # select any one vertex from g
    mst.add_vertex(u.get_key()) # add a copy of it to the MST
    unvisited.remove(u)

    # for each neighbour of vertex u
    for n in u.get_neighbours():
        if n is u:
            # avoid self-loops
            continue
        # update dictionaries
        nearest_neighbour[n] = mst.get_vertex(u.get_key())
        smallest_distance[n] = u.get_weight(n)

    # loop until smallest_distance becomes empty
    while (smallest_distance):
        # get nearest vertex outside the MST
        outside_mst = min(smallest_distance, key=smallest_distance.get)
        # get the nearest neighbour inside the MST
        inside_mst = nearest_neighbour[outside_mst]

        # add a copy of the outside vertex to the MST
        mst.add_vertex(outside_mst.get_key())
        # add the edge to the MST
        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),
                     smallest_distance[outside_mst])
        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),
                     smallest_distance[outside_mst])

        # now that outside_mst has been added to the MST, remove it from our
        # dictionaries and the set unvisited
        unvisited.remove(outside_mst)
        del smallest_distance[outside_mst]
        del nearest_neighbour[outside_mst]

        # update dictionaries
        for n in outside_mst.get_neighbours():
            if n in unvisited:
                if n not in smallest_distance:
                    smallest_distance[n] = outside_mst.get_weight(n)
                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())
                else:
                    if smallest_distance[n] > outside_mst.get_weight(n):
                        smallest_distance[n] = outside_mst.get_weight(n)
                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_prim(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 5 30
What would you like to do? add edge 1 4 40
What would you like to do? add edge 2 5 20
What would you like to do? add edge 4 5 40
What would you like to do? add edge 5 3 40
What would you like to do? add edge 5 6 70
What would you like to do? add edge 3 6 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 
Edges: 
(src=1, dest=4, weight=40) 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=3, dest=5, weight=40) 
(src=3, dest=6, weight=50) 
(src=4, dest=1, weight=40) 
(src=5, dest=2, weight=20) 
(src=5, dest=3, weight=40) 
(src=6, dest=3, weight=50) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 20
What would you like to do? add edge 2 3 30
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=3, weight=20) 
(src=1, dest=2, weight=10) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=20) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_vertex_exist(self, key):
        return key in self.vertices

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_krusal(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    if len(g) == 1:
        u = next(iter(g)) # get the single vertex
        mst.add_vertex(u.get_key()) # add a copy of it to mst
        return mst

    # get all the edges in a list
    edges = []
    for v in g:
        for n in v.get_neighbours():
            # avoid adding two edges for each edge of the undirected graph
            if v.get_key() < n.get_key():
                edges.append((v, n))

    # sort edges
    edges.sort(key=lambda edge: edge[0].get_weight(edge[1]))

    # initially, each vertex is in its own component
    component = {}
    for i, v in enumerate(g):
        component[v] = i

    # next edge to try
    edge_index = 0

    # loop until mst has the same number of vertices as g
    while len(mst) < len(g):
        u, v = edges[edge_index]
        edge_index += 1

        # if adding edge (u, v) will not form a cycle
        if component[u] != component[v]:

            # add to mst
            if not mst.does_vertex_exist(u.get_key()):
                mst.add_vertex(u.get_key())
            if not mst.does_vertex_exist(v.get_key()):
                mst.add_vertex(v.get_key())
            mst.add_edge(u.get_key(), v.get_key(), u.get_weight(v))
            mst.add_edge(v.get_key(), u.get_key(), u.get_weight(v))

            # merge components of u and v
            for w in g:
                if component[w] == component[v]:
                    component[w] = component[u]

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_krusal(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Johnsons Algorithm
================================ EOPN
Python Program to Implement Johnsons Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 3 8
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 1
1 to 3 distance -3
1 to 4 distance 2
1 to 5 distance -4
2 to 1 distance 3
2 to 2 distance 0
2 to 3 distance -4
2 to 4 distance 1
2 to 5 distance -1
3 to 1 distance 7
3 to 2 distance 4
3 to 3 distance 0
3 to 4 distance 5
3 to 5 distance 3
4 to 1 distance 2
4 to 2 distance -1
4 to 3 distance -5
4 to 4 distance 0
4 to 5 distance -2
5 to 1 distance 8
5 to 2 distance 5
5 to 3 distance 1
5 to 4 distance 6
5 to 5 distance 0
What would you like to do? quit

Case 2:
python 226__graph_johnson.py
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance inf
2 to 1 distance inf
2 to 2 distance 0
What would you like to do? add edge 1 2 100
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 -50
What would you like to do? add edge 1 3 60
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 100
1 to 3 distance 50
2 to 1 distance inf
2 to 2 distance 0
2 to 3 distance -50
3 to 1 distance inf
3 to 2 distance inf
3 to 3 distance 0
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def set_weight(self, dest, weight):
        """Set weight of edge from this vertex to dest."""
        self.points_to[dest] = weight

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def johnson(g):
    """Return distance where distance[u][v] is the min distance from u to v.

    distance[u][v] is the shortest distance from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    # add new vertex q
    g.add_vertex('q')
    # let q point to all other vertices in g with zero-weight edges
    for v in g:
        g.add_edge('q', v.get_key(), 0)

    # compute shortest distance from vertex q to all other vertices
    bell_dist = bellman_ford(g, g.get_vertex('q'))

    # set weight(u, v) = weight(u, v) + bell_dist(u) - bell_dist(v) for each
    # edge (u, v)
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[v] - bell_dist[n])

    # remove vertex q
    # This implementation of the graph stores edge (u, v) in Vertex object u
    # Since no other vertex points back to q, we do not need to worry about
    # removing edges pointing to q from other vertices.
    del g.vertices['q']

    # distance[u][v] will hold smallest distance from vertex u to v
    distance = {}
    # run dijkstra's algorithm on each source vertex
    for v in g:
        distance[v] = dijkstra(g, v)

    # correct distances
    for v in g:
        for w in g:
            distance[v][w] += bell_dist[w] - bell_dist[v]

    # correct weights in original graph
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[n] - bell_dist[v])

    return distance


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('johnson')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'johnson':
        distance = johnson(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                print('{} to {}'.format(start.get_key(), end.get_key()), end=' ')
                print('distance {}'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Read a Linked List in Reverse
================================ EOPN
Python Program to Read a Linked List in Reverse
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 5
Enter data item: 3
Enter data item: 10
Enter data item: 2
The linked list: 2 10 3 5 

Case 2:
How many elements would you like to add? 1
Enter data item: 8
The linked list: 8 

Case 3:
How many elements would you like to add? 3
Enter data item: 1
Enter data item: 2
Enter data item: 3
The linked list: 3 2 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    node = Node(data)
    a_llist.insert_at_beg(node)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Create a Linked List & Display the Elements in the List
================================ EOPN
Python Program to Create a Linked List & Display the Elements in the List
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: -2
Enter data item: 1
Enter data item: 5
Enter data item: 0
The linked list: 3 -2 1 5 0 

Case 2:
How many elements would you like to add? 1
Enter data item: 6
The linked list: 6 

Case 3:
How many elements would you like to add? 4
Enter data item: 2
Enter data item: 9
Enter data item: 3
Enter data item: 2
The linked list: 2 9 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Search for an Element in the Linked List using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 5
5 is at index 1.

Case 2:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 7
7 is at index 4.

Case 3:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 4
4 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        return self.find_index_helper(key, 0, self.head)

    def find_index_helper(self, key, start, node):
        if node is None:
            return -1

        if node.data == key:
            return start
        else:
            return self.find_index_helper(key, start + 1, node.next)

a_llist = LinkedList()
for data in [3, 5, 0, 10, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 9
9 is at index 4.

Case 2:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 11
11 is at index 5.

Case 3:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 3
3 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        current = self.head

        index = 0
        while current:
            if current.data == key:
                return index
            current = current.next
            index = index + 1

        return -1

a_llist = LinkedList()
for data in [4, -3, 1, 0, 9, 11]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: 8
Enter data item: 14
Enter data item: 2
Enter data item: 1
The reversed linked list: 1 2 14 8 3 

Case 2:
How many elements would you like to add? 1
Enter data item: 3
The reversed linked list: 3 

Case 3:
How many elements would you like to add? 2
Enter data item: 0
Enter data item: 1
The reversed linked list: 1 0
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        self.display_reversed_helper(self.head)

    def display_reversed_helper(self, current):
        if current is None:
            return

        self.display_reversed_helper(current.next)
        print(current.data, end = ' ')

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 3
Enter data item: 7
Enter data item: 2
Enter data item: 1
The linked list: 7 2 1 

Case 2:
How many elements would you like to add? 1
Enter data item: 2
The linked list: 2 

Case 3:
How many elements would you like to add? 5
Enter data item: 4
Enter data item: 2
Enter data item: 3
Enter data item: 5
Enter data item: 1
The linked list: 4 2 3 5 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        self.display_helper(self.head)

    def display_helper(self, current):
        if current is None:
            return

        print(current.data, end = ' ')
        self.display_helper(current.next)

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOPN
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 7
Enter data item: 2
Enter data item: 1
Enter data item: 9
The reversed linked list: 9 1 2 7 

Case 2:
How many elements would you like to add? 1
Enter data item: 5
The reversed linked list: 5 

Case 3:
How many elements would you like to add? 2
Enter data item: 3
Enter data item: 1
The reversed linked list: 1 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        end_node = None

        while end_node != self.head:
            current = self.head
            while current.next != end_node:
                current = current.next
            print(current.data, end = ' ')
            end_node = current

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Find the Length of the Linked List using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 4 10
The length of the linked list is 3.

Case 2:
Please enter the elements in the linked list: 7
The length of the linked list is 1.

Case 3:
Please enter the elements in the linked list: 3 4 1 -1 3 9
The length of the linked list is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        return self.length_helper(self.head)

    def length_helper(self, current):
        if current is None:
            return 0
        return 1 + self.length_helper(current.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Find the Length of the Linked List without using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 8 1
The length of the linked list is 2.

Case 2:
Please enter the elements in the linked list: 
The length of the linked list is 0.

Case 3:
Please enter the elements in the linked list: 7 5 9 12
The length of the linked list is 4.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        current = self.head
        length = 0
        while current:
            length = length + 1
            current = current.next
        return length

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 3
3 occurs 2 time(s) in the list.

Case 2:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 7
7 occurs 4 time(s) in the list.

Case 3:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 2
2 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        return self.count_helper(self.head, key)

    def count_helper(self, current, key):
        if current is None:
            return 0

        if current.data == key:
            return 1 + self.count_helper(current.next, key)
        else:
            return self.count_helper(current.next, key)

a_llist = LinkedList()
for data in [7, 3, 7, 4, 7, 11, 4, 0, 3, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 5
5 occurs 3 time(s) in the list.

Case 2:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 3
3 occurs 1 time(s) in the list.

Case 3:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 7
7 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        current = self.head

        count = 0
        while current:
            if current.data == key:
                count = count + 1
            current = current.next

        return count

a_llist = LinkedList()
for data in [5, 1, 3, 5, 5, 15, 4, 9, 2]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 1 40 3 10
The alternate nodes of the linked list: 7 1 3 

Case 2:
Please enter the elements in the linked list: 4 9 1
The alternate nodes of the linked list: 4 1 

Case 3:
Please enter the elements in the linked list: 3
The alternate nodes of the linked list: 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        self.alternate_helper(self.head)

    def alternate_helper(self, current):
        if current is None:
            return
        print(current.data, end = ' ')
        if current.next:
            self.alternate_helper(current.next.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 4 1 9 10 3
The alternate nodes of the linked list: 7 4 9 3 

Case 2:
Please enter the elements in the linked list: 1 2
The alternate nodes of the linked list: 1 

Case 3:
Please enter the elements in the linked list: 9
The alternate nodes of the linked list: 9
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            if current.next is not None:
                current = current.next.next
            else:
                break

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Implement a Stack using Linked List
================================ EOPN
Python Program to Implement a Stack using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 15
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Popped value:  15
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Stack:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node

    def pop(self):
        if self.head is None:
            return None
        else:
            popped = self.head.data
            self.head = self.head.next
            return popped

a_stack = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        a_stack.push(int(do[1]))
    elif operation == 'pop':
        popped = a_stack.pop()
        if popped is None:
            print('Stack is empty.')
        else:
            print('Popped value: ', int(popped))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue Data Structure using Linked List
================================ EOPN
Python Program to Implement Queue Data Structure using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 5
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  5
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.last = None

    def enqueue(self, data):
        if self.last is None:
            self.head = Node(data)
            self.last = self.head
        else:
            self.last.next = Node(data)
            self.last = self.last.next

    def dequeue(self):
        if self.head is None:
            return None
        else:
            to_return = self.head.data
            self.head = self.head.next
            return to_return

a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        dequeued = a_queue.dequeue()
        if dequeued is None:
            print('Queue is empty.')
        else:
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Binary Tree using Linked List
================================ EOPN
Python Program to Implement Binary Tree using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 5 left of 3
inorder traversal of binary tree: 5 3 
What would you like to do? insert 2 right of 5
inorder traversal of binary tree: 5 2 3 
What would you like to do? insert 11 right of 3
inorder traversal of binary tree: 5 2 3 11 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 left of 2
inorder traversal of binary tree: 4 2 1 3 
What would you like to do? insert 5 right of 2
inorder traversal of binary tree: 4 2 5 1 3 
What would you like to do? insert 6 left of 3
inorder traversal of binary tree: 4 2 5 1 6 3 
What would you like to do? insert 7 right of 3
inorder traversal of binary tree: 4 2 5 1 6 3 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether 2 Linked Lists are Same
================================ EOPN
Python Program to Check whether 2 Linked Lists are Same
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 5 8 10 12
Please enter the elements in the second linked list: 5 8 10 12
The two linked lists are the same.

Case 2:
Please enter the elements in the first linked list: 12 3 4 5 0
Please enter the elements in the second linked list: 12 3
The two linked list are not the same.

Case 3:
Please enter the elements in the first linked list: 4 1
Please enter the elements in the second linked list: 2 19 4
The two linked list are not the same.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def is_equal(llist1, llist2):
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        if current1.data != current2.data:
            return False
        current1 = current1.next
        current2 = current2.next
    if current1 is None and current2 is None:
        return True
    else:
        return False


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

if is_equal(llist1, llist2):
    print('The two linked lists are the same.')
else:
    print('The two linked list are not the same.', end = '')
 ETP  
 
Python Program to Detect the Cycle in a Linked List
================================ EOPN
Python Program to Detect the Cycle in a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3
Enter the index [0-2] of the node to which you want the last node to point (enter nothing to make it point to None): 0
The linked list has a cycle.

Case 2:
Please enter the elements in the linked list: 4 5
Enter the index [0-1] of the node to which you want the last node to point (enter nothing to make it point to None): 1
The linked list has a cycle.

Case 3:
Please enter the elements in the linked list: 9 1 4 5
Enter the index [0-3] of the node to which you want the last node to point (enter nothing to make it point to None): 
The linked list does not have a cycle.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            current = current.next
            if current is None:
                return None
        return current


def has_cycle(llist):
    slow = llist.head
    fast = llist.head
    while (fast != None and fast.next != None):
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

length = len(data_list)
if length != 0:
    values = '0-' + str(length - 1)
    last_ptr = input('Enter the index [' + values + '] of the node'
                     ' to which you want the last node to point'
                     ' (enter nothing to make it point to None): ').strip()
    if last_ptr == '':
        last_ptr = None
    else:
        last_ptr = a_llist.get_node(int(last_ptr))
        a_llist.last_node.next = last_ptr

if has_cycle(a_llist):
    print('The linked list has a cycle.')
else:
    print('The linked list does not have a cycle.')
 ETP  
 
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOPN
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the doubly linked list: 5 10 9 3
The largest element is 10.

Case 2:
Please enter the elements in the doubly linked list: 
The list is empty.

Case 3:
Please enter the elements in the doubly linked list: 234 10 4 200
The largest element is 234.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def append(self, data):
        self.insert_at_end(Node(data))

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            new_node.prev = self.last
            self.last.next = new_node
            self.last = new_node


def find_largest(dllist):
    if dllist.first is None:
        return None
    largest = dllist.first.data
    current = dllist.first.next
    while current:
        if current.data > largest:
            largest = current.data
        current = current.next
    return largest


a_dllist = DoublyLinkedList()

data_list = input('Please enter the elements in the doubly linked list: ').split()
for data in data_list:
    a_dllist.append(int(data))

largest = find_largest(a_dllist)
if largest:
    print('The largest element is {}.'.format(largest))
else:
    print('The list is empty.')
 ETP  
 
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOPN
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 9 10 15
Please enter the elements in the second linked list: 2 5 4
The sum linked list: 3 14 14 15 

Case 2:
Please enter the elements in the first linked list: 3 4 5
Please enter the elements in the second linked list: 
The sum linked list: 3 4 5 

Case 3:
Please enter the elements in the first linked list: 7 10
Please enter the elements in the second linked list: 6 5 4 3 2
The sum linked list: 13 15 4 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next


def add_linked_lists(llist1, llist2):
    sum_llist = LinkedList()
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        sum = current1.data + current2.data
        sum_llist.append(sum)
        current1 = current1.next
        current2 = current2.next
    if current1 is None:
        while current2:
            sum_llist.append(current2.data)
            current2 = current2.next
    else:
        while current1:
            sum_llist.append(current1.data)
            current1 = current1.next
    return sum_llist



llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

sum_llist = add_linked_lists(llist1, llist2)

print('The sum linked list: ', end = '')
sum_llist.display()
 ETP  
 
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOPN
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 4 5 1 3 10
Please enter the elements in the second linked list: 8 3 40 1
The element that appears first in the first linked list that is common to both is 1.

Case 2:
Please enter the elements in the first linked list: 1 4 5
Please enter the elements in the second linked list: 3 10
The two lists have no common elements.

Case 3:
Please enter the elements in the first linked list: 6 8 9
Please enter the elements in the second linked list: 7 10 6 4 9 8
The element that appears first in the first linked list that is common to both is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def first_common(llist1, llist2):
    current1 = llist1.head
    while current1:
        data = current1.data
        current2 = llist2.head
        while current2:
            if data == current2.data:
                return data
            current2 = current2.next
        current1 = current1.next
    return None


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

common = first_common(llist1, llist2)

if common:
    print('The element that appears first in the first linked list that'
          ' is common to both is {}.'.format(common))
else:
    print('The two lists have no common elements.')
 ETP  
 
Python Program to Remove Duplicates from a Linked List
================================ EOPN
Python Program to Remove Duplicates from a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 5 2 1 4 5 4 5
The list with duplicates removed: 
1 5 2 4 

Case 2:
Please enter the elements in the linked list: 3 4 1
The list with duplicates removed: 
3 4 1 

Case 3:
Please enter the elements in the linked list: 1 3 3 14 5 1 0
The list with duplicates removed: 
1 3 14 5 0
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        data = current1.data
        current2 = current1.next
        while current2:
            if current2.data == data:
                llist.remove(current2)
            current2 = current2.next
        current1 = current1.next


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

remove_duplicates(a_llist)

print('The list with duplicates removed: ')
a_llist.display()
 ETP  
 
Python Program to Reverse a Linked List
================================ EOPN
Python Program to Reverse a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 30 4
The reversed list: 
4 30 1 7 

Case 2:
Please enter the elements in the linked list: 3
The reversed list: 
3 

Case 3:
Please enter the elements in the linked list: 1 2
The reversed list: 
2 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist):
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    while after:
        current.next = before
        before = current
        current = after
        after = after.next
    current.next = before
    llist.head = current


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

reverse_llist(a_llist)

print('The reversed list: ')
a_llist.display()
 ETP  
 
Python Program to Reverse only First N Elements of a Linked List
================================ EOPN
Python Program to Reverse only First N Elements of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7
Enter the number of elements you want to reverse in the list: 4
The new list: 
4 3 2 1 5 6 7 

Case 2:
Please enter the elements in the linked list: 7 2 4
Enter the number of elements you want to reverse in the list: 1
The new list: 
7 2 4 

Case 3:
Please enter the elements in the linked list: 8 3 2
Enter the number of elements you want to reverse in the list: 3
The new list: 
2 3 8
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist, n):
    if n == 0:
        return
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    for i in range(n):
        current.next = before
        before = current
        current = after
        if after is None:
            break
        after = after.next
    llist.head.next = current
    llist.head = before


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))
n = int(input('Enter the number of elements you want to reverse in the list: '))

reverse_llist(a_llist, n)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Print Middle most Node of a Linked List
================================ EOPN
Python Program to Print Middle most Node of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7 8
The two middle elements are 4 and 5.

Case 2:
Please enter the elements in the linked list: 5
The middle element is 5.

Case 3:
Please enter the elements in the linked list: 3 1 0 4 2
The middle element is 0.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def print_middle(llist):
    current = llist.head
    length = 0
    while current:
        current = current.next
        length = length + 1

    current = llist.head
    for i in range((length - 1)//2):
        current = current.next

    if current:
        if length % 2 == 0:
            print('The two middle elements are {} and {}.'
                .format(current.data, current.next.data))
        else:
            print('The middle element is {}.'.format(current.data))
    else:
        print('The list is empty.')


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_middle(a_llist)
 ETP  
 
Python Program to Print Nth Node from the last of a Linked List
================================ EOPN
Python Program to Print Nth Node from the last of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 10 20 40 50 60
The nth element from the end will be printed. Please enter n: 3
The nth element from the end: 40

Case 2:
Please enter the elements in the linked list: 4 23 3
The nth element from the end will be printed. Please enter n: 1
The nth element from the end: 3

Case 3:
Please enter the elements in the linked list: 1 2
The nth element from the end will be printed. Please enter n: 2
The nth element from the end: 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def length_llist(llist):
    length = 0
    current = llist.head
    while current:
        current = current.next
        length = length + 1
    return length


def return_n_from_last(llist, n):
    l = length_llist(llist)
    current = llist.head
    for i in range(l - n):
        current = current.next
    return current.data


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

n = int(input('The nth element from the end will be printed. Please enter n: '))
value = return_n_from_last(a_llist, n)

print('The nth element from the end: {}'.format(value))
 ETP  
 
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOPN
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 2 3 4 5
Please enter the elements in the second linked list: 3 4 5 6 7 8
Their union: 
1 2 3 4 5 6 7 8 
Their intersection: 
3 4 5 

Case 2:
Please enter the elements in the first linked list: 
Please enter the elements in the second linked list: 7 8
Their union: 
7 8 
Their intersection: 

Case 3:
Please enter the elements in the first linked list: 8 4 2 1 10 3 4 7 8
Please enter the elements in the second linked list: 5 6 3 4 3 2 5 2 8
Their union: 
8 4 2 1 10 3 7 5 6 
Their intersection: 
8 4 2 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def duplicate(self):
        copy = LinkedList()
        current = self.head
        while current:
            node = Node(current.data)
            copy.insert_at_end(node)
            current = current.next
        return copy

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        current2 = current1.next
        data = current1.data
        while current2:
            temp = current2
            current2 = current2.next
            if temp.data == data:
                llist.remove(temp)
        current1 = current1.next


def find_union(llist1, llist2):
    if llist1.head is None:
        union = llist2.duplicate()
        remove_duplicates(union)
        return union
    if llist2.head is None:
        union = llist1.duplicate()
        remove_duplicates(union)
        return union

    union = llist1.duplicate()
    last_node = union.head
    while last_node.next is not None:
        last_node = last_node.next
    llist2_copy = llist2.duplicate()
    last_node.next = llist2_copy.head
    remove_duplicates(union)

    return union


def find_intersection(llist1, llist2):
    if (llist1.head is None or llist2.head is None):
        return LinkedList()

    intersection = LinkedList()
    current1 = llist1.head
    while current1:
        current2 = llist2.head
        data = current1.data
        while current2:
            if current2.data == data:
                node = Node(data)
                intersection.insert_at_end(node)
                break
            current2 = current2.next
        current1 = current1.next
    remove_duplicates(intersection)

    return intersection


a_llist1 = LinkedList()
a_llist2 = LinkedList()
data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist1.insert_at_end(node)
data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist2.insert_at_end(node)

union = find_union(a_llist1, a_llist2)
intersection = find_intersection(a_llist1, a_llist2)

print('Their union: ')
union.display()
print()
print('Their intersection: ')
intersection.display()
print()
 ETP  
 
Python Program to Solve Josephus Problem using Linked List
================================ EOPN
Python Program to Solve Josephus Problem using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Input number of people: 5
The kth person will be executed. Input k: 3
The person at position 4 won't be killed.

Case 2:
Input number of people: 15
The kth person will be executed. Input k: 7
The person at position 5 won't be killed.

Case 3:
Input number of people: 8
The kth person will be executed. Input k: 2
The person at position 1 won't be killed.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        node = Node(data)
        self.insert_at_end(node)

    def get_node(self, index, start):
        if self.head is None:
            return None
        current = start
        for i in range(index):
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next


def has_one_node(cllist):
    if cllist.head.next == cllist.head:
        return True
    else:
        return False


def get_josephus_solution(cllist, k):
    if cllist.head is None:
        return None
    start = cllist.head
    while not has_one_node(cllist):
        to_remove = cllist.get_node(k - 1, start)
        start = to_remove.next
        cllist.remove(to_remove)
    return cllist.head.data


a_cllist = CircularLinkedList()
n = int(input('Input number of people: '))
k = int(input('The kth person will be executed. Input k: '))
for i in range(1, n + 1):
    a_cllist.append(i)

ans = get_josephus_solution(a_cllist, k)
print('The person at position {} won\'t be killed.'.format(ans))
 ETP  
 
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOPN
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
Please enter the two indices of the two elements that you want to exchange: 0 1
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 5 1
Please enter the two indices of the two elements that you want to exchange: 1 2
The new list: 
4 1 5 

Case 3:
Please enter the elements in the linked list: 3 1 30 4 5 10 23
Please enter the two indices of the two elements that you want to exchange: 2 5
The new list: 
3 1 10 4 5 30 23
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def interchange(llist, n, m):
    node1 = llist.get_node(n)
    node2 = llist.get_node(m)
    prev_node1 = llist.get_prev_node(node1)
    prev_node2 = llist.get_prev_node(node2)
    if prev_node1 is not None:
        prev_node1.next = node2
    else:
        llist.head = node2
    if prev_node2 is not None:
        prev_node2.next = node1
    else:
        llist.head = node1
    temp = node2.next
    node2.next = node1.next
    node1.next = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

ans = input('Please enter the two indices of the two elements that'
            ' you want to exchange: ').split()
n = int(ans[0])
m = int(ans[1])

interchange(a_llist, n, m)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOPN
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 1 0 4 30 12
The new list: 
12 30 4 0 3 1 

Case 2:
Please enter the elements in the linked list: 1 2
The new list: 
2 1 

Case 3:
Please enter the elements in the linked list: 1 2 3 4 5
The new list: 
4 2 1 3 5
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next


def move_even_before_odd(llist):
    current = llist.head
    while current:
        temp = current.next
        if current.data % 2 == 0:
            llist.remove(current)
            llist.insert_at_beg(current)
        current = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

move_even_before_odd(a_llist)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOPN
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
The nodes at indices n and n+1 will be interchanged. Please enter n: 0
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 1 5
The nodes at indices n and n+1 will be interchanged. Please enter n: 2
The new list: 
5 1 4 

Case 3:
Please enter the elements in the linked list: 3 18 40 1 6
The nodes at indices n and n+1 will be interchanged. Please enter n: 3
The new list: 
3 18 40 6 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def append(self, data):
        self.insert_at_end(Node(data))

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break

def interchange(llist, n):
    current = llist.get_node(n)
    current2 = current.next
    if current2.next != current:
        before = llist.get_prev_node(current)
        after = current2.next
        before.next = current2
        current2.next = current
        current.next = after
    if llist.head == current:
        llist.head = current2
    elif llist.head == current2:
        llist.head = current


a_cllist = CircularLinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_cllist.append(int(data))

n = int(input('The nodes at indices n and n+1 will be interchanged.'
              ' Please enter n: '))

interchange(a_cllist, n)

print('The new list: ')
a_cllist.display()
 ETP  
 
Python Program to Illustrate the Operations of Singly Linked List
================================ EOPN
Python Program to Illustrate the Operations of Singly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 3 at end
The list: 7 3 
What would you like to do? insert 1 after 0
The list: 7 1 3 
What would you like to do? insert 9 before 2
The list: 7 1 9 3 
What would you like to do? remove 2
The list: 7 1 3 
What would you like to do? insert 12 at end
The list: 7 1 3 12 
What would you like to do? remove 0
The list: 1 3 12 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 after 0
No such index.
The list: 
What would you like to do? insert 3 at end
The list: 3 
What would you like to do? insert 1 after 0
The list: 3 1 
What would you like to do? insert 2 before 1
The list: 3 2 1 
What would you like to do? insert 0 at end
The list: 3 2 1 0 
What would you like to do? remove 3
The list: 3 2 1 
What would you like to do? remove 2
The list: 3 2 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_llist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_llist.insert_at_beg(new_node)
            elif position == 'end':
                a_llist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_llist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_llist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_llist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_llist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_llist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOPN
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 8 1 8 7
The linked lists is palindromic.

Case 2:
Please enter the elements in the linked list: 1 2 3 3 2 1
The linked list is palindromic.

Case 3:
Please enter the elements in the linked list: 1 4 5 4 5 1
The linked list is not palindromic.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def is_palindrome(llist):
    start = llist.head
    end = llist.last_node
    while (start != end and end.next != start):
        if start.data != end.data:
            return False
        start = start.next
        end = llist.get_prev_node(end)
    return True


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

if is_palindrome(a_llist):
    print('The linked list is palindromic.')
else:
    print('The linked list is not palindromic.')
 ETP  
 
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOPN
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 3 40 1
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 7.

Case 2:
Please enter the elements in the linked list: 3
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 3.

Case 3:
Please enter the elements in the linked list: 1 2
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 1.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def convert_to_circular(llist):
    if llist.last_node:
        llist.last_node.next = llist.head


def print_last_node_points_to(llist):
    last = llist.last_node
    if last is None:
        print('List is empty.')
        return
    if last.next is None:
        print('Last node points to None.')
    else:
        print('Last node points to element with data {}.'.format(last.next.data))


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_last_node_points_to(a_llist)

print('Converting linked list to a circular linked list...')
convert_to_circular(a_llist)

print_last_node_points_to(a_llist)
 ETP  
 
Python Program to Implement Circular Doubly Linked List
================================ EOPN
Python Program to Implement Circular Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 at beg
The list: 3 
What would you like to do? insert 5 at end
The list: 3 5 
What would you like to do? insert 1 after 0
The list: 3 1 5 
What would you like to do? insert 2 after 2
The list: 3 1 5 2 
What would you like to do? remove 0
The list: 1 5 2 
What would you like to do? remove 2
The list: 1 5 
What would you like to do? remove 1
The list: 1 
What would you like to do? remove 0
The list: 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 10 at end
The list: 10 
What would you like to do? insert 1 at beg
The list: 1 10 
What would you like to do? insert 5 before 0
The list: 1 10 5 
What would you like to do? insert 9 at beg
The list: 9 1 10 5 
What would you like to do? remove 3
The list: 9 1 10 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class CircularDoublyLinkedList:
    def __init__(self):
        self.first = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            current = current.next
            if current == self.first:
                return None
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        new_node.next = ref_node.next
        new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        self.insert_after(ref_node.prev, new_node)

    def insert_at_end(self, new_node):
        if self.first is None:
            self.first = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            self.insert_after(self.first.prev, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.first = new_node

    def remove(self, node):
        if self.first.next == self.first:
            self.first = None
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
            if self.first == node:
                self.first = node.next

    def display(self):
        if self.first is None:
            return
        current = self.first
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.first:
                break


a_cdllist = CircularDoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cdllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cdllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cdllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cdllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cdllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cdllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cdllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cdllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Demonstrate Circular Single Linked List
================================ EOPN
Python Program to Demonstrate Circular Single Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 1 before 0
The list: 7 1 
What would you like to do? insert 10 after 0
The list: 7 10 1 
What would you like to do? insert 3 at end
The list: 7 10 1 3 
What would you like to do? remove 2
The list: 7 10 3 
What would you like to do? remove 0
The list: 10 3 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 1 at beg
The list: 1 
What would you like to do? insert 3 after 2
No such index.
The list: 1 
What would you like to do? remove 1
No such index.
The list: 1 
What would you like to do? insert 6 after 0
The list: 1 6 
What would you like to do? remove 0
The list: 6 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.head = new_node

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break


a_cllist = CircularLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOPN
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 at beg
The list: 5 
What would you like to do? insert 3 at beg
The list: 3 5 
What would you like to do? insert 1 at end
The list: 3 5 1 
What would you like to do? insert 10 after 1
The list: 3 5 10 1 
What would you like to do? insert 0 before 2
The list: 3 5 0 10 1 
What would you like to do? remove 4
The list: 3 5 0 10 
What would you like to do? remove 1
The list: 3 0 10 
What would you like to do? remove 5
No such index.
The list: 3 0 10 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 2 at beg
The list: 2 
What would you like to do? insert 3 before 0
The list: 3 2 
What would you like to do? remove 0
The list: 2 
What would you like to do? remove 0
The list: 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        if ref_node.next is None:
            self.last = new_node
        else:
            new_node.next = ref_node.next
            new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        new_node.next = ref_node
        if ref_node.prev is None:
            self.first = new_node
        else:
            new_node.prev = ref_node.prev
            new_node.prev.next = new_node
        ref_node.prev = new_node

    def insert_at_beg(self, new_node):
        if self.first is None:
            self.first = new_node
            self.last = new_node
        else:
            self.insert_before(self.first, new_node)

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            self.insert_after(self.last, new_node)

    def remove(self, node):
        if node.prev is None:
            self.first = node.next
        else:
            node.prev.next = node.next

        if node.next is None:
            self.last = node.prev
        else:
            node.next.prev = node.prev

    def display(self):
        current = self.first
        while current:
            print(current.data, end = ' ')
            current = current.next


a_dllist = DoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_dllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_dllist.insert_at_beg(new_node)
            elif position == 'end':
                a_dllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_dllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_dllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_dllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_dllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_dllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Stack
================================ EOPN
Python Program to Implement a Stack
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? push 5
push <value>
pop
quit
What would you like to do? pop
Popped value:  5
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? push 1
push <value>
pop
quit
What would you like to do? pop
Popped value:  1
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Reverse a Stack using Recursion
================================ EOPN
Python Program to Reverse a Stack using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements to push: 7 3 1 5
The stack:
5
1
3
7
After reversing:
7
3
1
5

Case 2:
Please enter the elements to push: 3
The stack:
3
After reversing:
3

Case 3:
Please enter the elements to push: 1 2
The stack:
2
1
After reversing:
1
2
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def display(self):
        for data in reversed(self.items):
            print(data)

def insert_at_bottom(s, data):
    if s.is_empty():
        s.push(data)
    else:
        popped = s.pop()
        insert_at_bottom(s, data)
        s.push(popped)


def reverse_stack(s):
    if not s.is_empty():
        popped = s.pop()
        reverse_stack(s)
        insert_at_bottom(s, popped)


s = Stack()
data_list = input('Please enter the elements to push: ').split()
for data in data_list:
    s.push(int(data))

print('The stack:')
s.display()
reverse_stack(s)
print('After reversing:')
s.display()
 ETP  
 
Python Program to Implement Stack using One Queue
================================ EOPN
Python Program to Implement Stack using One Queue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? push 3
What would you like to do? push 5
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.q = Queue()

    def is_empty(self):
        return self.q.is_empty()

    def push(self, data):
        self.q.enqueue(data)

    def pop(self):
        for _ in range(self.q.get_size() - 1):
            dequeued = self.q.dequeue()
            self.q.enqueue(dequeued)
        return self.q.dequeue()


class Queue:
    def __init__(self):
        self.items = []
        self.size = 0

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.size += 1
        self.items.append(data)

    def dequeue(self):
        self.size -= 1
        return self.items.pop(0)

    def get_size(self):
        return self.size


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Stack Using Two Queues
================================ EOPN
Python Program to Implement Stack Using Two Queues
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? pop
Popped value:  2
What would you like to do? quit

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 5
What would you like to do? push 0
What would you like to do? pop
Popped value:  0
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def is_empty(self):
        return self.queue2.is_empty()

    def push(self, data):
        self.queue1.enqueue(data)
        while not self.queue2.is_empty():
            x = self.queue2.dequeue()
            self.queue1.enqueue(x)
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        return self.queue2.dequeue()

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue
================================ EOPN
Python Program to Implement Queue
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  1
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


q = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        q.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if q.is_empty():
            print('Queue is empty.')
        else:
            print('Dequeued value: ', q.dequeue())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dequeue
================================ EOPN
Python Program to Implement Dequeue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 3
What would you like to do? append 4
What would you like to do? appendleft 2
What would you like to do? appendleft 1
What would you like to do? pop
Popped value from right:  4
What would you like to do? popleft
Popped value from left:  1
What would you like to do? pop
Popped value from right:  3
What would you like to do? popleft
Popped value from left:  2
What would you like to do? pop
Dequeue is empty.
What would you like to do? quit

Case 2:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? pop
Popped value from right:  2
What would you like to do? pop
Popped value from right:  1
What would you like to do? appendleft 1
What would you like to do? appendleft 2
What would you like to do? pop
Popped value from right:  1
What would you like to do? pop
Popped value from right:  2
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? popleft
Popped value from left:  1
What would you like to do? popleft
Popped value from left:  2
What would you like to do? quit
--------------------------------
class Dequeue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def append(self, data):
        self.items.append(data)

    def append_left(self, data):
        self.items.insert(0, data)

    def pop(self):
        return self.items.pop()

    def pop_left(self):
        return self.items.pop(0)


q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queues using Stacks
================================ EOPN
Python Program to Implement Queues using Stacks
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? enqueue 8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 2
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  1
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.inbox = Stack()
        self.outbox = Stack()

    def is_empty(self):
        return (self.inbox.is_empty() and self.outbox.is_empty())

    def enqueue(self, data):
        self.inbox.push(data)

    def dequeue(self):
        if self.outbox.is_empty():
            while not self.inbox.is_empty():
                popped = self.inbox.pop()
                self.outbox.push(popped)
        return self.outbox.pop()


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if a_queue.is_empty():
            print('Queue is empty.')
        else:
            dequeued = a_queue.dequeue()
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check String is Palindrome using Stack
================================ EOPN
Python Program to Check String is Palindrome using Stack
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the string: madam
The string is a palindrome.

Case 2:
Please enter the string: racecar
The string is a palindrome.

Case 3:
Please enter the string: palace
The string is not a palindrome.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
text = input('Please enter the string: ')

for character in text:
    s.push(character)

reversed_text = ''
while not s.is_empty():
    reversed_text = reversed_text + s.pop()

if text == reversed_text:
    print('The string is a palindrome.')
else:
    print('The string is not a palindrome.')
 ETP  
 
Python Program to Check if Expression is correctly Parenthesized
================================ EOPN
Python Program to Check if Expression is correctly Parenthesized
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the expression: (3 + 4 * (1 + (2))/(7 * (8 + 9)))
Expression is correctly parenthesized.

Case 2:
Please enter the expression: (a + b))(3)
Expression is not correctly parenthesized.

Case 3:
Please enter the expression: (4 + (3 * 2)
Expression is not correctly parenthesized.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
exp = input('Please enter the expression: ')

for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False

if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')
 ETP  
 
Python Program to Implement Linear Search
================================ EOPN
Python Program to Implement Linear Search
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 4 3 2 1 10 11 2
The number to search for: 1
1 was found at index 4.

Case 2:
Enter the list of numbers: 5 2 1 5 -3
The number to search for: 2
2 was found at index 1.

Case 3:
Enter the list of numbers: 3 5 6
The number to search for: 2
2 was not found.
--------------------------------
def linear_search(alist, key):
    """Return index of key in alist. Return -1 if key not present."""
    for i in range(len(alist)):
        if alist[i] == key:
            return i
    return -1


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = linear_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search without Recursion
================================ EOPN
Python Program to Implement Binary Search without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 3 5 10 12 15 20
The number to search for: 12
12 was found at index 3.

Case 2:
Enter the sorted list of numbers: -3 0 1 5 6 7 8
The number to search for: 2
2 was not found.

Case 3:
Enter the sorted list of numbers: 5
The number to search for: 5
5 was found at index 0.
--------------------------------
def binary_search(alist, key):
    """Search key in alist[start... end - 1]."""
    start = 0
    end = len(alist)
    while start < end:
        mid = (start + end)//2
        if alist[mid] > key:
            end = mid
        elif alist[mid] < key:
            start = mid + 1
        else:
            return mid
    return -1


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search with Recursion
================================ EOPN
Python Program to Implement Binary Search with Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 4 5 6 7 8 9 10
The number to search for: 9
9 was found at index 5.

Case 2:
Enter the sorted list of numbers: 3 4 5 10
The number to search for: 8
8 was not found.

Case 3:
Enter the sorted list of numbers: 7
The number to search for: 7
7 was found at index 0.
--------------------------------
def binary_search(alist, start, end, key):
    """Search key in alist[start... end - 1]."""
    if not start < end:
        return -1

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, mid + 1, end, key)
    elif alist[mid] > key:
        return binary_search(alist, start, mid, key)
    else:
        return mid


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, 0, len(alist), key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 10 2 -1 0 2
The ith smallest element will be found. Enter i: 2
Result: 0.

Case 2:
Enter the list of numbers: 7
The ith smallest element will be found. Enter i: 1
Result: 7.

Case 3:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 5.
--------------------------------
def select(alist, start, end, i):
    """Find ith smallest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[start... pivot]
    k = pivot - start + 1

    if i < k:
        return select(alist, start, pivot, i)
    elif i > k:
        return select(alist, pivot + 1, end, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 10 7 2 -2
The ith smallest element will be found. Enter i: 2
Result: 7.

Case 2:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 1.

Case 3:
Enter the list of numbers: 3
The ith smallest element will be found. Enter i: 1
Result: 3.
--------------------------------
def select(alist, start, end, i):
    """Find ith largest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[pivot... end - 1]
    k = end - pivot

    if i < k:
        return select(alist, pivot + 1, end, i)
    elif i > k:
        return select(alist, start, pivot, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Implement Bubble Sort 
================================ EOPN
Python Program to Implement Bubble Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 38 10 5
Sorted list: [2, 4, 5, 10, 38]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7 3 1 -5 2 10
Sorted list: [-5, 1, 2, 3, 7, 10]
--------------------------------
def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Selection Sort
================================ EOPN
Python Program to Implement Selection Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 4 5 2 6
Sorted list: [1, 2, 3, 4, 5, 6]

Case 2:
Enter the list of numbers: 2 10 5 38 1 7
Sorted list: [1, 2, 5, 7, 10, 38]

Case 3:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]
--------------------------------
def selection_sort(alist):
    for i in range(0, len(alist) - 1):
        smallest = i
        for j in range(i + 1, len(alist)):
            if alist[j] < alist[smallest]:
                smallest = j
        alist[i], alist[smallest] = alist[smallest], alist[i]


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
selection_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Insertion Sort
================================ EOPN
Python Program to Implement Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 4 1 5 8 0
Sorted list: [0, 1, 2, 4, 5, 8]

Case 2:
Enter the list of numbers: 5 4 3 2 0 -1
Sorted list: [-1, 0, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3 4 1 4 5 0 7
Sorted list: [0, 1, 3, 4, 4, 5, 7]
--------------------------------
def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Merge Sort
================================ EOPN
Python Program to Implement Merge Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 8 2 5 1 3
Sorted list: [1, 1, 2, 3, 3, 5, 5, 8]

Case 2:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)

def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Quicksort
================================ EOPN
Python Program to Implement Quicksort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 8 10 3 0 4
Sorted list: [0, 2, 3, 4, 5, 8, 10]

Case 2:
Enter the list of numbers: 7 4 3 2 1
Sorted list: [1, 2, 3, 4, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def quicksort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        p = partition(alist, start, end)
        quicksort(alist, start, p)
        quicksort(alist, p + 1, end)


def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
quicksort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Heapsort
================================ EOPN
Python Program to Implement Heapsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 2 2 1 0 -2 5 7
Sorted list: [-2, 0, 1, 2, 2, 3, 5, 7]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def heapsort(alist):
    build_max_heap(alist)
    for i in range(len(alist) - 1, 0, -1):
        alist[0], alist[i] = alist[i], alist[0]
        max_heapify(alist, index=0, size=i)

def parent(i):
    return (i - 1)//2

def left(i):
    return 2*i + 1

def right(i):
    return 2*i + 2

def build_max_heap(alist):
    length = len(alist)
    start = parent(length - 1)
    while start >= 0:
        max_heapify(alist, index=start, size=length)
        start = start - 1

def max_heapify(alist, index, size):
    l = left(index)
    r = right(index)
    if (l < size and alist[l] > alist[index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[r] > alist[largest]):
        largest = r
    if (largest != index):
        alist[largest], alist[index] = alist[index], alist[largest]
        max_heapify(alist, largest, size)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
heapsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Counting Sort
================================ EOPN
Python Program to Implement Counting Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 4 1 3 6 1 8
Sorted list: [1, 1, 1, 2, 3, 4, 6, 8]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 4 3 2
Sorted list: [2, 3, 4, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 1
Sorted list: [1]
--------------------------------
def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)

    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1

    return result


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
 Python Program to Implement Radix Sort 
================================ EOPN
 Python Program to Implement Radix Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 38 20 1 3 4 0 2 5 1 3 8 2 9 10
Sorted list: [0, 1, 1, 2, 2, 3, 3, 4, 5, 8, 9, 10, 20, 38]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 3
Sorted list: [3]
--------------------------------
def radix_sort(alist, base=10):
    if alist == []:
        return

    def key_factory(digit, base):
        def key(alist, index):
            return ((alist[index]//(base**digit)) % base)
        return key
    largest = max(alist)
    exp = 0
    while base**exp <= largest:
        alist = counting_sort(alist, base - 1, key_factory(exp, base))
        exp = exp + 1
    return alist

def counting_sort(alist, largest, key):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[key(alist, i)] = c[key(alist, i)] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)
    for i in range(len(alist) - 1, -1, -1):
        result[c[key(alist, i)]] = alist[i]
        c[key(alist, i)] = c[key(alist, i)] - 1

    return result

alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = radix_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Bucket Sort
================================ EOPN
Python Program to Implement Bucket Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 5 10 3 5 7
Sorted list: [1, 2, 3, 5, 5, 7, 10]

Case 2:
Enter the list of (nonnegative) numbers: 8 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7, 8]

Case 3:
Enter the list of (nonnegative) numbers: 5
Sorted list: [5]
--------------------------------
def bucket_sort(alist):
    largest = max(alist)
    length = len(alist)
    size = largest/length

    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(alist[i]/size)
        if j != length:
            buckets[j].append(alist[i])
        else:
            buckets[length - 1].append(alist[i])

    for i in range(length):
        insertion_sort(buckets[i])

    result = []
    for i in range(length):
        result = result + buckets[i]

    return result

def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = bucket_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Gnome Sort
================================ EOPN
Python Program to Implement Gnome Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 3 2 51 38 1 10 3 0 7 8
Sorted list: [0, 1, 2, 2, 3, 3, 7, 8, 10, 38, 51]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7
Sorted list: [7]
--------------------------------
def gnome_sort(alist):
    for pos in range(1, len(alist)):
        while (pos != 0 and alist[pos] < alist[pos - 1]):
            alist[pos], alist[pos - 1] = alist[pos - 1], alist[pos]
            pos = pos - 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
gnome_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Cocktail Shaker Sort
================================ EOPN
Python Program to Implement Cocktail Shaker Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 18 5 2 10 0 7 4
Sorted list: [0, 2, 3, 4, 5, 7, 10, 18]

Case 2:
Enter the list of numbers: 6 5 4 3 2
Sorted list: [2, 3, 4, 5, 6]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def cocktail_shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    upper = len(alist) - 1
    lower = 0

    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1

        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
cocktail_shaker_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Comb Sort
================================ EOPN
Python Program to Implement Comb Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 8 4 3 7 10 23 4 5
Sorted list: [2, 3, 4, 4, 5, 7, 8, 10, 23]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3
Sorted list: [3]
--------------------------------
def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    gap = len(alist)
    shrink = 1.3

    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)

        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False

        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Shell Sort
================================ EOPN
Python Program to Implement Shell Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 3 1 10
Sorted list: [1, 2, 3, 5, 10]

Case 2:
Enter the list of numbers: 7 6 5 4
Sorted list: [4, 5, 6, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def gaps(size):
    # uses the gap sequence 2^k - 1: 1, 3, 7, 15, 31, ...
    length = size.bit_length()
    for k in range(length - 1, 0, -1):
        yield 2**k - 1


def shell_sort(alist):
    def insertion_sort_with_gap(gap):
        for i in range(gap, len(alist)):
            temp = alist[i]
            j = i - gap
            while (j >= 0 and temp < alist[j]):
                alist[j + gap] = alist[j]
                j = j - gap
            alist[j + gap] = temp

    for g in gaps(len(alist)):
        insertion_sort_with_gap(g)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
shell_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Introsort
================================ EOPN
Python Program to Implement Introsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 2 3 10 9 3 7 2 1 0 9
Sorted list: [0, 1, 2, 2, 3, 3, 3, 5, 7, 9, 9, 10]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 5
Sorted list: [5]
--------------------------------
def introsort(alist):
    maxdepth = (len(alist).bit_length() - 1)*2
    introsort_helper(alist, 0, len(alist), maxdepth)

def introsort_helper(alist, start, end, maxdepth):
    if end - start <= 1:
        return
    elif maxdepth == 0:
        heapsort(alist, start, end)
    else:
        p = partition(alist, start, end)
        introsort_helper(alist, start, p + 1, maxdepth - 1)
        introsort_helper(alist, p + 1, end, maxdepth - 1)

def partition(alist, start, end):
    pivot = alist[start]
    i = start - 1
    j = end

    while True:
        i = i + 1
        while alist[i] < pivot:
            i = i + 1
        j = j - 1
        while alist[j] > pivot:
            j = j - 1

        if i >= j:
            return j

        swap(alist, i, j)

def swap(alist, i, j):
    alist[i], alist[j] = alist[j], alist[i]

def heapsort(alist, start, end):
    build_max_heap(alist, start, end)
    for i in range(end - 1, start, -1):
        swap(alist, start, i)
        max_heapify(alist, index=0, start=start, end=i)

def build_max_heap(alist, start, end):
    def parent(i):
        return (i - 1)//2
    length = end - start
    index = parent(length - 1)
    while index >= 0:
        max_heapify(alist, index, start, end)
        index = index - 1

def max_heapify(alist, index, start, end):
    def left(i):
        return 2*i + 1
    def right(i):
        return 2*i + 2

    size = end - start
    l = left(index)
    r = right(index)
    if (l < size and alist[start + l] > alist[start + index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[start + r] > alist[start + largest]):
        largest = r
    if largest != index:
        swap(alist, start + largest, start + index)
        max_heapify(alist, largest, start, end)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
introsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Binary Insertion Sort
================================ EOPN
Python Program to Implement Binary Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 7 10 3 5 2 1 8 9
Sorted list: [1, 2, 2, 3, 5, 5, 7, 8, 9, 10]

Case 2:
Enter the list of numbers: 7 5 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5, 5, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def binary_insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        pos = binary_search(alist, temp, 0, i) + 1

        for k in range(i, pos, -1):
            alist[k] = alist[k - 1]

        alist[pos] = temp

def binary_search(alist, key, start, end):
    '''If key is in the list at index p, then return p.
    If there are multiple such keys in the list, then return the index of any one.
    If key is not in the list and a < key < b where a and b are elements in the list, then return the index of a.
    If key is not in the list and key < a where a is the first element in the list, then return -1.
    Only elements with indexes start to end - 1 inclusive are considered.
    '''
    if end - start <= 1:
        if key < alist[start]:
            return start - 1
        else:
            return start

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, key, mid, end)
    elif alist[mid] > key:
        return binary_search(alist, key, start, mid)
    else:
        return mid


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
binary_insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Sort using a Binary Search Tree
================================ EOPN
Python Program to Sort using a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 3 4 5 6 1 7 9 10 3
Sorted list: 1 2 3 3 4 4 5 6 7 9 10 

Case 2:
Enter the list of numbers: 6 5 4 3 2 1
Sorted list: 1 2 3 4 5 6 

Case 3:
Enter the list of numbers: 5
Sorted list: 5
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key <= node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)


bstree = BSTree()

alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
for x in alist:
    bstree.add(x)
print('Sorted list: ', end='')
bstree.inorder()
 ETP  
 
Python Program for Depth First Binary Tree Search using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 5
What would you like to do? insert 7 right of 5
What would you like to do? dfs
depth-first search traversal:
entering 1...
entering 2...
entering 4...
at 4...
leaving 4...
at 2...
entering 5...
entering 6...
at 6...
leaving 6...
at 5...
entering 7...
at 7...
leaving 7...
leaving 5...
leaving 2...
at 1...
entering 3...
at 3...
leaving 3...
leaving 1...

What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 4 left of 3
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 4
What would you like to do? dfs
depth-first search traversal:
entering 3...
entering 4...
entering 6...
at 6...
leaving 6...
at 4...
leaving 4...
at 3...
entering 5...
at 5...
leaving 5...
leaving 3...

What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def depth_first(self):
        print('entering {}...'.format(self.key))
        if self.left is not None:
            self.left.depth_first()
        print('at {}...'.format(self.key))
        if self.right is not None:
            self.right.depth_first()
        print('leaving {}...'.format(self.key))


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('depth-first search traversal:')
        if btree is not None:
            btree.depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? dfs
pre-order dfs traversal: 1 2 4 5 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? insert 8 left of 7
What would you like to do? insert 10 right of 7
What would you like to do? dfs
pre-order dfs traversal: 3 6 7 8 10 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def preorder_depth_first(self):
        s = Stack()
        s.push(self)
        while (not s.is_empty()):
            node = s.pop()
            print(node.key, end=' ')
            if node.right is not None:
                s.push(node.right)
            if node.left is not None:
                s.push(node.left)


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


btree = BinaryTree()

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('pre-order dfs traversal: ', end='')
        if btree is not None:
            btree.preorder_depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOPN
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? inorder 1
nth term of inorder traversal: 2
What would you like to do? inorder 2
nth term of inorder traversal: 1
What would you like to do? inorder 3
nth term of inorder traversal: 3
What would you like to do? inorder 4
index exceeds maximum possible index.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 3 left of 1
What would you like to do? insert 7 right of 1
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 5
What would you like to do? inorder 1
nth term of inorder traversal: 3
What would you like to do? inorder 2
nth term of inorder traversal: 6
What would you like to do? inorder 3
nth term of inorder traversal: 5
What would you like to do? inorder 4
nth term of inorder traversal: 1
What would you like to do? inorder 5
nth term of inorder traversal: 7
What would you like to do? inorder 6
index exceeds maximum possible index.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_nth(self, n):
        return self.inorder_nth_helper(n, [])

    def inorder_nth_helper(self, n, inord):
        if self.left is not None:
            temp = self.left.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp
        inord.append(self)
        if n == len(inord):
            return self
        if self.right is not None:
            temp = self.right.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('inorder <index>')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'inorder':
        if btree is not None:
            index = int(do[1].strip().lower())
            node = btree.inorder_nth(index)
            if node is not None:
                print('nth term of inorder traversal: {}'.format(node.key))
            else:
                print('index exceeds maximum possible index.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOPN
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 1 at rot
What would you like to do? largest
Largest element: 1
What would you like to do? insert 2 left of 1
What would you like to do? largest
Largest element: 2
What would you like to do? insert 3 right of 1
What would you like to do? largest
Largest element: 3
What would you like to do? insert 10 left of 3
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 3 at root
What would you like to do? insert 5 left of 3
What would you like to do? insert 2 right of 3
What would you like to do? largest
Largest element: 5
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_largest(self):
        # largest will be a single element list
        # this is a workaround to reference an integer
        largest = []
        self.inorder_largest_helper(largest)
        return largest[0]

    def inorder_largest_helper(self, largest):
        if self.left is not None:
            self.left.inorder_largest_helper(largest)
        if largest == []:
            largest.append(self.key)
        elif largest[0] < self.key:
            largest[0] = self.key
        if self.right is not None:
            self.right.inorder_largest_helper(largest)

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'largest':
        if btree is None:
            print('Tree is empty.')
        else:
            print('Largest element: {}'.format(btree.inorder_largest()))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOPN
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 2
What would you like to do? add 5 below 1
What would you like to do? add 6 below 1
What would you like to do? dfs
Post-order traversal: 3 4 2 5 6 1 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 3 at root
What would you like to do? add 5 below 3
What would you like to do? add 2 below 3
What would you like to do? add 1 below 5
What would you like to do? add 6 below 5
What would you like to do? dfs
Post-order traversal: 1 6 5 2 3 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def postorder(self):
        for child in self.children:
            child.postorder()
        print(self.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'dfs':
        print('Post-order traversal: ', end='')
        tree.postorder()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOPN
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 left of 3
What would you like to do? insert 6 right of 3
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 4 5 6 
BFS traversal of mirror: 
1 3 2 6 5 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 
BFS traversal of mirror: 
1 
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 
BFS traversal of mirror: 
1 3 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def mirror_copy(self):
        mirror = BinaryTree(self.key)
        if self.right is not None:
            mirror.left = self.right.mirror_copy()
        if self.left is not None:
            mirror.right = self.left.mirror_copy()
        return mirror

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            if popped.left is not None:
                queue.append(popped.left)
            if popped.right is not None:
                queue.append(popped.right)
            print(popped.key, end=' ')


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('mirror')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'mirror':
        if btree is not None:
            print('Creating mirror copy...')
            mirror = btree.mirror_copy()
            print('BFS traversal of original tree: ')
            btree.bfs()
            print()
            print('BFS traversal of mirror: ')
            mirror.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOPN
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOKW
--------------------------------
output:
Case 1:
Input post-order traversal: 4 5 2 8 6 7 3 1
Input in-order traversal: 4 2 5 1 6 8 3 7
Binary tree constructed.
Verifying:
Post-order traversal: 4 5 2 8 6 7 3 1 
In-order traversal: 4 2 5 1 6 8 3 7 

Case 2:
Input post-order traversal: 2 1 3
Input in-order traversal: 2 3 1
Binary tree constructed.
Verifying:
Post-order traversal: 2 1 3 
In-order traversal: 2 3 1
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def postorder(self):
        if self.left is not None:
            self.left.postorder()
        if self.right is not None:
            self.right.postorder()
        print(self.key, end=' ')


def construct_btree(postord, inord):
    if postord == [] or inord == []:
        return None
    key = postord[-1]
    node = BinaryTree(key)
    index = inord.index(key)
    node.left = construct_btree(postord[:index], inord[:index])
    node.right = construct_btree(postord[index:-1], inord[index + 1:])
    return node


postord = input('Input post-order traversal: ').split()
postord = [int(x) for x in postord]
inord = input('Input in-order traversal: ').split()
inord = [int(x) for x in inord]

btree = construct_btree(postord, inord)
print('Binary tree constructed.')
print('Verifying:')
print('Post-order traversal: ', end='')
btree.postorder()
print()
print('In-order traversal: ', end='')
btree.inorder()
print()
 ETP  
 
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOPN
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 5
What would you like to do? add 1
What would you like to do? add 10
What would you like to do? add 7
What would you like to do? add 3
What would you like to do? inorder
Inorder traversal: 1 3 5 7 10 
What would you like to do? remove 3
What would you like to do? remove 7
What would you like to do? inorder
Inorder traversal: 1 5 10 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 1 10 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 2
What would you like to do? add 8
What would you like to do? inorder
Inorder traversal: 2 8 
What would you like to do? add 5
What would you like to do? inorder
Inorder traversal: 2 5 8 
What would you like to do? remove 2
What would you like to do? remove 8
What would you like to do? inorder
Inorder traversal: 5 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def replace_node_of_parent(self, new_node):
        if self.parent is not None:
            if new_node is not None:
                new_node.parent = self.parent
            if self.parent.left == self:
                self.parent.left = new_node
            elif self.parent.right == self:
                self.parent.right = new_node
        else:
            self.key = new_node.key
            self.left = new_node.left
            self.right = new_node.right
            if new_node.left is not None:
                new_node.left.parent = self
            if new_node.right is not None:
                new_node.right.parent = self

    def find_min(self):
        current = self
        while current.left is not None:
            current = current.left
        return current

    def remove(self):
        if (self.left is not None and self.right is not None):
            successor = self.right.find_min()
            self.key = successor.key
            successor.remove()
        elif self.left is not None:
            self.replace_node_of_parent(self.left)
        elif self.right is not None:
            self.replace_node_of_parent(self.right)
        else:
            self.replace_node_of_parent(None)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def remove(self, key):
        to_remove = self.search(key)
        if (self.root == to_remove
            and self.root.left is None and self.root.right is None):
            self.root = None
        else:
            to_remove.remove()

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('remove <key>')
print('inorder')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    elif operation == 'remove':
        key = int(do[1])
        bstree.remove(key)
    elif operation == 'inorder':
        print('Inorder traversal: ', end='')
        bstree.inorder()
        print()
    elif operation == 'quit':
        break
 ETP  
 
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOPN
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 3
What would you like to do? add 2
What would you like to do? add 10
What would you like to do? add 4
What would you like to do? smallest
Smallest element: 2
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 10
What would you like to do? smallest
Smallest element: 10
What would you like to do? largest
Largest element: 10
What would you like to do? add 4
What would you like to do? add 12
What would you like to do? smallest
Smallest element: 4
What would you like to do? largest
Largest element: 12
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)

    def get_smallest(self):
        if self.root is not None:
            current = self.root
            while current.left is not None:
                current = current.left
            return current.key

    def get_largest(self):
        if self.root is not None:
            current = self.root
            while current.right is not None:
                current = current.right
            return current.key


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('smallest')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    if operation == 'smallest':
        smallest = bstree.get_smallest()
        print('Smallest element: {}'.format(smallest))
    if operation == 'largest':
        largest = bstree.get_largest()
        print('Largest element: {}'.format(largest))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Leaf Node in a Tree
================================ EOPN
Python Program to Count Number of Leaf Node in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of leaf nodes: 2
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 2 at root
What would you like to do? add 7 below 2
What would you like to do? add 8 below 7
What would you like to do? add 9 below 8
What would you like to do? count
Number of leaf nodes: 1
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_leaf_nodes(self):
        leaf_nodes = []
        self.count_leaf_nodes_helper(leaf_nodes)
        return len(leaf_nodes)

    def count_leaf_nodes_helper(self, leaf_nodes):
        if self.children == []:
            leaf_nodes.append(self)
        else:
            for child in self.children:
                child.count_leaf_nodes_helper(leaf_nodes)


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_leaf_nodes()
            print('Number of leaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 right of 2
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? count
Number of nodes in tree: 4
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? count
Number of nodes in tree: 0
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? count
Number of nodes in tree: 1
inorder traversal of binary tree: 1 
What would you like to do? insert 2 right of 1
inorder traversal of binary tree: 1 2 
What would you like to do? count
Number of nodes in tree: 2
inorder traversal of binary tree: 1 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def count_nodes(node):
    if node is None:
        return 0
    return 1 + count_nodes(node.left) + count_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('count')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'count':
        print('Number of nodes in tree: {}'.format(count_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOPN
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? border
Border of tree: 
1 2 3 
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? border
Border of tree: 
1 2 4 5 6 7 3 
What would you like to do? insert 8 left of 4
What would you like to do? insert 9 right of 4
What would you like to do? insert 10 left of 5
What would you like to do? insert 11 right of 5
What would you like to do? insert 12 left of 6
What would you like to do? insert 13 right of 6
What would you like to do? insert 14 left of 7
What would you like to do? insert 15 right of 7
What would you like to do? border
Border of tree: 
1 2 4 8 9 10 11 12 13 14 15 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 left of 2
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? insert 6 right of 4
What would you like to do? insert 7 right of 1
What would you like to do? insert 8 right of 7
What would you like to do? border
Border of tree: 
1 2 3 5 6 8 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left_boundary(self):
        current = self
        while True:
            if current.left is not None:
                print(current.key, end=' ')
                current = current.left
            elif current.right is not None:
                print(current.key, end=' ')
                current = current.right
            else:
                break

    def print_right_boundary(self):
        if self.right is not None:
            self.right.print_right_boundary()
            print(self.key, end=' ')
        elif self.left is not None:
            self.left.print_right_boundary()
            print(self.key, end=' ')


    def print_leaves(self):
        if self.left is not None:
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
        if (self.left is None
            and self.right is None):
            print(self.key, end=' ')

    def print_border(self):
        print(self.key, end=' ')
        if self.left is not None:
            self.left.print_left_boundary()
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
            self.right.print_right_boundary()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('border')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'border':
        if btree is not None:
            print('Border of tree: ')
            btree.print_border()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Read a Linked List in Reverse
================================ EOPN
Python Program to Read a Linked List in Reverse
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 5
Enter data item: 3
Enter data item: 10
Enter data item: 2
The linked list: 2 10 3 5 

Case 2:
How many elements would you like to add? 1
Enter data item: 8
The linked list: 8 

Case 3:
How many elements would you like to add? 3
Enter data item: 1
Enter data item: 2
Enter data item: 3
The linked list: 3 2 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    node = Node(data)
    a_llist.insert_at_beg(node)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Create a Linked List & Display the Elements in the List
================================ EOPN
Python Program to Create a Linked List & Display the Elements in the List
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: -2
Enter data item: 1
Enter data item: 5
Enter data item: 0
The linked list: 3 -2 1 5 0 

Case 2:
How many elements would you like to add? 1
Enter data item: 6
The linked list: 6 

Case 3:
How many elements would you like to add? 4
Enter data item: 2
Enter data item: 9
Enter data item: 3
Enter data item: 2
The linked list: 2 9 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Search for an Element in the Linked List using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 5
5 is at index 1.

Case 2:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 7
7 is at index 4.

Case 3:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 4
4 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        return self.find_index_helper(key, 0, self.head)

    def find_index_helper(self, key, start, node):
        if node is None:
            return -1

        if node.data == key:
            return start
        else:
            return self.find_index_helper(key, start + 1, node.next)

a_llist = LinkedList()
for data in [3, 5, 0, 10, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 9
9 is at index 4.

Case 2:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 11
11 is at index 5.

Case 3:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 3
3 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        current = self.head

        index = 0
        while current:
            if current.data == key:
                return index
            current = current.next
            index = index + 1

        return -1

a_llist = LinkedList()
for data in [4, -3, 1, 0, 9, 11]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: 8
Enter data item: 14
Enter data item: 2
Enter data item: 1
The reversed linked list: 1 2 14 8 3 

Case 2:
How many elements would you like to add? 1
Enter data item: 3
The reversed linked list: 3 

Case 3:
How many elements would you like to add? 2
Enter data item: 0
Enter data item: 1
The reversed linked list: 1 0
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        self.display_reversed_helper(self.head)

    def display_reversed_helper(self, current):
        if current is None:
            return

        self.display_reversed_helper(current.next)
        print(current.data, end = ' ')

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOPN
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? count
Number of nonleaf nodes: 0
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of nonleaf nodes: 1
What would you like to do? add 4 below 2
What would you like to do? count
Number of nonleaf nodes: 2
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 3
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 3
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 6 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 7 below 6
What would you like to do? count
Number of nonleaf nodes: 5
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_nonleaf_nodes(self):
        nonleaf_count = 0
        if self.children != []:
            nonleaf_count = 1
        for child in self.children:
            nonleaf_count = nonleaf_count + child.count_nonleaf_nodes()
        return nonleaf_count


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_nonleaf_nodes()
            print('Number of nonleaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of all Nodes in a Tree
================================ EOPN
Python Program to Find the Sum of all Nodes in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? sum
Tree is empty.
What would you like to do? add 3 at root
What would you like to do? sum
Sum of all nodes: 3
What would you like to do? add 4 below 3
What would you like to do? sum
Sum of all nodes: 7
What would you like to do? add 5 below 3
What would you like to do? add 10 below 4
What would you like to do? sum
Sum of all nodes: 22
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 1
What would you like to do? add 5 below 2
What would you like to do? add 6 below 3
What would you like to do? add 7 below 4
What would you like to do? sum
Sum of all nodes: 28
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def sum_nodes(self):
        summation = self.key
        for child in self.children:
            summation = summation + child.sum_nodes()
        return summation


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('sum')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'sum':
        if tree is None:
            print('Tree is empty.')
        else:
            summation = tree.sum_nodes()
            print('Sum of all nodes: {}'.format(summation))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOPN
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 2
What would you like to do? add 5 below 2
What would you like to do? display
BFS traversal display: 1 2 3 4 5 
What would you like to do? remove 1
What would you like to do? display
BFS traversal display: 4 2 3 5 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 4 2 3 
What would you like to do? remove 4
What would you like to do? display
BFS traversal display: 2 3 
What would you like to do? remove 3
What would you like to do? remove 2
What would you like to do? display
Tree is empty.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 9 below 7
What would you like to do? add 11 below 9
What would you like to do? add 12 below 7
What would you like to do? display
BFS traversal display: 5 7 9 12 11 
What would you like to do? remove 9
What would you like to do? display
BFS traversal display: 5 7 11 12 
What would you like to do? remove 12
What would you like to do? display
BFS traversal display: 5 7 11 
What would you like to do? remove 7
What would you like to do? display
BFS traversal display: 5 11 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 11 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None, parent=None):
        self.key = data
        self.children = []
        self.parent = parent

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def remove(self):
        parent = self.parent
        index = parent.children.index(self)
        parent.children.remove(self)
        for child in reversed(self.children):
            parent.children.insert(index, child)
            child.parent = parent

    def bfs_display(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('remove <data>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            new_node.parent = ref_node
            ref_node.add(new_node)

    elif operation == 'remove':
        data = int(do[1])
        to_remove = tree.search(data)
        if tree == to_remove:
            if tree.children == []:
                tree = None
            else:
                leaf = tree.children[0]
                while leaf.children != []:
                    leaf = leaf.children[0]
                leaf.parent.children.remove(leaf)
                leaf.parent = None
                leaf.children = tree.children
                tree = leaf
        else:
            to_remove.remove()

    elif operation == 'display':
        if tree is not None:
            print('BFS traversal display: ', end='')
            tree.bfs_display()
            print()
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 3
Enter data item: 7
Enter data item: 2
Enter data item: 1
The linked list: 7 2 1 

Case 2:
How many elements would you like to add? 1
Enter data item: 2
The linked list: 2 

Case 3:
How many elements would you like to add? 5
Enter data item: 4
Enter data item: 2
Enter data item: 3
Enter data item: 5
Enter data item: 1
The linked list: 4 2 3 5 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        self.display_helper(self.head)

    def display_helper(self, current):
        if current is None:
            return

        print(current.data, end = ' ')
        self.display_helper(current.next)

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOPN
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 7
Enter data item: 2
Enter data item: 1
Enter data item: 9
The reversed linked list: 9 1 2 7 

Case 2:
How many elements would you like to add? 1
Enter data item: 5
The reversed linked list: 5 

Case 3:
How many elements would you like to add? 2
Enter data item: 3
Enter data item: 1
The reversed linked list: 1 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        end_node = None

        while end_node != self.head:
            current = self.head
            while current.next != end_node:
                current = current.next
            print(current.data, end = ' ')
            end_node = current

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Find the Length of the Linked List using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 4 10
The length of the linked list is 3.

Case 2:
Please enter the elements in the linked list: 7
The length of the linked list is 1.

Case 3:
Please enter the elements in the linked list: 3 4 1 -1 3 9
The length of the linked list is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        return self.length_helper(self.head)

    def length_helper(self, current):
        if current is None:
            return 0
        return 1 + self.length_helper(current.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Find the Length of the Linked List without using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 8 1
The length of the linked list is 2.

Case 2:
Please enter the elements in the linked list: 
The length of the linked list is 0.

Case 3:
Please enter the elements in the linked list: 7 5 9 12
The length of the linked list is 4.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        current = self.head
        length = 0
        while current:
            length = length + 1
            current = current.next
        return length

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 3
3 occurs 2 time(s) in the list.

Case 2:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 7
7 occurs 4 time(s) in the list.

Case 3:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 2
2 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        return self.count_helper(self.head, key)

    def count_helper(self, current, key):
        if current is None:
            return 0

        if current.data == key:
            return 1 + self.count_helper(current.next, key)
        else:
            return self.count_helper(current.next, key)

a_llist = LinkedList()
for data in [7, 3, 7, 4, 7, 11, 4, 0, 3, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOPN
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 1 at root
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 0 left of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 2 right of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 3 left of 2
What would you like to do? bst
Tree is not a binary search tree.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 5 at root
What would you like to do? insert 1 left of 5
What would you like to do? insert 10 right of 5
What would you like to do? insert 0 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 15 right of 10
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def is_bst_p(self):
        if self.left is not None:
            if self.key < self.left.key:
                return False
            elif not self.left.is_bst_p():
                return False
        if self.right is not None:
            if self.key > self.right.key:
                return False
            elif not self.right.is_bst_p():
                return False
        return True


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('bst')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'bst':
        if btree is not None:
            if btree.is_bst_p():
                print('Tree is a binary search tree.')
            else:
                print('Tree is not a binary search tree.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOPN
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? paths
Tree is empty.
What would you like to do? add 1 at root
What would you like to do? paths
1 
What would you like to do? add 2 below 1
What would you like to do? paths
1 2 
What would you like to do? add 3 below 1
What would you like to do? paths
1 2 
1 3 
What would you like to do? add 4 below 1
What would you like to do? paths
1 2 
1 3 
1 4 
What would you like to do? add 8 below 2
What would you like to do? paths
1 2 8 
1 3 
1 4 
What would you like to do? add 7 below 2
What would you like to do? paths
1 2 8 
1 2 7 
1 3 
1 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? add 1 at root
What would you like to do? add 10 below 1
What would you like to do? add 11 below 10
What would you like to do? add 12 below 11
What would you like to do? add 20 below 1
What would you like to do? add 21 below 20
What would you like to do? add 30 below 1
What would you like to do? paths
1 10 11 12 
1 20 21 
1 30 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def print_all_paths_to_leaf(self):
        self.print_all_paths_to_leaf_helper([])

    def print_all_paths_to_leaf_helper(self, path_till_now):
        path_till_now.append(self.key)
        if self.children == []:
            for key in path_till_now:
                print(key, end=' ')
            print()
        else:
            for child in self.children:
                child.print_all_paths_to_leaf_helper(path_till_now[:])


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('paths')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'paths':
        if tree is None:
            print('Tree is empty.')
        else:
            tree.print_all_paths_to_leaf()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print only Nodes in Left SubTree
================================ EOPN
Python Program to Print only Nodes in Left SubTree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? left
Nodes of left subtree: 4 2 5 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 10 at root
What would you like to do? left
Nodes of left subtree: 
What would you like to do? insert 1 right of 10
What would you like to do? insert 2 left of 10
What would you like to do? insert 3 right of 2
What would you like to do? left
Nodes of left subtree: 2 3 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left(self):
        if self.left is not None:
            self.left.inorder()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('left')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'left':
        print('Nodes of left subtree: ', end='')
        if btree is not None:
            btree.print_left()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOPN
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 1 2 
What would you like to do? add 3 below 1
What would you like to do? add 10 below 2
What would you like to do? add 12 below 2
What would you like to do? add 14 below 3
What would you like to do? add 7 below 14
What would you like to do? bfs
BFS traversal: 1 2 3 10 12 14 7 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 8 below 5
What would you like to do? add 4 below 7
What would you like to do? add 3 below 7
What would you like to do? add 1 below 8
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 5 7 8 4 3 1 2 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('bfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'bfs':
        if tree is None:
            print('Tree is empty.')
        else:
            print('BFS traversal: ', end='')
            tree.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 7 left of 3
inorder traversal of binary tree: 7 3 
What would you like to do? sum
Sum of nodes in tree: 10
inorder traversal of binary tree: 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 2 at root
inorder traversal of binary tree: 2 
What would you like to do? insert 10 left of 2
inorder traversal of binary tree: 10 2 
What would you like to do? insert 1 right of 2
inorder traversal of binary tree: 10 2 1 
What would you like to do? insert 5 left of 1
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? sum
Sum of nodes in tree: 18
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def sum_nodes(node):
    if node is None:
        return 0
    return node.key + sum_nodes(node.left) + sum_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('sum')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'sum':
        print('Sum of nodes in tree: {}'.format(sum_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 5
5 occurs 3 time(s) in the list.

Case 2:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 3
3 occurs 1 time(s) in the list.

Case 3:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 7
7 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        current = self.head

        count = 0
        while current:
            if current.data == key:
                count = count + 1
            current = current.next

        return count

a_llist = LinkedList()
for data in [5, 1, 3, 5, 5, 15, 4, 9, 2]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 1 40 3 10
The alternate nodes of the linked list: 7 1 3 

Case 2:
Please enter the elements in the linked list: 4 9 1
The alternate nodes of the linked list: 4 1 

Case 3:
Please enter the elements in the linked list: 3
The alternate nodes of the linked list: 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        self.alternate_helper(self.head)

    def alternate_helper(self, current):
        if current is None:
            return
        print(current.data, end = ' ')
        if current.next:
            self.alternate_helper(current.next.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 4 1 9 10 3
The alternate nodes of the linked list: 7 4 9 3 

Case 2:
Please enter the elements in the linked list: 1 2
The alternate nodes of the linked list: 1 

Case 3:
Please enter the elements in the linked list: 9
The alternate nodes of the linked list: 9
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            if current.next is not None:
                current = current.next.next
            else:
                break

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Implement a Stack using Linked List
================================ EOPN
Python Program to Implement a Stack using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 15
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Popped value:  15
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Stack:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node

    def pop(self):
        if self.head is None:
            return None
        else:
            popped = self.head.data
            self.head = self.head.next
            return popped

a_stack = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        a_stack.push(int(do[1]))
    elif operation == 'pop':
        popped = a_stack.pop()
        if popped is None:
            print('Stack is empty.')
        else:
            print('Popped value: ', int(popped))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue Data Structure using Linked List
================================ EOPN
Python Program to Implement Queue Data Structure using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 5
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  5
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.last = None

    def enqueue(self, data):
        if self.last is None:
            self.head = Node(data)
            self.last = self.head
        else:
            self.last.next = Node(data)
            self.last = self.last.next

    def dequeue(self):
        if self.head is None:
            return None
        else:
            to_return = self.head.data
            self.head = self.head.next
            return to_return

a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        dequeued = a_queue.dequeue()
        if dequeued is None:
            print('Queue is empty.')
        else:
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Binary Tree using Linked List
================================ EOPN
Python Program to Implement Binary Tree using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 5 left of 3
inorder traversal of binary tree: 5 3 
What would you like to do? insert 2 right of 5
inorder traversal of binary tree: 5 2 3 
What would you like to do? insert 11 right of 3
inorder traversal of binary tree: 5 2 3 11 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 left of 2
inorder traversal of binary tree: 4 2 1 3 
What would you like to do? insert 5 right of 2
inorder traversal of binary tree: 4 2 5 1 3 
What would you like to do? insert 6 left of 3
inorder traversal of binary tree: 4 2 5 1 6 3 
What would you like to do? insert 7 right of 3
inorder traversal of binary tree: 4 2 5 1 6 3 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether 2 Linked Lists are Same
================================ EOPN
Python Program to Check whether 2 Linked Lists are Same
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 5 8 10 12
Please enter the elements in the second linked list: 5 8 10 12
The two linked lists are the same.

Case 2:
Please enter the elements in the first linked list: 12 3 4 5 0
Please enter the elements in the second linked list: 12 3
The two linked list are not the same.

Case 3:
Please enter the elements in the first linked list: 4 1
Please enter the elements in the second linked list: 2 19 4
The two linked list are not the same.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def is_equal(llist1, llist2):
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        if current1.data != current2.data:
            return False
        current1 = current1.next
        current2 = current2.next
    if current1 is None and current2 is None:
        return True
    else:
        return False


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

if is_equal(llist1, llist2):
    print('The two linked lists are the same.')
else:
    print('The two linked list are not the same.', end = '')
 ETP  
 
Python Program to Detect the Cycle in a Linked List
================================ EOPN
Python Program to Detect the Cycle in a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3
Enter the index [0-2] of the node to which you want the last node to point (enter nothing to make it point to None): 0
The linked list has a cycle.

Case 2:
Please enter the elements in the linked list: 4 5
Enter the index [0-1] of the node to which you want the last node to point (enter nothing to make it point to None): 1
The linked list has a cycle.

Case 3:
Please enter the elements in the linked list: 9 1 4 5
Enter the index [0-3] of the node to which you want the last node to point (enter nothing to make it point to None): 
The linked list does not have a cycle.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            current = current.next
            if current is None:
                return None
        return current


def has_cycle(llist):
    slow = llist.head
    fast = llist.head
    while (fast != None and fast.next != None):
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

length = len(data_list)
if length != 0:
    values = '0-' + str(length - 1)
    last_ptr = input('Enter the index [' + values + '] of the node'
                     ' to which you want the last node to point'
                     ' (enter nothing to make it point to None): ').strip()
    if last_ptr == '':
        last_ptr = None
    else:
        last_ptr = a_llist.get_node(int(last_ptr))
        a_llist.last_node.next = last_ptr

if has_cycle(a_llist):
    print('The linked list has a cycle.')
else:
    print('The linked list does not have a cycle.')
 ETP  
 
Python Program to Implement Graph
================================ EOPN
Python Program to Implement Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? display
Vertices: 1 2 
Edges: 

What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 

What would you like to do? add edge 1 3
What would you like to do? add edge 3 1
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 
(src=1, dest=3, weight=1) 
(src=3, dest=1, weight=1) 

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 4 5
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 

What would you like to do? add edge 5 4
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 
(src=5, dest=4, weight=1) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> [weight]')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    if len(do) == 5:
                        weight = int(do[4])
                        g.add_edge(src, dest, weight)
                    else:
                        g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Breadth-First Search on a Graph
================================ EOPN
Python Program to Implement Breadth-First Search on a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add vertex 9
What would you like to do? add vertex 10
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 1 5
What would you like to do? add edge 2 6
What would you like to do? add edge 3 7
What would you like to do? add edge 3 8
What would you like to do? add edge 4 8
What would you like to do? add edge 8 10
What would you like to do? add edge 5 10
What would you like to do? add edge 6 9
What would you like to do? add edge 9 10
What would you like to do? bfs 1
Breadth-first Traversal: 1 3 2 5 7 8 6 10 9 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bfs 1
Breadth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 
What would you like to do? bfs 2
Breadth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? bfs 2
Breadth-first Traversal: 2 1 
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 3 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def display_bfs(vertex):
    """Display BFS Traversal starting at vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        print(current.get_key(), end=' ')
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('bfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'bfs':
        key = int(do[1])
        print('Breadth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_bfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOPN
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the doubly linked list: 5 10 9 3
The largest element is 10.

Case 2:
Please enter the elements in the doubly linked list: 
The list is empty.

Case 3:
Please enter the elements in the doubly linked list: 234 10 4 200
The largest element is 234.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def append(self, data):
        self.insert_at_end(Node(data))

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            new_node.prev = self.last
            self.last.next = new_node
            self.last = new_node


def find_largest(dllist):
    if dllist.first is None:
        return None
    largest = dllist.first.data
    current = dllist.first.next
    while current:
        if current.data > largest:
            largest = current.data
        current = current.next
    return largest


a_dllist = DoublyLinkedList()

data_list = input('Please enter the elements in the doubly linked list: ').split()
for data in data_list:
    a_dllist.append(int(data))

largest = find_largest(a_dllist)
if largest:
    print('The largest element is {}.'.format(largest))
else:
    print('The list is empty.')
 ETP  
 
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOPN
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 9 10 15
Please enter the elements in the second linked list: 2 5 4
The sum linked list: 3 14 14 15 

Case 2:
Please enter the elements in the first linked list: 3 4 5
Please enter the elements in the second linked list: 
The sum linked list: 3 4 5 

Case 3:
Please enter the elements in the first linked list: 7 10
Please enter the elements in the second linked list: 6 5 4 3 2
The sum linked list: 13 15 4 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next


def add_linked_lists(llist1, llist2):
    sum_llist = LinkedList()
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        sum = current1.data + current2.data
        sum_llist.append(sum)
        current1 = current1.next
        current2 = current2.next
    if current1 is None:
        while current2:
            sum_llist.append(current2.data)
            current2 = current2.next
    else:
        while current1:
            sum_llist.append(current1.data)
            current1 = current1.next
    return sum_llist



llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

sum_llist = add_linked_lists(llist1, llist2)

print('The sum linked list: ', end = '')
sum_llist.display()
 ETP  
 
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOPN
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 4 5 1 3 10
Please enter the elements in the second linked list: 8 3 40 1
The element that appears first in the first linked list that is common to both is 1.

Case 2:
Please enter the elements in the first linked list: 1 4 5
Please enter the elements in the second linked list: 3 10
The two lists have no common elements.

Case 3:
Please enter the elements in the first linked list: 6 8 9
Please enter the elements in the second linked list: 7 10 6 4 9 8
The element that appears first in the first linked list that is common to both is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def first_common(llist1, llist2):
    current1 = llist1.head
    while current1:
        data = current1.data
        current2 = llist2.head
        while current2:
            if data == current2.data:
                return data
            current2 = current2.next
        current1 = current1.next
    return None


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

common = first_common(llist1, llist2)

if common:
    print('The element that appears first in the first linked list that'
          ' is common to both is {}.'.format(common))
else:
    print('The two lists have no common elements.')
 ETP  
 
Python Program to Remove Duplicates from a Linked List
================================ EOPN
Python Program to Remove Duplicates from a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 5 2 1 4 5 4 5
The list with duplicates removed: 
1 5 2 4 

Case 2:
Please enter the elements in the linked list: 3 4 1
The list with duplicates removed: 
3 4 1 

Case 3:
Please enter the elements in the linked list: 1 3 3 14 5 1 0
The list with duplicates removed: 
1 3 14 5 0
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        data = current1.data
        current2 = current1.next
        while current2:
            if current2.data == data:
                llist.remove(current2)
            current2 = current2.next
        current1 = current1.next


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

remove_duplicates(a_llist)

print('The list with duplicates removed: ')
a_llist.display()
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1, 4]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 5 4
What would you like to do? reachable 4
All nodes reachable from 4: [4]
What would you like to do? reachable 5
All nodes reachable from 5: [4, 5]
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2, 3]
What would you like to do? reachable 3
All nodes reachable from 3: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_all_reachable_nodes(vertex):
    """Return set containing all vertices reachable from vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)
    return visited


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 5 1
What would you like to do? add edge 4 2
What would you like to do? components
Component 1: [5, 2, 4, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
Vertex already exists.
What would you like to do? components
Component 1: [2, 3, 1]
Component 2: [4]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        component[current] = label
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            component_vertices = [v.get_key() for v in component
                                  if component[v] == label]
            print('Component {}:'.format(label), component_vertices)



    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOPN
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
What would you like to do? add edge 1 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 1): 3 1
Vertex 2 (distance 1): 2 1
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? add edge 4 5
What would you like to do? add edge 4 6
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 3): 5 4 2 1
Vertex 6 (distance 3): 6 4 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? add edge 2 6
What would you like to do? add edge 1 5
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 1): 5 1
Vertex 6 (distance 2): 6 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        # dictionary containing destination vertices mapped to the weight of the
        # edge with which they are joined to this vertex
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_shortest_paths(src):
    """Returns tuple of two dictionaries: (parent, distance)

    parent contains vertices mapped to their parent vertex in the shortest
    path from src to that vertex.
    distance contains vertices mapped to their shortest distance from src.
    """
    parent = {src: None}
    distance = {src: 0}

    visited = set()
    q = Queue()
    q.enqueue(src)
    visited.add(src)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                distance[dest] = distance[current] + 1
                q.enqueue(dest)
    return (parent, distance)

g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('shortest <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        src = g.get_vertex(key)
        parent, distance = find_shortest_paths(src)

        print('Path from destination vertices to source vertex {}:'.format(key))
        for v in parent:
            print('Vertex {} (distance {}): '.format(v.get_key(), distance[v]),
                  end='')
            while parent[v] is not None:
                print(v.get_key(), end = ' ')
                v = parent[v]
            print(src.get_key()) # print source vertex

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 2 4
What would you like to do? add edge 2 5
What would you like to do? add edge 6 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 6 2
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_cycle_present(vertex, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {vertex: None}
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                q.enqueue(dest)
            else:
                if parent[current] is not dest:
                    return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Reverse a Linked List
================================ EOPN
Python Program to Reverse a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 30 4
The reversed list: 
4 30 1 7 

Case 2:
Please enter the elements in the linked list: 3
The reversed list: 
3 

Case 3:
Please enter the elements in the linked list: 1 2
The reversed list: 
2 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist):
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    while after:
        current.next = before
        before = current
        current = after
        after = after.next
    current.next = before
    llist.head = current


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

reverse_llist(a_llist)

print('The reversed list: ')
a_llist.display()
 ETP  
 
Python Program to Reverse only First N Elements of a Linked List
================================ EOPN
Python Program to Reverse only First N Elements of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7
Enter the number of elements you want to reverse in the list: 4
The new list: 
4 3 2 1 5 6 7 

Case 2:
Please enter the elements in the linked list: 7 2 4
Enter the number of elements you want to reverse in the list: 1
The new list: 
7 2 4 

Case 3:
Please enter the elements in the linked list: 8 3 2
Enter the number of elements you want to reverse in the list: 3
The new list: 
2 3 8
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist, n):
    if n == 0:
        return
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    for i in range(n):
        current.next = before
        before = current
        current = after
        if after is None:
            break
        after = after.next
    llist.head.next = current
    llist.head = before


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))
n = int(input('Enter the number of elements you want to reverse in the list: '))

reverse_llist(a_llist, n)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Print Middle most Node of a Linked List
================================ EOPN
Python Program to Print Middle most Node of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7 8
The two middle elements are 4 and 5.

Case 2:
Please enter the elements in the linked list: 5
The middle element is 5.

Case 3:
Please enter the elements in the linked list: 3 1 0 4 2
The middle element is 0.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def print_middle(llist):
    current = llist.head
    length = 0
    while current:
        current = current.next
        length = length + 1

    current = llist.head
    for i in range((length - 1)//2):
        current = current.next

    if current:
        if length % 2 == 0:
            print('The two middle elements are {} and {}.'
                .format(current.data, current.next.data))
        else:
            print('The middle element is {}.'.format(current.data))
    else:
        print('The list is empty.')


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_middle(a_llist)
 ETP  
 
Python Program to Print Nth Node from the last of a Linked List
================================ EOPN
Python Program to Print Nth Node from the last of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 10 20 40 50 60
The nth element from the end will be printed. Please enter n: 3
The nth element from the end: 40

Case 2:
Please enter the elements in the linked list: 4 23 3
The nth element from the end will be printed. Please enter n: 1
The nth element from the end: 3

Case 3:
Please enter the elements in the linked list: 1 2
The nth element from the end will be printed. Please enter n: 2
The nth element from the end: 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def length_llist(llist):
    length = 0
    current = llist.head
    while current:
        current = current.next
        length = length + 1
    return length


def return_n_from_last(llist, n):
    l = length_llist(llist)
    current = llist.head
    for i in range(l - n):
        current = current.next
    return current.data


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

n = int(input('The nth element from the end will be printed. Please enter n: '))
value = return_n_from_last(a_llist, n)

print('The nth element from the end: {}'.format(value))
 ETP  
 
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOPN
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 2 3 4 5
Please enter the elements in the second linked list: 3 4 5 6 7 8
Their union: 
1 2 3 4 5 6 7 8 
Their intersection: 
3 4 5 

Case 2:
Please enter the elements in the first linked list: 
Please enter the elements in the second linked list: 7 8
Their union: 
7 8 
Their intersection: 

Case 3:
Please enter the elements in the first linked list: 8 4 2 1 10 3 4 7 8
Please enter the elements in the second linked list: 5 6 3 4 3 2 5 2 8
Their union: 
8 4 2 1 10 3 7 5 6 
Their intersection: 
8 4 2 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def duplicate(self):
        copy = LinkedList()
        current = self.head
        while current:
            node = Node(current.data)
            copy.insert_at_end(node)
            current = current.next
        return copy

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        current2 = current1.next
        data = current1.data
        while current2:
            temp = current2
            current2 = current2.next
            if temp.data == data:
                llist.remove(temp)
        current1 = current1.next


def find_union(llist1, llist2):
    if llist1.head is None:
        union = llist2.duplicate()
        remove_duplicates(union)
        return union
    if llist2.head is None:
        union = llist1.duplicate()
        remove_duplicates(union)
        return union

    union = llist1.duplicate()
    last_node = union.head
    while last_node.next is not None:
        last_node = last_node.next
    llist2_copy = llist2.duplicate()
    last_node.next = llist2_copy.head
    remove_duplicates(union)

    return union


def find_intersection(llist1, llist2):
    if (llist1.head is None or llist2.head is None):
        return LinkedList()

    intersection = LinkedList()
    current1 = llist1.head
    while current1:
        current2 = llist2.head
        data = current1.data
        while current2:
            if current2.data == data:
                node = Node(data)
                intersection.insert_at_end(node)
                break
            current2 = current2.next
        current1 = current1.next
    remove_duplicates(intersection)

    return intersection


a_llist1 = LinkedList()
a_llist2 = LinkedList()
data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist1.insert_at_end(node)
data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist2.insert_at_end(node)

union = find_union(a_llist1, a_llist2)
intersection = find_intersection(a_llist1, a_llist2)

print('Their union: ')
union.display()
print()
print('Their intersection: ')
intersection.display()
print()
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 5 6
What would you like to do? add edge 6 7
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 7 1
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    visited.add(vertex)
    q = Queue()
    q.enqueue(vertex)
    while not q.is_empty():
        current = q.dequeue()

        next_colour = 1 - colour[current] # switch colour
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                colour[dest] = next_colour
                q.enqueue(dest)
            else:
                if colour[dest] != next_colour:
                    return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 3 5
What would you like to do? add edge 1 6
What would you like to do? add edge 6 2
What would you like to do? dfs 1
Depth-first Traversal: 1 6 2 3 4 5 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 1 2 
What would you like to do? dfs 2
Depth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? dfs 2
Depth-first Traversal: 2 3 4 1 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def display_dfs(v):
    """Display DFS traversal starting at vertex v."""
    display_dfs_helper(v, set())


def display_dfs_helper(v, visited):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes."""
    visited.add(v)
    print(v.get_key(), end=' ')
    for dest in v.get_neighbours():
        if dest not in visited:
            display_dfs_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? add edge 3 7
What would you like to do? dfs 1
Depth-first Traversal: 1 5 6 2 3 7 4 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


def display_dfs(v):
    visited = set()
    s = Stack()
    s.push(vertex)
    while not s.is_empty():
        current = s.pop()
        if current in visited:
            continue
        print(current.get_key(), end=' ')
        visited.add(current)
        for dest in current.get_neighbours():
            if dest not in visited:
                s.push(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print DFS Numbering of a Graph
================================ EOPN
Python Program to Print DFS Numbering of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Visiting 3... discovered time = 3
Visiting 4... discovered time = 4
Leaving 4... finished time = 5
Leaving 3... finished time = 6
Leaving 2... finished time = 7
Visiting 5... discovered time = 8
Visiting 6... discovered time = 9
Leaving 6... finished time = 10
Leaving 5... finished time = 11
Leaving 1... finished time = 12

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Leaving 1... finished time = 2

What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Leaving 2... finished time = 3
Leaving 1... finished time = 4

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to

def dfs(v, pre, post):
    """Display DFS traversal starting at vertex v. Stores pre and post times in
    dictionaries pre and post."""
    dfs_helper(v, set(), pre, post, [0])

def dfs_helper(v, visited, pre, post, time):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes, dictionaries pre and post to store
    discovered and finished times and the one-element list time to keep track of
    current time."""
    visited.add(v)
    time[0] = time[0] + 1
    pre[v] = time[0]
    print('Visiting {}... discovered time = {}'.format(v.get_key(), time[0]))
    for dest in v.get_neighbours():
        if dest not in visited:
            dfs_helper(dest, visited, pre, post, time)
    time[0] = time[0] + 1
    post[v] = time[0]
    print('Leaving {}... finished time = {}'.format(v.get_key(), time[0]))


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ')
        vertex = g.get_vertex(key)
        pre = dict()
        post = dict()
        dfs(vertex, pre, post)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Solve Josephus Problem using Linked List
================================ EOPN
Python Program to Solve Josephus Problem using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Input number of people: 5
The kth person will be executed. Input k: 3
The person at position 4 won't be killed.

Case 2:
Input number of people: 15
The kth person will be executed. Input k: 7
The person at position 5 won't be killed.

Case 3:
Input number of people: 8
The kth person will be executed. Input k: 2
The person at position 1 won't be killed.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        node = Node(data)
        self.insert_at_end(node)

    def get_node(self, index, start):
        if self.head is None:
            return None
        current = start
        for i in range(index):
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next


def has_one_node(cllist):
    if cllist.head.next == cllist.head:
        return True
    else:
        return False


def get_josephus_solution(cllist, k):
    if cllist.head is None:
        return None
    start = cllist.head
    while not has_one_node(cllist):
        to_remove = cllist.get_node(k - 1, start)
        start = to_remove.next
        cllist.remove(to_remove)
    return cllist.head.data


a_cllist = CircularLinkedList()
n = int(input('Input number of people: '))
k = int(input('The kth person will be executed. Input k: '))
for i in range(1, n + 1):
    a_cllist.append(i)

ans = get_josephus_solution(a_cllist, k)
print('The person at position {} won\'t be killed.'.format(ans))
 ETP  
 
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOPN
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
Please enter the two indices of the two elements that you want to exchange: 0 1
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 5 1
Please enter the two indices of the two elements that you want to exchange: 1 2
The new list: 
4 1 5 

Case 3:
Please enter the elements in the linked list: 3 1 30 4 5 10 23
Please enter the two indices of the two elements that you want to exchange: 2 5
The new list: 
3 1 10 4 5 30 23
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def interchange(llist, n, m):
    node1 = llist.get_node(n)
    node2 = llist.get_node(m)
    prev_node1 = llist.get_prev_node(node1)
    prev_node2 = llist.get_prev_node(node2)
    if prev_node1 is not None:
        prev_node1.next = node2
    else:
        llist.head = node2
    if prev_node2 is not None:
        prev_node2.next = node1
    else:
        llist.head = node1
    temp = node2.next
    node2.next = node1.next
    node1.next = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

ans = input('Please enter the two indices of the two elements that'
            ' you want to exchange: ').split()
n = int(ans[0])
m = int(ans[1])

interchange(a_llist, n, m)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOPN
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 1 0 4 30 12
The new list: 
12 30 4 0 3 1 

Case 2:
Please enter the elements in the linked list: 1 2
The new list: 
2 1 

Case 3:
Please enter the elements in the linked list: 1 2 3 4 5
The new list: 
4 2 1 3 5
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next


def move_even_before_odd(llist):
    current = llist.head
    while current:
        temp = current.next
        if current.data % 2 == 0:
            llist.remove(current)
            llist.insert_at_beg(current)
        current = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

move_even_before_odd(a_llist)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 4 5
What would you like to do? add edge 5 6
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 4
All nodes reachable from 4: [6, 4, 5]
What would you like to do? reachable 7
All nodes reachable from 7: [7]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def find_all_reachable_nodes(v):
    """Return set containing all vertices reachable from vertex."""
    reachable = set()
    find_all_reachable_nodes_helper(v, reachable)
    return reachable


def find_all_reachable_nodes_helper(v, visited):
    """Add all vertices visited by DFS traversal starting at v to the set visited."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            find_all_reachable_nodes_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [2, 1]
Component 2: [3]
Component 3: [4]
Component 4: [5]
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 1 5
What would you like to do? components
Component 1: [2, 5, 1]
Component 2: [4, 3]
What would you like to do? add edge 2 4
What would you like to do? components
Component 1: [4, 2, 5, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? components
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? components
Component 1: [1]
Component 2: [2]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [1, 2]
What would you like to do? add vertex 3
What would you like to do? components
Component 1: [1, 2]
Component 2: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    label_all_reachable_helper(vertex, set(), component, label)


def label_all_reachable_helper(vertex, visited, component, label):
    """Set component[v] = label for all v in the component containing
    vertex. Uses set visited to keep track of nodes alread visited."""
    visited.add(vertex)
    component[vertex] = label
    for dest in vertex.get_neighbours():
        if dest not in visited:
            label_all_reachable_helper(dest, visited, component, label)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            print('Component {}:'.format(label),
                  [v.get_key() for v in component if component[v] == label])


    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOPN
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
The nodes at indices n and n+1 will be interchanged. Please enter n: 0
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 1 5
The nodes at indices n and n+1 will be interchanged. Please enter n: 2
The new list: 
5 1 4 

Case 3:
Please enter the elements in the linked list: 3 18 40 1 6
The nodes at indices n and n+1 will be interchanged. Please enter n: 3
The new list: 
3 18 40 6 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def append(self, data):
        self.insert_at_end(Node(data))

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break

def interchange(llist, n):
    current = llist.get_node(n)
    current2 = current.next
    if current2.next != current:
        before = llist.get_prev_node(current)
        after = current2.next
        before.next = current2
        current2.next = current
        current.next = after
    if llist.head == current:
        llist.head = current2
    elif llist.head == current2:
        llist.head = current


a_cllist = CircularLinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_cllist.append(int(data))

n = int(input('The nodes at indices n and n+1 will be interchanged.'
              ' Please enter n: '))

interchange(a_cllist, n)

print('The new list: ')
a_cllist.display()
 ETP  
 
Python Program to Illustrate the Operations of Singly Linked List
================================ EOPN
Python Program to Illustrate the Operations of Singly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 3 at end
The list: 7 3 
What would you like to do? insert 1 after 0
The list: 7 1 3 
What would you like to do? insert 9 before 2
The list: 7 1 9 3 
What would you like to do? remove 2
The list: 7 1 3 
What would you like to do? insert 12 at end
The list: 7 1 3 12 
What would you like to do? remove 0
The list: 1 3 12 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 after 0
No such index.
The list: 
What would you like to do? insert 3 at end
The list: 3 
What would you like to do? insert 1 after 0
The list: 3 1 
What would you like to do? insert 2 before 1
The list: 3 2 1 
What would you like to do? insert 0 at end
The list: 3 2 1 0 
What would you like to do? remove 3
The list: 3 2 1 
What would you like to do? remove 2
The list: 3 2 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_llist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_llist.insert_at_beg(new_node)
            elif position == 'end':
                a_llist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_llist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_llist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_llist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_llist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_llist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOPN
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 8 1 8 7
The linked lists is palindromic.

Case 2:
Please enter the elements in the linked list: 1 2 3 3 2 1
The linked list is palindromic.

Case 3:
Please enter the elements in the linked list: 1 4 5 4 5 1
The linked list is not palindromic.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def is_palindrome(llist):
    start = llist.head
    end = llist.last_node
    while (start != end and end.next != start):
        if start.data != end.data:
            return False
        start = start.next
        end = llist.get_prev_node(end)
    return True


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

if is_palindrome(a_llist):
    print('The linked list is palindromic.')
else:
    print('The linked list is not palindromic.')
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 5 1
What would you like to do? add edge 6 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 5
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    return is_bipartite_helper(vertex, visited, colour)


def is_bipartite_helper(v, visited, colour):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited. Uses dictionary colour to keep
    track of colour of each vertex."""
    visited.add(v)
    next_colour = 1 - colour[v] # switch colour
    for dest in v.get_neighbours():
        if dest not in visited:
            colour[dest] = next_colour
            if not is_bipartite_helper(dest, visited, colour):
                return False
        else:
            if colour[dest] != next_colour:
                return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add vertex 5
What would you like to do? add edge 4 5
What would you like to do? add edge 5 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(v, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {v: None}
    return is_cycle_present_helper(v, visited, parent)


def is_cycle_present_helper(v, visited, parent):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited. Uses dictionary parent to keep
    track of parents of nodes in the DFS tree."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            parent[dest] = v
            if is_cycle_present_helper(dest, visited, parent):
                return True
        else:
            if parent[v] is not dest:
                return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 4
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 3 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(graph):
    """Return True if cycle is present in the graph."""
    on_stack = set()
    visited = set()
    for v in graph:
        if v not in visited:
            if is_cycle_present_helper(v, visited, on_stack):
                return True
    return False


def is_cycle_present_helper(v, visited, on_stack):
    """Return True if the DFS traversal starting at vertex v detects a
    cycle. Uses set visited to keep track of nodes that have been visited. Uses
    set on_stack to keep track of nodes that are 'on the stack' of the recursive
    calls."""
    if v in on_stack:
        return True
    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if is_cycle_present_helper(dest, visited, on_stack):
                return True
    on_stack.remove(v)
    visited.add(v)
    return False


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_edge_exist(v1, v2):
                    g.add_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        if is_cycle_present(g):
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOPN
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? topological
Topological Sorting: [3, 2, 1]
What would you like to do? add edge 1 2
What would you like to do? topological
Topological Sorting: [3, 1, 2]
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 4 5
What would you like to do? topological
Topological Sorting: [7, 6, 4, 5, 1, 2, 3]
What would you like to do? add edge 4 6
What would you like to do? topological
Topological Sorting: [7, 4, 5, 6, 1, 2, 3]
What would you like to do? add edge 5 7
What would you like to do? topological
Topological Sorting: [4, 5, 7, 6, 1, 2, 3]
What would you like to do? add edge 3 4
What would you like to do? topological
Topological Sorting: [1, 2, 3, 4, 5, 7, 6]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? topological
Topological Sorting: [1]
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add edge 3 2
What would you like to do? topological
Graph is not a DAG.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def get_topological_sorting(graph):
    """Return a topological sorting of the DAG. Return None if graph is not a DAG."""
    tlist = []
    visited = set()
    on_stack = set()
    for v in graph:
        if v not in visited:
            if not get_topological_sorting_helper(v, visited, on_stack, tlist):
                return None
    return tlist


def get_topological_sorting_helper(v, visited, on_stack, tlist):
    """Perform DFS traversal starting at vertex v and store a topological
    sorting of the DAG in tlist. Return False if it is found that the graph is
    not a DAG. Uses set visited to keep track of already visited nodes."""
    if v in on_stack:
        # graph has cycles and is therefore not a DAG.
        return False

    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if not get_topological_sorting_helper(dest, visited, on_stack, tlist):
                return False
    on_stack.remove(v)
    visited.add(v)
    tlist.insert(0, v.get_key()) # prepend node key to tlist
    return True


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('topological')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'topological':
        tlist = get_topological_sorting(g)
        if tlist is not None:
            print('Topological Sorting: ', end='')
            print(tlist)
        else:
            print('Graph is not a DAG.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOPN
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 3 40 1
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 7.

Case 2:
Please enter the elements in the linked list: 3
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 3.

Case 3:
Please enter the elements in the linked list: 1 2
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 1.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def convert_to_circular(llist):
    if llist.last_node:
        llist.last_node.next = llist.head


def print_last_node_points_to(llist):
    last = llist.last_node
    if last is None:
        print('List is empty.')
        return
    if last.next is None:
        print('Last node points to None.')
    else:
        print('Last node points to element with data {}.'.format(last.next.data))


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_last_node_points_to(a_llist)

print('Converting linked list to a circular linked list...')
convert_to_circular(a_llist)

print_last_node_points_to(a_llist)
 ETP  
 
Python Program to Implement Circular Doubly Linked List
================================ EOPN
Python Program to Implement Circular Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 at beg
The list: 3 
What would you like to do? insert 5 at end
The list: 3 5 
What would you like to do? insert 1 after 0
The list: 3 1 5 
What would you like to do? insert 2 after 2
The list: 3 1 5 2 
What would you like to do? remove 0
The list: 1 5 2 
What would you like to do? remove 2
The list: 1 5 
What would you like to do? remove 1
The list: 1 
What would you like to do? remove 0
The list: 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 10 at end
The list: 10 
What would you like to do? insert 1 at beg
The list: 1 10 
What would you like to do? insert 5 before 0
The list: 1 10 5 
What would you like to do? insert 9 at beg
The list: 9 1 10 5 
What would you like to do? remove 3
The list: 9 1 10 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class CircularDoublyLinkedList:
    def __init__(self):
        self.first = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            current = current.next
            if current == self.first:
                return None
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        new_node.next = ref_node.next
        new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        self.insert_after(ref_node.prev, new_node)

    def insert_at_end(self, new_node):
        if self.first is None:
            self.first = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            self.insert_after(self.first.prev, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.first = new_node

    def remove(self, node):
        if self.first.next == self.first:
            self.first = None
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
            if self.first == node:
                self.first = node.next

    def display(self):
        if self.first is None:
            return
        current = self.first
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.first:
                break


a_cdllist = CircularDoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cdllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cdllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cdllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cdllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cdllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cdllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cdllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cdllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Demonstrate Circular Single Linked List
================================ EOPN
Python Program to Demonstrate Circular Single Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 1 before 0
The list: 7 1 
What would you like to do? insert 10 after 0
The list: 7 10 1 
What would you like to do? insert 3 at end
The list: 7 10 1 3 
What would you like to do? remove 2
The list: 7 10 3 
What would you like to do? remove 0
The list: 10 3 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 1 at beg
The list: 1 
What would you like to do? insert 3 after 2
No such index.
The list: 1 
What would you like to do? remove 1
No such index.
The list: 1 
What would you like to do? insert 6 after 0
The list: 1 6 
What would you like to do? remove 0
The list: 6 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.head = new_node

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break


a_cllist = CircularLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOPN
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 at beg
The list: 5 
What would you like to do? insert 3 at beg
The list: 3 5 
What would you like to do? insert 1 at end
The list: 3 5 1 
What would you like to do? insert 10 after 1
The list: 3 5 10 1 
What would you like to do? insert 0 before 2
The list: 3 5 0 10 1 
What would you like to do? remove 4
The list: 3 5 0 10 
What would you like to do? remove 1
The list: 3 0 10 
What would you like to do? remove 5
No such index.
The list: 3 0 10 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 2 at beg
The list: 2 
What would you like to do? insert 3 before 0
The list: 3 2 
What would you like to do? remove 0
The list: 2 
What would you like to do? remove 0
The list: 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        if ref_node.next is None:
            self.last = new_node
        else:
            new_node.next = ref_node.next
            new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        new_node.next = ref_node
        if ref_node.prev is None:
            self.first = new_node
        else:
            new_node.prev = ref_node.prev
            new_node.prev.next = new_node
        ref_node.prev = new_node

    def insert_at_beg(self, new_node):
        if self.first is None:
            self.first = new_node
            self.last = new_node
        else:
            self.insert_before(self.first, new_node)

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            self.insert_after(self.last, new_node)

    def remove(self, node):
        if node.prev is None:
            self.first = node.next
        else:
            node.prev.next = node.next

        if node.next is None:
            self.last = node.prev
        else:
            node.next.prev = node.prev

    def display(self):
        current = self.first
        while current:
            print(current.data, end = ' ')
            current = current.next


a_dllist = DoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_dllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_dllist.insert_at_beg(new_node)
            elif position == 'end':
                a_dllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_dllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_dllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_dllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_dllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_dllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOPN
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 80
What would you like to do? add edge 3 4 70
What would you like to do? add edge 2 5 20
What would you like to do? add edge 2 3 6
What would you like to do? add edge 5 6 50
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? shortest 1
Distances from 1: 
Distance to 6: 45
Distance to 3: 16
Distance to 4: 86
Distance to 5: 30
Distance to 2: 10
Distance to 7: 40
Distance to 1: 0

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 20
What would you like to do? add edge 3 4 30
What would you like to do? add edge 1 4 100
What would you like to do? shortest 1
Distances from 1: 
Distance to 2: 10
Distance to 4: 60
Distance to 3: 30
Distance to 1: 0
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('shortest <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = dijkstra(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Bellman-Ford Algorithm
================================ EOPN
Python Program to Implement Bellman-Ford Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 8 8
What would you like to do? add edge 2 6 2
What would you like to do? add edge 3 2 1
What would you like to do? add edge 3 4 1
What would you like to do? add edge 4 5 3
What would you like to do? add edge 5 6 -1
What would you like to do? add edge 6 3 -2
What would you like to do? add edge 7 2 -4
What would you like to do? add edge 7 6 -1
What would you like to do? add edge 8 7 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 5: 9
Distance to 6: 7
Distance to 7: 9
Distance to 2: 5
Distance to 1: 0
Distance to 8: 8
Distance to 3: 5
Distance to 4: 6

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0

What would you like to do? add vertex 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 2: inf

What would you like to do? add edge 1 2 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 3 -1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 2

What would you like to do? add edge 3 2 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 1

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('bellman-ford <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'bellman-ford':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = bellman_ford(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Floyd-Warshall Algorithm
================================ EOPN
Python Program to Implement Floyd-Warshall Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 1 3 8
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 5 -> 4 -> 3 -> 2 (distance 1)
From 1 to 3: 1 -> 5 -> 4 -> 3 (distance -3)
From 1 to 4: 1 -> 5 -> 4 (distance 2)
From 1 to 5: 1 -> 5 (distance -4)
From 2 to 1: 2 -> 4 -> 1 (distance 3)
From 2 to 3: 2 -> 4 -> 3 (distance -4)
From 2 to 4: 2 -> 4 (distance 1)
From 2 to 5: 2 -> 4 -> 1 -> 5 (distance -1)
From 3 to 1: 3 -> 2 -> 4 -> 1 (distance 7)
From 3 to 2: 3 -> 2 (distance 4)
From 3 to 4: 3 -> 2 -> 4 (distance 5)
From 3 to 5: 3 -> 2 -> 4 -> 1 -> 5 (distance 3)
From 4 to 1: 4 -> 1 (distance 2)
From 4 to 2: 4 -> 3 -> 2 (distance -1)
From 4 to 3: 4 -> 3 (distance -5)
From 4 to 5: 4 -> 1 -> 5 (distance -2)
From 5 to 1: 5 -> 4 -> 1 (distance 8)
From 5 to 2: 5 -> 4 -> 3 -> 2 (distance 5)
From 5 to 3: 5 -> 4 -> 3 (distance 1)
From 5 to 4: 5 -> 4 (distance 6)
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 -7
What would you like to do? add edge 1 3 5
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 2 (distance 10)
From 1 to 3: 1 -> 2 -> 3 (distance 3)
From 2 to 3: 2 -> 3 (distance -7)
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def floyd_warshall(g):
    """Return dictionaries distance and next_v.

    distance[u][v] is the shortest distance from vertex u to v.
    next_v[u][v] is the next vertex after vertex v in the shortest path from u
    to v. It is None if there is no path between them. next_v[u][u] should be
    None for all u.

    g is a Graph object which can have negative edge weights.
    """
    distance = {v:dict.fromkeys(g, float('inf')) for v in g}
    next_v = {v:dict.fromkeys(g, None) for v in g}

    for v in g:
        for n in v.get_neighbours():
            distance[v][n] = v.get_weight(n)
            next_v[v][n] = n

    for v in g:
         distance[v][v] = 0
         next_v[v][v] = None

    for p in g: 
        for v in g:
            for w in g:
                if distance[v][w] > distance[v][p] + distance[p][w]:
                    distance[v][w] = distance[v][p] + distance[p][w]
                    next_v[v][w] = next_v[v][p]

    return distance, next_v


def print_path(next_v, u, v):
    """Print shortest path from vertex u to v.

    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u
    in the shortest path from u to v. It is None if there is no path between
    them. next_v[u][u] should be None for all u.

    u and v are Vertex objects.
    """
    p = u
    while (next_v[p][v]):
        print('{} -> '.format(p.get_key()), end='')
        p = next_v[p][v]
    print('{} '.format(v.get_key()), end='')


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('floyd-warshall')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'floyd-warshall':
        distance, next_v = floyd_warshall(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                if next_v[start][end]:
                    print('From {} to {}: '.format(start.get_key(),
                                                    end.get_key()),
                            end = '')
                    print_path(next_v, start, end)
                    print('(distance {})'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Transitive Closure of a Graph
================================ EOPN
Python Program to Find Transitive Closure of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
transitive-closure
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
2, 2
What would you like to do? add edge 1 2 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
2, 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
1, 3
2, 2
2, 3
3, 3
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
transitive-closure
display
quit
What would you like to do? add vertex 0
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 0 1
What would you like to do? add edge 0 2
What would you like to do? add edge 1 2
What would you like to do? add edge 2 0
What would you like to do? add edge 2 3
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
0, 0
0, 1
0, 2
0, 3
1, 0
1, 1
1, 2
1, 3
2, 0
2, 1
2, 2
2, 3
3, 3
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def transitive_closure(g):
    """Return dictionary reachable.

    reachable[u][v] = True iff there is a path from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    reachable = {v:dict.fromkeys(g, False) for v in g}

    for v in g:
        for n in v.get_neighbours():
            reachable[v][n] = True

    for v in g:
         reachable[v][v] = True

    for p in g: 
        for v in g:
            for w in g:
                if reachable[v][p] and reachable[p][w]:
                    reachable[v][w] = True

    return reachable


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('transitive-closure')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'transitive-closure':
        reachable = transitive_closure(g)
        print('All pairs (u, v) such that there is a path from u to v: ')
        for start in g:
            for end in g:
                if reachable[start][end]:
                    print('{}, {}'.format(start.get_key(), end.get_key()))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 3 18
What would you like to do? add edge 1 2 10
What would you like to do? add edge 3 4 70
What would you like to do? add edge 3 2 6
What would you like to do? add edge 2 5 20
What would you like to do? add edge 5 6 10
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 7 
Edges: 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=2, dest=3, weight=6) 
(src=3, dest=2, weight=6) 
(src=3, dest=4, weight=70) 
(src=4, dest=3, weight=70) 
(src=5, dest=6, weight=10) 
(src=5, dest=2, weight=20) 
(src=6, dest=5, weight=10) 
(src=6, dest=7, weight=5) 
(src=7, dest=6, weight=5) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 100
What would you like to do? add edge 1 3 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=10) 
(src=1, dest=3, weight=50) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=50) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_prim(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    # if graph is empty
    if not g:
        return mst

    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    nearest_neighbour = {}
    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    smallest_distance = {}
    # v is in unvisited iff v has not been added to the MST
    unvisited = set(g)

    u = next(iter(g)) # select any one vertex from g
    mst.add_vertex(u.get_key()) # add a copy of it to the MST
    unvisited.remove(u)

    # for each neighbour of vertex u
    for n in u.get_neighbours():
        if n is u:
            # avoid self-loops
            continue
        # update dictionaries
        nearest_neighbour[n] = mst.get_vertex(u.get_key())
        smallest_distance[n] = u.get_weight(n)

    # loop until smallest_distance becomes empty
    while (smallest_distance):
        # get nearest vertex outside the MST
        outside_mst = min(smallest_distance, key=smallest_distance.get)
        # get the nearest neighbour inside the MST
        inside_mst = nearest_neighbour[outside_mst]

        # add a copy of the outside vertex to the MST
        mst.add_vertex(outside_mst.get_key())
        # add the edge to the MST
        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),
                     smallest_distance[outside_mst])
        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),
                     smallest_distance[outside_mst])

        # now that outside_mst has been added to the MST, remove it from our
        # dictionaries and the set unvisited
        unvisited.remove(outside_mst)
        del smallest_distance[outside_mst]
        del nearest_neighbour[outside_mst]

        # update dictionaries
        for n in outside_mst.get_neighbours():
            if n in unvisited:
                if n not in smallest_distance:
                    smallest_distance[n] = outside_mst.get_weight(n)
                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())
                else:
                    if smallest_distance[n] > outside_mst.get_weight(n):
                        smallest_distance[n] = outside_mst.get_weight(n)
                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_prim(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Stack
================================ EOPN
Python Program to Implement a Stack
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? push 5
push <value>
pop
quit
What would you like to do? pop
Popped value:  5
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? push 1
push <value>
pop
quit
What would you like to do? pop
Popped value:  1
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Reverse a Stack using Recursion
================================ EOPN
Python Program to Reverse a Stack using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements to push: 7 3 1 5
The stack:
5
1
3
7
After reversing:
7
3
1
5

Case 2:
Please enter the elements to push: 3
The stack:
3
After reversing:
3

Case 3:
Please enter the elements to push: 1 2
The stack:
2
1
After reversing:
1
2
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def display(self):
        for data in reversed(self.items):
            print(data)

def insert_at_bottom(s, data):
    if s.is_empty():
        s.push(data)
    else:
        popped = s.pop()
        insert_at_bottom(s, data)
        s.push(popped)


def reverse_stack(s):
    if not s.is_empty():
        popped = s.pop()
        reverse_stack(s)
        insert_at_bottom(s, popped)


s = Stack()
data_list = input('Please enter the elements to push: ').split()
for data in data_list:
    s.push(int(data))

print('The stack:')
s.display()
reverse_stack(s)
print('After reversing:')
s.display()
 ETP  
 
Python Program to Implement Stack using One Queue
================================ EOPN
Python Program to Implement Stack using One Queue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? push 3
What would you like to do? push 5
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.q = Queue()

    def is_empty(self):
        return self.q.is_empty()

    def push(self, data):
        self.q.enqueue(data)

    def pop(self):
        for _ in range(self.q.get_size() - 1):
            dequeued = self.q.dequeue()
            self.q.enqueue(dequeued)
        return self.q.dequeue()


class Queue:
    def __init__(self):
        self.items = []
        self.size = 0

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.size += 1
        self.items.append(data)

    def dequeue(self):
        self.size -= 1
        return self.items.pop(0)

    def get_size(self):
        return self.size


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Stack Using Two Queues
================================ EOPN
Python Program to Implement Stack Using Two Queues
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? pop
Popped value:  2
What would you like to do? quit

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 5
What would you like to do? push 0
What would you like to do? pop
Popped value:  0
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def is_empty(self):
        return self.queue2.is_empty()

    def push(self, data):
        self.queue1.enqueue(data)
        while not self.queue2.is_empty():
            x = self.queue2.dequeue()
            self.queue1.enqueue(x)
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        return self.queue2.dequeue()

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue
================================ EOPN
Python Program to Implement Queue
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  1
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


q = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        q.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if q.is_empty():
            print('Queue is empty.')
        else:
            print('Dequeued value: ', q.dequeue())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 5 30
What would you like to do? add edge 1 4 40
What would you like to do? add edge 2 5 20
What would you like to do? add edge 4 5 40
What would you like to do? add edge 5 3 40
What would you like to do? add edge 5 6 70
What would you like to do? add edge 3 6 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 
Edges: 
(src=1, dest=4, weight=40) 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=3, dest=5, weight=40) 
(src=3, dest=6, weight=50) 
(src=4, dest=1, weight=40) 
(src=5, dest=2, weight=20) 
(src=5, dest=3, weight=40) 
(src=6, dest=3, weight=50) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 20
What would you like to do? add edge 2 3 30
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=3, weight=20) 
(src=1, dest=2, weight=10) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=20) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_vertex_exist(self, key):
        return key in self.vertices

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_krusal(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    if len(g) == 1:
        u = next(iter(g)) # get the single vertex
        mst.add_vertex(u.get_key()) # add a copy of it to mst
        return mst

    # get all the edges in a list
    edges = []
    for v in g:
        for n in v.get_neighbours():
            # avoid adding two edges for each edge of the undirected graph
            if v.get_key() < n.get_key():
                edges.append((v, n))

    # sort edges
    edges.sort(key=lambda edge: edge[0].get_weight(edge[1]))

    # initially, each vertex is in its own component
    component = {}
    for i, v in enumerate(g):
        component[v] = i

    # next edge to try
    edge_index = 0

    # loop until mst has the same number of vertices as g
    while len(mst) < len(g):
        u, v = edges[edge_index]
        edge_index += 1

        # if adding edge (u, v) will not form a cycle
        if component[u] != component[v]:

            # add to mst
            if not mst.does_vertex_exist(u.get_key()):
                mst.add_vertex(u.get_key())
            if not mst.does_vertex_exist(v.get_key()):
                mst.add_vertex(v.get_key())
            mst.add_edge(u.get_key(), v.get_key(), u.get_weight(v))
            mst.add_edge(v.get_key(), u.get_key(), u.get_weight(v))

            # merge components of u and v
            for w in g:
                if component[w] == component[v]:
                    component[w] = component[u]

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_krusal(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Johnsons Algorithm
================================ EOPN
Python Program to Implement Johnsons Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 3 8
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 1
1 to 3 distance -3
1 to 4 distance 2
1 to 5 distance -4
2 to 1 distance 3
2 to 2 distance 0
2 to 3 distance -4
2 to 4 distance 1
2 to 5 distance -1
3 to 1 distance 7
3 to 2 distance 4
3 to 3 distance 0
3 to 4 distance 5
3 to 5 distance 3
4 to 1 distance 2
4 to 2 distance -1
4 to 3 distance -5
4 to 4 distance 0
4 to 5 distance -2
5 to 1 distance 8
5 to 2 distance 5
5 to 3 distance 1
5 to 4 distance 6
5 to 5 distance 0
What would you like to do? quit

Case 2:
python 226__graph_johnson.py
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance inf
2 to 1 distance inf
2 to 2 distance 0
What would you like to do? add edge 1 2 100
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 -50
What would you like to do? add edge 1 3 60
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 100
1 to 3 distance 50
2 to 1 distance inf
2 to 2 distance 0
2 to 3 distance -50
3 to 1 distance inf
3 to 2 distance inf
3 to 3 distance 0
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def set_weight(self, dest, weight):
        """Set weight of edge from this vertex to dest."""
        self.points_to[dest] = weight

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def johnson(g):
    """Return distance where distance[u][v] is the min distance from u to v.

    distance[u][v] is the shortest distance from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    # add new vertex q
    g.add_vertex('q')
    # let q point to all other vertices in g with zero-weight edges
    for v in g:
        g.add_edge('q', v.get_key(), 0)

    # compute shortest distance from vertex q to all other vertices
    bell_dist = bellman_ford(g, g.get_vertex('q'))

    # set weight(u, v) = weight(u, v) + bell_dist(u) - bell_dist(v) for each
    # edge (u, v)
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[v] - bell_dist[n])

    # remove vertex q
    # This implementation of the graph stores edge (u, v) in Vertex object u
    # Since no other vertex points back to q, we do not need to worry about
    # removing edges pointing to q from other vertices.
    del g.vertices['q']

    # distance[u][v] will hold smallest distance from vertex u to v
    distance = {}
    # run dijkstra's algorithm on each source vertex
    for v in g:
        distance[v] = dijkstra(g, v)

    # correct distances
    for v in g:
        for w in g:
            distance[v][w] += bell_dist[w] - bell_dist[v]

    # correct weights in original graph
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[n] - bell_dist[v])

    return distance


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('johnson')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'johnson':
        distance = johnson(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                print('{} to {}'.format(start.get_key(), end.get_key()), end=' ')
                print('distance {}'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dequeue
================================ EOPN
Python Program to Implement Dequeue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 3
What would you like to do? append 4
What would you like to do? appendleft 2
What would you like to do? appendleft 1
What would you like to do? pop
Popped value from right:  4
What would you like to do? popleft
Popped value from left:  1
What would you like to do? pop
Popped value from right:  3
What would you like to do? popleft
Popped value from left:  2
What would you like to do? pop
Dequeue is empty.
What would you like to do? quit

Case 2:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? pop
Popped value from right:  2
What would you like to do? pop
Popped value from right:  1
What would you like to do? appendleft 1
What would you like to do? appendleft 2
What would you like to do? pop
Popped value from right:  1
What would you like to do? pop
Popped value from right:  2
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? popleft
Popped value from left:  1
What would you like to do? popleft
Popped value from left:  2
What would you like to do? quit
--------------------------------
class Dequeue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def append(self, data):
        self.items.append(data)

    def append_left(self, data):
        self.items.insert(0, data)

    def pop(self):
        return self.items.pop()

    def pop_left(self):
        return self.items.pop(0)


q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queues using Stacks
================================ EOPN
Python Program to Implement Queues using Stacks
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? enqueue 8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 2
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  1
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.inbox = Stack()
        self.outbox = Stack()

    def is_empty(self):
        return (self.inbox.is_empty() and self.outbox.is_empty())

    def enqueue(self, data):
        self.inbox.push(data)

    def dequeue(self):
        if self.outbox.is_empty():
            while not self.inbox.is_empty():
                popped = self.inbox.pop()
                self.outbox.push(popped)
        return self.outbox.pop()


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if a_queue.is_empty():
            print('Queue is empty.')
        else:
            dequeued = a_queue.dequeue()
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check String is Palindrome using Stack
================================ EOPN
Python Program to Check String is Palindrome using Stack
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the string: madam
The string is a palindrome.

Case 2:
Please enter the string: racecar
The string is a palindrome.

Case 3:
Please enter the string: palace
The string is not a palindrome.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
text = input('Please enter the string: ')

for character in text:
    s.push(character)

reversed_text = ''
while not s.is_empty():
    reversed_text = reversed_text + s.pop()

if text == reversed_text:
    print('The string is a palindrome.')
else:
    print('The string is not a palindrome.')
 ETP  
 
Python Program to Check if Expression is correctly Parenthesized
================================ EOPN
Python Program to Check if Expression is correctly Parenthesized
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the expression: (3 + 4 * (1 + (2))/(7 * (8 + 9)))
Expression is correctly parenthesized.

Case 2:
Please enter the expression: (a + b))(3)
Expression is not correctly parenthesized.

Case 3:
Please enter the expression: (4 + (3 * 2)
Expression is not correctly parenthesized.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
exp = input('Please enter the expression: ')

for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False

if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')
 ETP  
 
Python Program to Implement Linear Search
================================ EOPN
Python Program to Implement Linear Search
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 4 3 2 1 10 11 2
The number to search for: 1
1 was found at index 4.

Case 2:
Enter the list of numbers: 5 2 1 5 -3
The number to search for: 2
2 was found at index 1.

Case 3:
Enter the list of numbers: 3 5 6
The number to search for: 2
2 was not found.
--------------------------------
def linear_search(alist, key):
    """Return index of key in alist. Return -1 if key not present."""
    for i in range(len(alist)):
        if alist[i] == key:
            return i
    return -1


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = linear_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search without Recursion
================================ EOPN
Python Program to Implement Binary Search without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 3 5 10 12 15 20
The number to search for: 12
12 was found at index 3.

Case 2:
Enter the sorted list of numbers: -3 0 1 5 6 7 8
The number to search for: 2
2 was not found.

Case 3:
Enter the sorted list of numbers: 5
The number to search for: 5
5 was found at index 0.
--------------------------------
def binary_search(alist, key):
    """Search key in alist[start... end - 1]."""
    start = 0
    end = len(alist)
    while start < end:
        mid = (start + end)//2
        if alist[mid] > key:
            end = mid
        elif alist[mid] < key:
            start = mid + 1
        else:
            return mid
    return -1


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search with Recursion
================================ EOPN
Python Program to Implement Binary Search with Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 4 5 6 7 8 9 10
The number to search for: 9
9 was found at index 5.

Case 2:
Enter the sorted list of numbers: 3 4 5 10
The number to search for: 8
8 was not found.

Case 3:
Enter the sorted list of numbers: 7
The number to search for: 7
7 was found at index 0.
--------------------------------
def binary_search(alist, start, end, key):
    """Search key in alist[start... end - 1]."""
    if not start < end:
        return -1

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, mid + 1, end, key)
    elif alist[mid] > key:
        return binary_search(alist, start, mid, key)
    else:
        return mid


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, 0, len(alist), key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 10 2 -1 0 2
The ith smallest element will be found. Enter i: 2
Result: 0.

Case 2:
Enter the list of numbers: 7
The ith smallest element will be found. Enter i: 1
Result: 7.

Case 3:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 5.
--------------------------------
def select(alist, start, end, i):
    """Find ith smallest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[start... pivot]
    k = pivot - start + 1

    if i < k:
        return select(alist, start, pivot, i)
    elif i > k:
        return select(alist, pivot + 1, end, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 10 7 2 -2
The ith smallest element will be found. Enter i: 2
Result: 7.

Case 2:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 1.

Case 3:
Enter the list of numbers: 3
The ith smallest element will be found. Enter i: 1
Result: 3.
--------------------------------
def select(alist, start, end, i):
    """Find ith largest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[pivot... end - 1]
    k = end - pivot

    if i < k:
        return select(alist, pivot + 1, end, i)
    elif i > k:
        return select(alist, start, pivot, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Implement Bubble Sort 
================================ EOPN
Python Program to Implement Bubble Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 38 10 5
Sorted list: [2, 4, 5, 10, 38]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7 3 1 -5 2 10
Sorted list: [-5, 1, 2, 3, 7, 10]
--------------------------------
def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Selection Sort
================================ EOPN
Python Program to Implement Selection Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 4 5 2 6
Sorted list: [1, 2, 3, 4, 5, 6]

Case 2:
Enter the list of numbers: 2 10 5 38 1 7
Sorted list: [1, 2, 5, 7, 10, 38]

Case 3:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]
--------------------------------
def selection_sort(alist):
    for i in range(0, len(alist) - 1):
        smallest = i
        for j in range(i + 1, len(alist)):
            if alist[j] < alist[smallest]:
                smallest = j
        alist[i], alist[smallest] = alist[smallest], alist[i]


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
selection_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Insertion Sort
================================ EOPN
Python Program to Implement Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 4 1 5 8 0
Sorted list: [0, 1, 2, 4, 5, 8]

Case 2:
Enter the list of numbers: 5 4 3 2 0 -1
Sorted list: [-1, 0, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3 4 1 4 5 0 7
Sorted list: [0, 1, 3, 4, 4, 5, 7]
--------------------------------
def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Merge Sort
================================ EOPN
Python Program to Implement Merge Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 8 2 5 1 3
Sorted list: [1, 1, 2, 3, 3, 5, 5, 8]

Case 2:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)

def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Quicksort
================================ EOPN
Python Program to Implement Quicksort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 8 10 3 0 4
Sorted list: [0, 2, 3, 4, 5, 8, 10]

Case 2:
Enter the list of numbers: 7 4 3 2 1
Sorted list: [1, 2, 3, 4, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def quicksort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        p = partition(alist, start, end)
        quicksort(alist, start, p)
        quicksort(alist, p + 1, end)


def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
quicksort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Heapsort
================================ EOPN
Python Program to Implement Heapsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 2 2 1 0 -2 5 7
Sorted list: [-2, 0, 1, 2, 2, 3, 5, 7]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def heapsort(alist):
    build_max_heap(alist)
    for i in range(len(alist) - 1, 0, -1):
        alist[0], alist[i] = alist[i], alist[0]
        max_heapify(alist, index=0, size=i)

def parent(i):
    return (i - 1)//2

def left(i):
    return 2*i + 1

def right(i):
    return 2*i + 2

def build_max_heap(alist):
    length = len(alist)
    start = parent(length - 1)
    while start >= 0:
        max_heapify(alist, index=start, size=length)
        start = start - 1

def max_heapify(alist, index, size):
    l = left(index)
    r = right(index)
    if (l < size and alist[l] > alist[index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[r] > alist[largest]):
        largest = r
    if (largest != index):
        alist[largest], alist[index] = alist[index], alist[largest]
        max_heapify(alist, largest, size)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
heapsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Counting Sort
================================ EOPN
Python Program to Implement Counting Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 4 1 3 6 1 8
Sorted list: [1, 1, 1, 2, 3, 4, 6, 8]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 4 3 2
Sorted list: [2, 3, 4, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 1
Sorted list: [1]
--------------------------------
def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)

    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1

    return result


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
 Python Program to Implement Radix Sort 
================================ EOPN
 Python Program to Implement Radix Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 38 20 1 3 4 0 2 5 1 3 8 2 9 10
Sorted list: [0, 1, 1, 2, 2, 3, 3, 4, 5, 8, 9, 10, 20, 38]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 3
Sorted list: [3]
--------------------------------
def radix_sort(alist, base=10):
    if alist == []:
        return

    def key_factory(digit, base):
        def key(alist, index):
            return ((alist[index]//(base**digit)) % base)
        return key
    largest = max(alist)
    exp = 0
    while base**exp <= largest:
        alist = counting_sort(alist, base - 1, key_factory(exp, base))
        exp = exp + 1
    return alist

def counting_sort(alist, largest, key):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[key(alist, i)] = c[key(alist, i)] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)
    for i in range(len(alist) - 1, -1, -1):
        result[c[key(alist, i)]] = alist[i]
        c[key(alist, i)] = c[key(alist, i)] - 1

    return result

alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = radix_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Bucket Sort
================================ EOPN
Python Program to Implement Bucket Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 5 10 3 5 7
Sorted list: [1, 2, 3, 5, 5, 7, 10]

Case 2:
Enter the list of (nonnegative) numbers: 8 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7, 8]

Case 3:
Enter the list of (nonnegative) numbers: 5
Sorted list: [5]
--------------------------------
def bucket_sort(alist):
    largest = max(alist)
    length = len(alist)
    size = largest/length

    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(alist[i]/size)
        if j != length:
            buckets[j].append(alist[i])
        else:
            buckets[length - 1].append(alist[i])

    for i in range(length):
        insertion_sort(buckets[i])

    result = []
    for i in range(length):
        result = result + buckets[i]

    return result

def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = bucket_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Gnome Sort
================================ EOPN
Python Program to Implement Gnome Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 3 2 51 38 1 10 3 0 7 8
Sorted list: [0, 1, 2, 2, 3, 3, 7, 8, 10, 38, 51]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7
Sorted list: [7]
--------------------------------
def gnome_sort(alist):
    for pos in range(1, len(alist)):
        while (pos != 0 and alist[pos] < alist[pos - 1]):
            alist[pos], alist[pos - 1] = alist[pos - 1], alist[pos]
            pos = pos - 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
gnome_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Cocktail Shaker Sort
================================ EOPN
Python Program to Implement Cocktail Shaker Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 18 5 2 10 0 7 4
Sorted list: [0, 2, 3, 4, 5, 7, 10, 18]

Case 2:
Enter the list of numbers: 6 5 4 3 2
Sorted list: [2, 3, 4, 5, 6]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def cocktail_shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    upper = len(alist) - 1
    lower = 0

    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1

        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
cocktail_shaker_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Comb Sort
================================ EOPN
Python Program to Implement Comb Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 8 4 3 7 10 23 4 5
Sorted list: [2, 3, 4, 4, 5, 7, 8, 10, 23]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3
Sorted list: [3]
--------------------------------
def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    gap = len(alist)
    shrink = 1.3

    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)

        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False

        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Shell Sort
================================ EOPN
Python Program to Implement Shell Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 3 1 10
Sorted list: [1, 2, 3, 5, 10]

Case 2:
Enter the list of numbers: 7 6 5 4
Sorted list: [4, 5, 6, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def gaps(size):
    # uses the gap sequence 2^k - 1: 1, 3, 7, 15, 31, ...
    length = size.bit_length()
    for k in range(length - 1, 0, -1):
        yield 2**k - 1


def shell_sort(alist):
    def insertion_sort_with_gap(gap):
        for i in range(gap, len(alist)):
            temp = alist[i]
            j = i - gap
            while (j >= 0 and temp < alist[j]):
                alist[j + gap] = alist[j]
                j = j - gap
            alist[j + gap] = temp

    for g in gaps(len(alist)):
        insertion_sort_with_gap(g)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
shell_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Introsort
================================ EOPN
Python Program to Implement Introsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 2 3 10 9 3 7 2 1 0 9
Sorted list: [0, 1, 2, 2, 3, 3, 3, 5, 7, 9, 9, 10]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 5
Sorted list: [5]
--------------------------------
def introsort(alist):
    maxdepth = (len(alist).bit_length() - 1)*2
    introsort_helper(alist, 0, len(alist), maxdepth)

def introsort_helper(alist, start, end, maxdepth):
    if end - start <= 1:
        return
    elif maxdepth == 0:
        heapsort(alist, start, end)
    else:
        p = partition(alist, start, end)
        introsort_helper(alist, start, p + 1, maxdepth - 1)
        introsort_helper(alist, p + 1, end, maxdepth - 1)

def partition(alist, start, end):
    pivot = alist[start]
    i = start - 1
    j = end

    while True:
        i = i + 1
        while alist[i] < pivot:
            i = i + 1
        j = j - 1
        while alist[j] > pivot:
            j = j - 1

        if i >= j:
            return j

        swap(alist, i, j)

def swap(alist, i, j):
    alist[i], alist[j] = alist[j], alist[i]

def heapsort(alist, start, end):
    build_max_heap(alist, start, end)
    for i in range(end - 1, start, -1):
        swap(alist, start, i)
        max_heapify(alist, index=0, start=start, end=i)

def build_max_heap(alist, start, end):
    def parent(i):
        return (i - 1)//2
    length = end - start
    index = parent(length - 1)
    while index >= 0:
        max_heapify(alist, index, start, end)
        index = index - 1

def max_heapify(alist, index, start, end):
    def left(i):
        return 2*i + 1
    def right(i):
        return 2*i + 2

    size = end - start
    l = left(index)
    r = right(index)
    if (l < size and alist[start + l] > alist[start + index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[start + r] > alist[start + largest]):
        largest = r
    if largest != index:
        swap(alist, start + largest, start + index)
        max_heapify(alist, largest, start, end)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
introsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Binary Insertion Sort
================================ EOPN
Python Program to Implement Binary Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 7 10 3 5 2 1 8 9
Sorted list: [1, 2, 2, 3, 5, 5, 7, 8, 9, 10]

Case 2:
Enter the list of numbers: 7 5 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5, 5, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def binary_insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        pos = binary_search(alist, temp, 0, i) + 1

        for k in range(i, pos, -1):
            alist[k] = alist[k - 1]

        alist[pos] = temp

def binary_search(alist, key, start, end):
    '''If key is in the list at index p, then return p.
    If there are multiple such keys in the list, then return the index of any one.
    If key is not in the list and a < key < b where a and b are elements in the list, then return the index of a.
    If key is not in the list and key < a where a is the first element in the list, then return -1.
    Only elements with indexes start to end - 1 inclusive are considered.
    '''
    if end - start <= 1:
        if key < alist[start]:
            return start - 1
        else:
            return start

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, key, mid, end)
    elif alist[mid] > key:
        return binary_search(alist, key, start, mid)
    else:
        return mid


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
binary_insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Sort using a Binary Search Tree
================================ EOPN
Python Program to Sort using a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 3 4 5 6 1 7 9 10 3
Sorted list: 1 2 3 3 4 4 5 6 7 9 10 

Case 2:
Enter the list of numbers: 6 5 4 3 2 1
Sorted list: 1 2 3 4 5 6 

Case 3:
Enter the list of numbers: 5
Sorted list: 5
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key <= node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)


bstree = BSTree()

alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
for x in alist:
    bstree.add(x)
print('Sorted list: ', end='')
bstree.inorder()
 ETP  
 
Python Program for Depth First Binary Tree Search using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 5
What would you like to do? insert 7 right of 5
What would you like to do? dfs
depth-first search traversal:
entering 1...
entering 2...
entering 4...
at 4...
leaving 4...
at 2...
entering 5...
entering 6...
at 6...
leaving 6...
at 5...
entering 7...
at 7...
leaving 7...
leaving 5...
leaving 2...
at 1...
entering 3...
at 3...
leaving 3...
leaving 1...

What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 4 left of 3
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 4
What would you like to do? dfs
depth-first search traversal:
entering 3...
entering 4...
entering 6...
at 6...
leaving 6...
at 4...
leaving 4...
at 3...
entering 5...
at 5...
leaving 5...
leaving 3...

What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def depth_first(self):
        print('entering {}...'.format(self.key))
        if self.left is not None:
            self.left.depth_first()
        print('at {}...'.format(self.key))
        if self.right is not None:
            self.right.depth_first()
        print('leaving {}...'.format(self.key))


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('depth-first search traversal:')
        if btree is not None:
            btree.depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? dfs
pre-order dfs traversal: 1 2 4 5 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? insert 8 left of 7
What would you like to do? insert 10 right of 7
What would you like to do? dfs
pre-order dfs traversal: 3 6 7 8 10 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def preorder_depth_first(self):
        s = Stack()
        s.push(self)
        while (not s.is_empty()):
            node = s.pop()
            print(node.key, end=' ')
            if node.right is not None:
                s.push(node.right)
            if node.left is not None:
                s.push(node.left)


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


btree = BinaryTree()

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('pre-order dfs traversal: ', end='')
        if btree is not None:
            btree.preorder_depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOPN
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? inorder 1
nth term of inorder traversal: 2
What would you like to do? inorder 2
nth term of inorder traversal: 1
What would you like to do? inorder 3
nth term of inorder traversal: 3
What would you like to do? inorder 4
index exceeds maximum possible index.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 3 left of 1
What would you like to do? insert 7 right of 1
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 5
What would you like to do? inorder 1
nth term of inorder traversal: 3
What would you like to do? inorder 2
nth term of inorder traversal: 6
What would you like to do? inorder 3
nth term of inorder traversal: 5
What would you like to do? inorder 4
nth term of inorder traversal: 1
What would you like to do? inorder 5
nth term of inorder traversal: 7
What would you like to do? inorder 6
index exceeds maximum possible index.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_nth(self, n):
        return self.inorder_nth_helper(n, [])

    def inorder_nth_helper(self, n, inord):
        if self.left is not None:
            temp = self.left.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp
        inord.append(self)
        if n == len(inord):
            return self
        if self.right is not None:
            temp = self.right.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('inorder <index>')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'inorder':
        if btree is not None:
            index = int(do[1].strip().lower())
            node = btree.inorder_nth(index)
            if node is not None:
                print('nth term of inorder traversal: {}'.format(node.key))
            else:
                print('index exceeds maximum possible index.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOPN
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 1 at rot
What would you like to do? largest
Largest element: 1
What would you like to do? insert 2 left of 1
What would you like to do? largest
Largest element: 2
What would you like to do? insert 3 right of 1
What would you like to do? largest
Largest element: 3
What would you like to do? insert 10 left of 3
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 3 at root
What would you like to do? insert 5 left of 3
What would you like to do? insert 2 right of 3
What would you like to do? largest
Largest element: 5
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_largest(self):
        # largest will be a single element list
        # this is a workaround to reference an integer
        largest = []
        self.inorder_largest_helper(largest)
        return largest[0]

    def inorder_largest_helper(self, largest):
        if self.left is not None:
            self.left.inorder_largest_helper(largest)
        if largest == []:
            largest.append(self.key)
        elif largest[0] < self.key:
            largest[0] = self.key
        if self.right is not None:
            self.right.inorder_largest_helper(largest)

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'largest':
        if btree is None:
            print('Tree is empty.')
        else:
            print('Largest element: {}'.format(btree.inorder_largest()))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOPN
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 2
What would you like to do? add 5 below 1
What would you like to do? add 6 below 1
What would you like to do? dfs
Post-order traversal: 3 4 2 5 6 1 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 3 at root
What would you like to do? add 5 below 3
What would you like to do? add 2 below 3
What would you like to do? add 1 below 5
What would you like to do? add 6 below 5
What would you like to do? dfs
Post-order traversal: 1 6 5 2 3 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def postorder(self):
        for child in self.children:
            child.postorder()
        print(self.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'dfs':
        print('Post-order traversal: ', end='')
        tree.postorder()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOPN
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 left of 3
What would you like to do? insert 6 right of 3
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 4 5 6 
BFS traversal of mirror: 
1 3 2 6 5 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 
BFS traversal of mirror: 
1 
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 
BFS traversal of mirror: 
1 3 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def mirror_copy(self):
        mirror = BinaryTree(self.key)
        if self.right is not None:
            mirror.left = self.right.mirror_copy()
        if self.left is not None:
            mirror.right = self.left.mirror_copy()
        return mirror

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            if popped.left is not None:
                queue.append(popped.left)
            if popped.right is not None:
                queue.append(popped.right)
            print(popped.key, end=' ')


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('mirror')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'mirror':
        if btree is not None:
            print('Creating mirror copy...')
            mirror = btree.mirror_copy()
            print('BFS traversal of original tree: ')
            btree.bfs()
            print()
            print('BFS traversal of mirror: ')
            mirror.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOPN
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOKW
--------------------------------
output:
Case 1:
Input post-order traversal: 4 5 2 8 6 7 3 1
Input in-order traversal: 4 2 5 1 6 8 3 7
Binary tree constructed.
Verifying:
Post-order traversal: 4 5 2 8 6 7 3 1 
In-order traversal: 4 2 5 1 6 8 3 7 

Case 2:
Input post-order traversal: 2 1 3
Input in-order traversal: 2 3 1
Binary tree constructed.
Verifying:
Post-order traversal: 2 1 3 
In-order traversal: 2 3 1
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def postorder(self):
        if self.left is not None:
            self.left.postorder()
        if self.right is not None:
            self.right.postorder()
        print(self.key, end=' ')


def construct_btree(postord, inord):
    if postord == [] or inord == []:
        return None
    key = postord[-1]
    node = BinaryTree(key)
    index = inord.index(key)
    node.left = construct_btree(postord[:index], inord[:index])
    node.right = construct_btree(postord[index:-1], inord[index + 1:])
    return node


postord = input('Input post-order traversal: ').split()
postord = [int(x) for x in postord]
inord = input('Input in-order traversal: ').split()
inord = [int(x) for x in inord]

btree = construct_btree(postord, inord)
print('Binary tree constructed.')
print('Verifying:')
print('Post-order traversal: ', end='')
btree.postorder()
print()
print('In-order traversal: ', end='')
btree.inorder()
print()
 ETP  
 
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOPN
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 5
What would you like to do? add 1
What would you like to do? add 10
What would you like to do? add 7
What would you like to do? add 3
What would you like to do? inorder
Inorder traversal: 1 3 5 7 10 
What would you like to do? remove 3
What would you like to do? remove 7
What would you like to do? inorder
Inorder traversal: 1 5 10 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 1 10 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 2
What would you like to do? add 8
What would you like to do? inorder
Inorder traversal: 2 8 
What would you like to do? add 5
What would you like to do? inorder
Inorder traversal: 2 5 8 
What would you like to do? remove 2
What would you like to do? remove 8
What would you like to do? inorder
Inorder traversal: 5 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def replace_node_of_parent(self, new_node):
        if self.parent is not None:
            if new_node is not None:
                new_node.parent = self.parent
            if self.parent.left == self:
                self.parent.left = new_node
            elif self.parent.right == self:
                self.parent.right = new_node
        else:
            self.key = new_node.key
            self.left = new_node.left
            self.right = new_node.right
            if new_node.left is not None:
                new_node.left.parent = self
            if new_node.right is not None:
                new_node.right.parent = self

    def find_min(self):
        current = self
        while current.left is not None:
            current = current.left
        return current

    def remove(self):
        if (self.left is not None and self.right is not None):
            successor = self.right.find_min()
            self.key = successor.key
            successor.remove()
        elif self.left is not None:
            self.replace_node_of_parent(self.left)
        elif self.right is not None:
            self.replace_node_of_parent(self.right)
        else:
            self.replace_node_of_parent(None)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def remove(self, key):
        to_remove = self.search(key)
        if (self.root == to_remove
            and self.root.left is None and self.root.right is None):
            self.root = None
        else:
            to_remove.remove()

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('remove <key>')
print('inorder')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    elif operation == 'remove':
        key = int(do[1])
        bstree.remove(key)
    elif operation == 'inorder':
        print('Inorder traversal: ', end='')
        bstree.inorder()
        print()
    elif operation == 'quit':
        break
 ETP  
 
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOPN
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 3
What would you like to do? add 2
What would you like to do? add 10
What would you like to do? add 4
What would you like to do? smallest
Smallest element: 2
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 10
What would you like to do? smallest
Smallest element: 10
What would you like to do? largest
Largest element: 10
What would you like to do? add 4
What would you like to do? add 12
What would you like to do? smallest
Smallest element: 4
What would you like to do? largest
Largest element: 12
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)

    def get_smallest(self):
        if self.root is not None:
            current = self.root
            while current.left is not None:
                current = current.left
            return current.key

    def get_largest(self):
        if self.root is not None:
            current = self.root
            while current.right is not None:
                current = current.right
            return current.key


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('smallest')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    if operation == 'smallest':
        smallest = bstree.get_smallest()
        print('Smallest element: {}'.format(smallest))
    if operation == 'largest':
        largest = bstree.get_largest()
        print('Largest element: {}'.format(largest))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Leaf Node in a Tree
================================ EOPN
Python Program to Count Number of Leaf Node in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of leaf nodes: 2
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 2 at root
What would you like to do? add 7 below 2
What would you like to do? add 8 below 7
What would you like to do? add 9 below 8
What would you like to do? count
Number of leaf nodes: 1
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_leaf_nodes(self):
        leaf_nodes = []
        self.count_leaf_nodes_helper(leaf_nodes)
        return len(leaf_nodes)

    def count_leaf_nodes_helper(self, leaf_nodes):
        if self.children == []:
            leaf_nodes.append(self)
        else:
            for child in self.children:
                child.count_leaf_nodes_helper(leaf_nodes)


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_leaf_nodes()
            print('Number of leaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 right of 2
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? count
Number of nodes in tree: 4
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? count
Number of nodes in tree: 0
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? count
Number of nodes in tree: 1
inorder traversal of binary tree: 1 
What would you like to do? insert 2 right of 1
inorder traversal of binary tree: 1 2 
What would you like to do? count
Number of nodes in tree: 2
inorder traversal of binary tree: 1 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def count_nodes(node):
    if node is None:
        return 0
    return 1 + count_nodes(node.left) + count_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('count')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'count':
        print('Number of nodes in tree: {}'.format(count_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOPN
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? border
Border of tree: 
1 2 3 
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? border
Border of tree: 
1 2 4 5 6 7 3 
What would you like to do? insert 8 left of 4
What would you like to do? insert 9 right of 4
What would you like to do? insert 10 left of 5
What would you like to do? insert 11 right of 5
What would you like to do? insert 12 left of 6
What would you like to do? insert 13 right of 6
What would you like to do? insert 14 left of 7
What would you like to do? insert 15 right of 7
What would you like to do? border
Border of tree: 
1 2 4 8 9 10 11 12 13 14 15 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 left of 2
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? insert 6 right of 4
What would you like to do? insert 7 right of 1
What would you like to do? insert 8 right of 7
What would you like to do? border
Border of tree: 
1 2 3 5 6 8 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left_boundary(self):
        current = self
        while True:
            if current.left is not None:
                print(current.key, end=' ')
                current = current.left
            elif current.right is not None:
                print(current.key, end=' ')
                current = current.right
            else:
                break

    def print_right_boundary(self):
        if self.right is not None:
            self.right.print_right_boundary()
            print(self.key, end=' ')
        elif self.left is not None:
            self.left.print_right_boundary()
            print(self.key, end=' ')


    def print_leaves(self):
        if self.left is not None:
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
        if (self.left is None
            and self.right is None):
            print(self.key, end=' ')

    def print_border(self):
        print(self.key, end=' ')
        if self.left is not None:
            self.left.print_left_boundary()
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
            self.right.print_right_boundary()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('border')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'border':
        if btree is not None:
            print('Border of tree: ')
            btree.print_border()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOPN
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? count
Number of nonleaf nodes: 0
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of nonleaf nodes: 1
What would you like to do? add 4 below 2
What would you like to do? count
Number of nonleaf nodes: 2
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 3
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 3
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 6 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 7 below 6
What would you like to do? count
Number of nonleaf nodes: 5
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_nonleaf_nodes(self):
        nonleaf_count = 0
        if self.children != []:
            nonleaf_count = 1
        for child in self.children:
            nonleaf_count = nonleaf_count + child.count_nonleaf_nodes()
        return nonleaf_count


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_nonleaf_nodes()
            print('Number of nonleaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of all Nodes in a Tree
================================ EOPN
Python Program to Find the Sum of all Nodes in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? sum
Tree is empty.
What would you like to do? add 3 at root
What would you like to do? sum
Sum of all nodes: 3
What would you like to do? add 4 below 3
What would you like to do? sum
Sum of all nodes: 7
What would you like to do? add 5 below 3
What would you like to do? add 10 below 4
What would you like to do? sum
Sum of all nodes: 22
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 1
What would you like to do? add 5 below 2
What would you like to do? add 6 below 3
What would you like to do? add 7 below 4
What would you like to do? sum
Sum of all nodes: 28
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def sum_nodes(self):
        summation = self.key
        for child in self.children:
            summation = summation + child.sum_nodes()
        return summation


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('sum')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'sum':
        if tree is None:
            print('Tree is empty.')
        else:
            summation = tree.sum_nodes()
            print('Sum of all nodes: {}'.format(summation))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOPN
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 2
What would you like to do? add 5 below 2
What would you like to do? display
BFS traversal display: 1 2 3 4 5 
What would you like to do? remove 1
What would you like to do? display
BFS traversal display: 4 2 3 5 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 4 2 3 
What would you like to do? remove 4
What would you like to do? display
BFS traversal display: 2 3 
What would you like to do? remove 3
What would you like to do? remove 2
What would you like to do? display
Tree is empty.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 9 below 7
What would you like to do? add 11 below 9
What would you like to do? add 12 below 7
What would you like to do? display
BFS traversal display: 5 7 9 12 11 
What would you like to do? remove 9
What would you like to do? display
BFS traversal display: 5 7 11 12 
What would you like to do? remove 12
What would you like to do? display
BFS traversal display: 5 7 11 
What would you like to do? remove 7
What would you like to do? display
BFS traversal display: 5 11 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 11 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None, parent=None):
        self.key = data
        self.children = []
        self.parent = parent

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def remove(self):
        parent = self.parent
        index = parent.children.index(self)
        parent.children.remove(self)
        for child in reversed(self.children):
            parent.children.insert(index, child)
            child.parent = parent

    def bfs_display(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('remove <data>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            new_node.parent = ref_node
            ref_node.add(new_node)

    elif operation == 'remove':
        data = int(do[1])
        to_remove = tree.search(data)
        if tree == to_remove:
            if tree.children == []:
                tree = None
            else:
                leaf = tree.children[0]
                while leaf.children != []:
                    leaf = leaf.children[0]
                leaf.parent.children.remove(leaf)
                leaf.parent = None
                leaf.children = tree.children
                tree = leaf
        else:
            to_remove.remove()

    elif operation == 'display':
        if tree is not None:
            print('BFS traversal display: ', end='')
            tree.bfs_display()
            print()
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOPN
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 1 at root
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 0 left of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 2 right of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 3 left of 2
What would you like to do? bst
Tree is not a binary search tree.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 5 at root
What would you like to do? insert 1 left of 5
What would you like to do? insert 10 right of 5
What would you like to do? insert 0 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 15 right of 10
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def is_bst_p(self):
        if self.left is not None:
            if self.key < self.left.key:
                return False
            elif not self.left.is_bst_p():
                return False
        if self.right is not None:
            if self.key > self.right.key:
                return False
            elif not self.right.is_bst_p():
                return False
        return True


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('bst')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'bst':
        if btree is not None:
            if btree.is_bst_p():
                print('Tree is a binary search tree.')
            else:
                print('Tree is not a binary search tree.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOPN
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? paths
Tree is empty.
What would you like to do? add 1 at root
What would you like to do? paths
1 
What would you like to do? add 2 below 1
What would you like to do? paths
1 2 
What would you like to do? add 3 below 1
What would you like to do? paths
1 2 
1 3 
What would you like to do? add 4 below 1
What would you like to do? paths
1 2 
1 3 
1 4 
What would you like to do? add 8 below 2
What would you like to do? paths
1 2 8 
1 3 
1 4 
What would you like to do? add 7 below 2
What would you like to do? paths
1 2 8 
1 2 7 
1 3 
1 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? add 1 at root
What would you like to do? add 10 below 1
What would you like to do? add 11 below 10
What would you like to do? add 12 below 11
What would you like to do? add 20 below 1
What would you like to do? add 21 below 20
What would you like to do? add 30 below 1
What would you like to do? paths
1 10 11 12 
1 20 21 
1 30 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def print_all_paths_to_leaf(self):
        self.print_all_paths_to_leaf_helper([])

    def print_all_paths_to_leaf_helper(self, path_till_now):
        path_till_now.append(self.key)
        if self.children == []:
            for key in path_till_now:
                print(key, end=' ')
            print()
        else:
            for child in self.children:
                child.print_all_paths_to_leaf_helper(path_till_now[:])


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('paths')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'paths':
        if tree is None:
            print('Tree is empty.')
        else:
            tree.print_all_paths_to_leaf()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print only Nodes in Left SubTree
================================ EOPN
Python Program to Print only Nodes in Left SubTree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? left
Nodes of left subtree: 4 2 5 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 10 at root
What would you like to do? left
Nodes of left subtree: 
What would you like to do? insert 1 right of 10
What would you like to do? insert 2 left of 10
What would you like to do? insert 3 right of 2
What would you like to do? left
Nodes of left subtree: 2 3 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left(self):
        if self.left is not None:
            self.left.inorder()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('left')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'left':
        print('Nodes of left subtree: ', end='')
        if btree is not None:
            btree.print_left()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOPN
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 1 2 
What would you like to do? add 3 below 1
What would you like to do? add 10 below 2
What would you like to do? add 12 below 2
What would you like to do? add 14 below 3
What would you like to do? add 7 below 14
What would you like to do? bfs
BFS traversal: 1 2 3 10 12 14 7 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 8 below 5
What would you like to do? add 4 below 7
What would you like to do? add 3 below 7
What would you like to do? add 1 below 8
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 5 7 8 4 3 1 2 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('bfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'bfs':
        if tree is None:
            print('Tree is empty.')
        else:
            print('BFS traversal: ', end='')
            tree.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 7 left of 3
inorder traversal of binary tree: 7 3 
What would you like to do? sum
Sum of nodes in tree: 10
inorder traversal of binary tree: 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 2 at root
inorder traversal of binary tree: 2 
What would you like to do? insert 10 left of 2
inorder traversal of binary tree: 10 2 
What would you like to do? insert 1 right of 2
inorder traversal of binary tree: 10 2 1 
What would you like to do? insert 5 left of 1
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? sum
Sum of nodes in tree: 18
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def sum_nodes(node):
    if node is None:
        return 0
    return node.key + sum_nodes(node.left) + sum_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('sum')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'sum':
        print('Sum of nodes in tree: {}'.format(sum_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Graph
================================ EOPN
Python Program to Implement Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? display
Vertices: 1 2 
Edges: 

What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 

What would you like to do? add edge 1 3
What would you like to do? add edge 3 1
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 
(src=1, dest=3, weight=1) 
(src=3, dest=1, weight=1) 

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 4 5
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 

What would you like to do? add edge 5 4
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 
(src=5, dest=4, weight=1) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> [weight]')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    if len(do) == 5:
                        weight = int(do[4])
                        g.add_edge(src, dest, weight)
                    else:
                        g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Breadth-First Search on a Graph
================================ EOPN
Python Program to Implement Breadth-First Search on a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add vertex 9
What would you like to do? add vertex 10
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 1 5
What would you like to do? add edge 2 6
What would you like to do? add edge 3 7
What would you like to do? add edge 3 8
What would you like to do? add edge 4 8
What would you like to do? add edge 8 10
What would you like to do? add edge 5 10
What would you like to do? add edge 6 9
What would you like to do? add edge 9 10
What would you like to do? bfs 1
Breadth-first Traversal: 1 3 2 5 7 8 6 10 9 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bfs 1
Breadth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 
What would you like to do? bfs 2
Breadth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? bfs 2
Breadth-first Traversal: 2 1 
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 3 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def display_bfs(vertex):
    """Display BFS Traversal starting at vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        print(current.get_key(), end=' ')
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('bfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'bfs':
        key = int(do[1])
        print('Breadth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_bfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1, 4]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 5 4
What would you like to do? reachable 4
All nodes reachable from 4: [4]
What would you like to do? reachable 5
All nodes reachable from 5: [4, 5]
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2, 3]
What would you like to do? reachable 3
All nodes reachable from 3: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_all_reachable_nodes(vertex):
    """Return set containing all vertices reachable from vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)
    return visited


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 5 1
What would you like to do? add edge 4 2
What would you like to do? components
Component 1: [5, 2, 4, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
Vertex already exists.
What would you like to do? components
Component 1: [2, 3, 1]
Component 2: [4]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        component[current] = label
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            component_vertices = [v.get_key() for v in component
                                  if component[v] == label]
            print('Component {}:'.format(label), component_vertices)



    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOPN
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
What would you like to do? add edge 1 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 1): 3 1
Vertex 2 (distance 1): 2 1
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? add edge 4 5
What would you like to do? add edge 4 6
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 3): 5 4 2 1
Vertex 6 (distance 3): 6 4 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? add edge 2 6
What would you like to do? add edge 1 5
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 1): 5 1
Vertex 6 (distance 2): 6 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        # dictionary containing destination vertices mapped to the weight of the
        # edge with which they are joined to this vertex
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_shortest_paths(src):
    """Returns tuple of two dictionaries: (parent, distance)

    parent contains vertices mapped to their parent vertex in the shortest
    path from src to that vertex.
    distance contains vertices mapped to their shortest distance from src.
    """
    parent = {src: None}
    distance = {src: 0}

    visited = set()
    q = Queue()
    q.enqueue(src)
    visited.add(src)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                distance[dest] = distance[current] + 1
                q.enqueue(dest)
    return (parent, distance)

g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('shortest <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        src = g.get_vertex(key)
        parent, distance = find_shortest_paths(src)

        print('Path from destination vertices to source vertex {}:'.format(key))
        for v in parent:
            print('Vertex {} (distance {}): '.format(v.get_key(), distance[v]),
                  end='')
            while parent[v] is not None:
                print(v.get_key(), end = ' ')
                v = parent[v]
            print(src.get_key()) # print source vertex

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 2 4
What would you like to do? add edge 2 5
What would you like to do? add edge 6 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 6 2
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_cycle_present(vertex, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {vertex: None}
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                q.enqueue(dest)
            else:
                if parent[current] is not dest:
                    return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 5 6
What would you like to do? add edge 6 7
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 7 1
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    visited.add(vertex)
    q = Queue()
    q.enqueue(vertex)
    while not q.is_empty():
        current = q.dequeue()

        next_colour = 1 - colour[current] # switch colour
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                colour[dest] = next_colour
                q.enqueue(dest)
            else:
                if colour[dest] != next_colour:
                    return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 3 5
What would you like to do? add edge 1 6
What would you like to do? add edge 6 2
What would you like to do? dfs 1
Depth-first Traversal: 1 6 2 3 4 5 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 1 2 
What would you like to do? dfs 2
Depth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? dfs 2
Depth-first Traversal: 2 3 4 1 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def display_dfs(v):
    """Display DFS traversal starting at vertex v."""
    display_dfs_helper(v, set())


def display_dfs_helper(v, visited):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes."""
    visited.add(v)
    print(v.get_key(), end=' ')
    for dest in v.get_neighbours():
        if dest not in visited:
            display_dfs_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? add edge 3 7
What would you like to do? dfs 1
Depth-first Traversal: 1 5 6 2 3 7 4 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


def display_dfs(v):
    visited = set()
    s = Stack()
    s.push(vertex)
    while not s.is_empty():
        current = s.pop()
        if current in visited:
            continue
        print(current.get_key(), end=' ')
        visited.add(current)
        for dest in current.get_neighbours():
            if dest not in visited:
                s.push(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print DFS Numbering of a Graph
================================ EOPN
Python Program to Print DFS Numbering of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Visiting 3... discovered time = 3
Visiting 4... discovered time = 4
Leaving 4... finished time = 5
Leaving 3... finished time = 6
Leaving 2... finished time = 7
Visiting 5... discovered time = 8
Visiting 6... discovered time = 9
Leaving 6... finished time = 10
Leaving 5... finished time = 11
Leaving 1... finished time = 12

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Leaving 1... finished time = 2

What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Leaving 2... finished time = 3
Leaving 1... finished time = 4

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to

def dfs(v, pre, post):
    """Display DFS traversal starting at vertex v. Stores pre and post times in
    dictionaries pre and post."""
    dfs_helper(v, set(), pre, post, [0])

def dfs_helper(v, visited, pre, post, time):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes, dictionaries pre and post to store
    discovered and finished times and the one-element list time to keep track of
    current time."""
    visited.add(v)
    time[0] = time[0] + 1
    pre[v] = time[0]
    print('Visiting {}... discovered time = {}'.format(v.get_key(), time[0]))
    for dest in v.get_neighbours():
        if dest not in visited:
            dfs_helper(dest, visited, pre, post, time)
    time[0] = time[0] + 1
    post[v] = time[0]
    print('Leaving {}... finished time = {}'.format(v.get_key(), time[0]))


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ')
        vertex = g.get_vertex(key)
        pre = dict()
        post = dict()
        dfs(vertex, pre, post)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 4 5
What would you like to do? add edge 5 6
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 4
All nodes reachable from 4: [6, 4, 5]
What would you like to do? reachable 7
All nodes reachable from 7: [7]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def find_all_reachable_nodes(v):
    """Return set containing all vertices reachable from vertex."""
    reachable = set()
    find_all_reachable_nodes_helper(v, reachable)
    return reachable


def find_all_reachable_nodes_helper(v, visited):
    """Add all vertices visited by DFS traversal starting at v to the set visited."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            find_all_reachable_nodes_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [2, 1]
Component 2: [3]
Component 3: [4]
Component 4: [5]
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 1 5
What would you like to do? components
Component 1: [2, 5, 1]
Component 2: [4, 3]
What would you like to do? add edge 2 4
What would you like to do? components
Component 1: [4, 2, 5, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? components
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? components
Component 1: [1]
Component 2: [2]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [1, 2]
What would you like to do? add vertex 3
What would you like to do? components
Component 1: [1, 2]
Component 2: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    label_all_reachable_helper(vertex, set(), component, label)


def label_all_reachable_helper(vertex, visited, component, label):
    """Set component[v] = label for all v in the component containing
    vertex. Uses set visited to keep track of nodes alread visited."""
    visited.add(vertex)
    component[vertex] = label
    for dest in vertex.get_neighbours():
        if dest not in visited:
            label_all_reachable_helper(dest, visited, component, label)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            print('Component {}:'.format(label),
                  [v.get_key() for v in component if component[v] == label])


    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 5 1
What would you like to do? add edge 6 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 5
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    return is_bipartite_helper(vertex, visited, colour)


def is_bipartite_helper(v, visited, colour):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited. Uses dictionary colour to keep
    track of colour of each vertex."""
    visited.add(v)
    next_colour = 1 - colour[v] # switch colour
    for dest in v.get_neighbours():
        if dest not in visited:
            colour[dest] = next_colour
            if not is_bipartite_helper(dest, visited, colour):
                return False
        else:
            if colour[dest] != next_colour:
                return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add vertex 5
What would you like to do? add edge 4 5
What would you like to do? add edge 5 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(v, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {v: None}
    return is_cycle_present_helper(v, visited, parent)


def is_cycle_present_helper(v, visited, parent):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited. Uses dictionary parent to keep
    track of parents of nodes in the DFS tree."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            parent[dest] = v
            if is_cycle_present_helper(dest, visited, parent):
                return True
        else:
            if parent[v] is not dest:
                return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 4
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 3 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(graph):
    """Return True if cycle is present in the graph."""
    on_stack = set()
    visited = set()
    for v in graph:
        if v not in visited:
            if is_cycle_present_helper(v, visited, on_stack):
                return True
    return False


def is_cycle_present_helper(v, visited, on_stack):
    """Return True if the DFS traversal starting at vertex v detects a
    cycle. Uses set visited to keep track of nodes that have been visited. Uses
    set on_stack to keep track of nodes that are 'on the stack' of the recursive
    calls."""
    if v in on_stack:
        return True
    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if is_cycle_present_helper(dest, visited, on_stack):
                return True
    on_stack.remove(v)
    visited.add(v)
    return False


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_edge_exist(v1, v2):
                    g.add_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        if is_cycle_present(g):
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOPN
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? topological
Topological Sorting: [3, 2, 1]
What would you like to do? add edge 1 2
What would you like to do? topological
Topological Sorting: [3, 1, 2]
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 4 5
What would you like to do? topological
Topological Sorting: [7, 6, 4, 5, 1, 2, 3]
What would you like to do? add edge 4 6
What would you like to do? topological
Topological Sorting: [7, 4, 5, 6, 1, 2, 3]
What would you like to do? add edge 5 7
What would you like to do? topological
Topological Sorting: [4, 5, 7, 6, 1, 2, 3]
What would you like to do? add edge 3 4
What would you like to do? topological
Topological Sorting: [1, 2, 3, 4, 5, 7, 6]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? topological
Topological Sorting: [1]
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add edge 3 2
What would you like to do? topological
Graph is not a DAG.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def get_topological_sorting(graph):
    """Return a topological sorting of the DAG. Return None if graph is not a DAG."""
    tlist = []
    visited = set()
    on_stack = set()
    for v in graph:
        if v not in visited:
            if not get_topological_sorting_helper(v, visited, on_stack, tlist):
                return None
    return tlist


def get_topological_sorting_helper(v, visited, on_stack, tlist):
    """Perform DFS traversal starting at vertex v and store a topological
    sorting of the DAG in tlist. Return False if it is found that the graph is
    not a DAG. Uses set visited to keep track of already visited nodes."""
    if v in on_stack:
        # graph has cycles and is therefore not a DAG.
        return False

    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if not get_topological_sorting_helper(dest, visited, on_stack, tlist):
                return False
    on_stack.remove(v)
    visited.add(v)
    tlist.insert(0, v.get_key()) # prepend node key to tlist
    return True


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('topological')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'topological':
        tlist = get_topological_sorting(g)
        if tlist is not None:
            print('Topological Sorting: ', end='')
            print(tlist)
        else:
            print('Graph is not a DAG.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOPN
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 80
What would you like to do? add edge 3 4 70
What would you like to do? add edge 2 5 20
What would you like to do? add edge 2 3 6
What would you like to do? add edge 5 6 50
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? shortest 1
Distances from 1: 
Distance to 6: 45
Distance to 3: 16
Distance to 4: 86
Distance to 5: 30
Distance to 2: 10
Distance to 7: 40
Distance to 1: 0

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 20
What would you like to do? add edge 3 4 30
What would you like to do? add edge 1 4 100
What would you like to do? shortest 1
Distances from 1: 
Distance to 2: 10
Distance to 4: 60
Distance to 3: 30
Distance to 1: 0
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('shortest <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = dijkstra(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Bellman-Ford Algorithm
================================ EOPN
Python Program to Implement Bellman-Ford Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 8 8
What would you like to do? add edge 2 6 2
What would you like to do? add edge 3 2 1
What would you like to do? add edge 3 4 1
What would you like to do? add edge 4 5 3
What would you like to do? add edge 5 6 -1
What would you like to do? add edge 6 3 -2
What would you like to do? add edge 7 2 -4
What would you like to do? add edge 7 6 -1
What would you like to do? add edge 8 7 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 5: 9
Distance to 6: 7
Distance to 7: 9
Distance to 2: 5
Distance to 1: 0
Distance to 8: 8
Distance to 3: 5
Distance to 4: 6

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0

What would you like to do? add vertex 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 2: inf

What would you like to do? add edge 1 2 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 3 -1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 2

What would you like to do? add edge 3 2 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 1

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('bellman-ford <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'bellman-ford':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = bellman_ford(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Floyd-Warshall Algorithm
================================ EOPN
Python Program to Implement Floyd-Warshall Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 1 3 8
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 5 -> 4 -> 3 -> 2 (distance 1)
From 1 to 3: 1 -> 5 -> 4 -> 3 (distance -3)
From 1 to 4: 1 -> 5 -> 4 (distance 2)
From 1 to 5: 1 -> 5 (distance -4)
From 2 to 1: 2 -> 4 -> 1 (distance 3)
From 2 to 3: 2 -> 4 -> 3 (distance -4)
From 2 to 4: 2 -> 4 (distance 1)
From 2 to 5: 2 -> 4 -> 1 -> 5 (distance -1)
From 3 to 1: 3 -> 2 -> 4 -> 1 (distance 7)
From 3 to 2: 3 -> 2 (distance 4)
From 3 to 4: 3 -> 2 -> 4 (distance 5)
From 3 to 5: 3 -> 2 -> 4 -> 1 -> 5 (distance 3)
From 4 to 1: 4 -> 1 (distance 2)
From 4 to 2: 4 -> 3 -> 2 (distance -1)
From 4 to 3: 4 -> 3 (distance -5)
From 4 to 5: 4 -> 1 -> 5 (distance -2)
From 5 to 1: 5 -> 4 -> 1 (distance 8)
From 5 to 2: 5 -> 4 -> 3 -> 2 (distance 5)
From 5 to 3: 5 -> 4 -> 3 (distance 1)
From 5 to 4: 5 -> 4 (distance 6)
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 -7
What would you like to do? add edge 1 3 5
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 2 (distance 10)
From 1 to 3: 1 -> 2 -> 3 (distance 3)
From 2 to 3: 2 -> 3 (distance -7)
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def floyd_warshall(g):
    """Return dictionaries distance and next_v.

    distance[u][v] is the shortest distance from vertex u to v.
    next_v[u][v] is the next vertex after vertex v in the shortest path from u
    to v. It is None if there is no path between them. next_v[u][u] should be
    None for all u.

    g is a Graph object which can have negative edge weights.
    """
    distance = {v:dict.fromkeys(g, float('inf')) for v in g}
    next_v = {v:dict.fromkeys(g, None) for v in g}

    for v in g:
        for n in v.get_neighbours():
            distance[v][n] = v.get_weight(n)
            next_v[v][n] = n

    for v in g:
         distance[v][v] = 0
         next_v[v][v] = None

    for p in g: 
        for v in g:
            for w in g:
                if distance[v][w] > distance[v][p] + distance[p][w]:
                    distance[v][w] = distance[v][p] + distance[p][w]
                    next_v[v][w] = next_v[v][p]

    return distance, next_v


def print_path(next_v, u, v):
    """Print shortest path from vertex u to v.

    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u
    in the shortest path from u to v. It is None if there is no path between
    them. next_v[u][u] should be None for all u.

    u and v are Vertex objects.
    """
    p = u
    while (next_v[p][v]):
        print('{} -> '.format(p.get_key()), end='')
        p = next_v[p][v]
    print('{} '.format(v.get_key()), end='')


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('floyd-warshall')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'floyd-warshall':
        distance, next_v = floyd_warshall(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                if next_v[start][end]:
                    print('From {} to {}: '.format(start.get_key(),
                                                    end.get_key()),
                            end = '')
                    print_path(next_v, start, end)
                    print('(distance {})'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Transitive Closure of a Graph
================================ EOPN
Python Program to Find Transitive Closure of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
transitive-closure
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
2, 2
What would you like to do? add edge 1 2 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
2, 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
1, 3
2, 2
2, 3
3, 3
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
transitive-closure
display
quit
What would you like to do? add vertex 0
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 0 1
What would you like to do? add edge 0 2
What would you like to do? add edge 1 2
What would you like to do? add edge 2 0
What would you like to do? add edge 2 3
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
0, 0
0, 1
0, 2
0, 3
1, 0
1, 1
1, 2
1, 3
2, 0
2, 1
2, 2
2, 3
3, 3
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def transitive_closure(g):
    """Return dictionary reachable.

    reachable[u][v] = True iff there is a path from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    reachable = {v:dict.fromkeys(g, False) for v in g}

    for v in g:
        for n in v.get_neighbours():
            reachable[v][n] = True

    for v in g:
         reachable[v][v] = True

    for p in g: 
        for v in g:
            for w in g:
                if reachable[v][p] and reachable[p][w]:
                    reachable[v][w] = True

    return reachable


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('transitive-closure')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'transitive-closure':
        reachable = transitive_closure(g)
        print('All pairs (u, v) such that there is a path from u to v: ')
        for start in g:
            for end in g:
                if reachable[start][end]:
                    print('{}, {}'.format(start.get_key(), end.get_key()))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 3 18
What would you like to do? add edge 1 2 10
What would you like to do? add edge 3 4 70
What would you like to do? add edge 3 2 6
What would you like to do? add edge 2 5 20
What would you like to do? add edge 5 6 10
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 7 
Edges: 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=2, dest=3, weight=6) 
(src=3, dest=2, weight=6) 
(src=3, dest=4, weight=70) 
(src=4, dest=3, weight=70) 
(src=5, dest=6, weight=10) 
(src=5, dest=2, weight=20) 
(src=6, dest=5, weight=10) 
(src=6, dest=7, weight=5) 
(src=7, dest=6, weight=5) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 100
What would you like to do? add edge 1 3 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=10) 
(src=1, dest=3, weight=50) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=50) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_prim(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    # if graph is empty
    if not g:
        return mst

    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    nearest_neighbour = {}
    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    smallest_distance = {}
    # v is in unvisited iff v has not been added to the MST
    unvisited = set(g)

    u = next(iter(g)) # select any one vertex from g
    mst.add_vertex(u.get_key()) # add a copy of it to the MST
    unvisited.remove(u)

    # for each neighbour of vertex u
    for n in u.get_neighbours():
        if n is u:
            # avoid self-loops
            continue
        # update dictionaries
        nearest_neighbour[n] = mst.get_vertex(u.get_key())
        smallest_distance[n] = u.get_weight(n)

    # loop until smallest_distance becomes empty
    while (smallest_distance):
        # get nearest vertex outside the MST
        outside_mst = min(smallest_distance, key=smallest_distance.get)
        # get the nearest neighbour inside the MST
        inside_mst = nearest_neighbour[outside_mst]

        # add a copy of the outside vertex to the MST
        mst.add_vertex(outside_mst.get_key())
        # add the edge to the MST
        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),
                     smallest_distance[outside_mst])
        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),
                     smallest_distance[outside_mst])

        # now that outside_mst has been added to the MST, remove it from our
        # dictionaries and the set unvisited
        unvisited.remove(outside_mst)
        del smallest_distance[outside_mst]
        del nearest_neighbour[outside_mst]

        # update dictionaries
        for n in outside_mst.get_neighbours():
            if n in unvisited:
                if n not in smallest_distance:
                    smallest_distance[n] = outside_mst.get_weight(n)
                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())
                else:
                    if smallest_distance[n] > outside_mst.get_weight(n):
                        smallest_distance[n] = outside_mst.get_weight(n)
                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_prim(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 5 30
What would you like to do? add edge 1 4 40
What would you like to do? add edge 2 5 20
What would you like to do? add edge 4 5 40
What would you like to do? add edge 5 3 40
What would you like to do? add edge 5 6 70
What would you like to do? add edge 3 6 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 
Edges: 
(src=1, dest=4, weight=40) 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=3, dest=5, weight=40) 
(src=3, dest=6, weight=50) 
(src=4, dest=1, weight=40) 
(src=5, dest=2, weight=20) 
(src=5, dest=3, weight=40) 
(src=6, dest=3, weight=50) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 20
What would you like to do? add edge 2 3 30
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=3, weight=20) 
(src=1, dest=2, weight=10) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=20) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_vertex_exist(self, key):
        return key in self.vertices

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_krusal(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    if len(g) == 1:
        u = next(iter(g)) # get the single vertex
        mst.add_vertex(u.get_key()) # add a copy of it to mst
        return mst

    # get all the edges in a list
    edges = []
    for v in g:
        for n in v.get_neighbours():
            # avoid adding two edges for each edge of the undirected graph
            if v.get_key() < n.get_key():
                edges.append((v, n))

    # sort edges
    edges.sort(key=lambda edge: edge[0].get_weight(edge[1]))

    # initially, each vertex is in its own component
    component = {}
    for i, v in enumerate(g):
        component[v] = i

    # next edge to try
    edge_index = 0

    # loop until mst has the same number of vertices as g
    while len(mst) < len(g):
        u, v = edges[edge_index]
        edge_index += 1

        # if adding edge (u, v) will not form a cycle
        if component[u] != component[v]:

            # add to mst
            if not mst.does_vertex_exist(u.get_key()):
                mst.add_vertex(u.get_key())
            if not mst.does_vertex_exist(v.get_key()):
                mst.add_vertex(v.get_key())
            mst.add_edge(u.get_key(), v.get_key(), u.get_weight(v))
            mst.add_edge(v.get_key(), u.get_key(), u.get_weight(v))

            # merge components of u and v
            for w in g:
                if component[w] == component[v]:
                    component[w] = component[u]

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_krusal(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Johnsons Algorithm
================================ EOPN
Python Program to Implement Johnsons Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 3 8
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 1
1 to 3 distance -3
1 to 4 distance 2
1 to 5 distance -4
2 to 1 distance 3
2 to 2 distance 0
2 to 3 distance -4
2 to 4 distance 1
2 to 5 distance -1
3 to 1 distance 7
3 to 2 distance 4
3 to 3 distance 0
3 to 4 distance 5
3 to 5 distance 3
4 to 1 distance 2
4 to 2 distance -1
4 to 3 distance -5
4 to 4 distance 0
4 to 5 distance -2
5 to 1 distance 8
5 to 2 distance 5
5 to 3 distance 1
5 to 4 distance 6
5 to 5 distance 0
What would you like to do? quit

Case 2:
python 226__graph_johnson.py
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance inf
2 to 1 distance inf
2 to 2 distance 0
What would you like to do? add edge 1 2 100
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 -50
What would you like to do? add edge 1 3 60
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 100
1 to 3 distance 50
2 to 1 distance inf
2 to 2 distance 0
2 to 3 distance -50
3 to 1 distance inf
3 to 2 distance inf
3 to 3 distance 0
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def set_weight(self, dest, weight):
        """Set weight of edge from this vertex to dest."""
        self.points_to[dest] = weight

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def johnson(g):
    """Return distance where distance[u][v] is the min distance from u to v.

    distance[u][v] is the shortest distance from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    # add new vertex q
    g.add_vertex('q')
    # let q point to all other vertices in g with zero-weight edges
    for v in g:
        g.add_edge('q', v.get_key(), 0)

    # compute shortest distance from vertex q to all other vertices
    bell_dist = bellman_ford(g, g.get_vertex('q'))

    # set weight(u, v) = weight(u, v) + bell_dist(u) - bell_dist(v) for each
    # edge (u, v)
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[v] - bell_dist[n])

    # remove vertex q
    # This implementation of the graph stores edge (u, v) in Vertex object u
    # Since no other vertex points back to q, we do not need to worry about
    # removing edges pointing to q from other vertices.
    del g.vertices['q']

    # distance[u][v] will hold smallest distance from vertex u to v
    distance = {}
    # run dijkstra's algorithm on each source vertex
    for v in g:
        distance[v] = dijkstra(g, v)

    # correct distances
    for v in g:
        for w in g:
            distance[v][w] += bell_dist[w] - bell_dist[v]

    # correct weights in original graph
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[n] - bell_dist[v])

    return distance


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('johnson')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'johnson':
        distance = johnson(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                print('{} to {}'.format(start.get_key(), end.get_key()), end=' ')
                print('distance {}'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Read a Linked List in Reverse
================================ EOPN
Python Program to Read a Linked List in Reverse
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 5
Enter data item: 3
Enter data item: 10
Enter data item: 2
The linked list: 2 10 3 5 

Case 2:
How many elements would you like to add? 1
Enter data item: 8
The linked list: 8 

Case 3:
How many elements would you like to add? 3
Enter data item: 1
Enter data item: 2
Enter data item: 3
The linked list: 3 2 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    node = Node(data)
    a_llist.insert_at_beg(node)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Create a Linked List & Display the Elements in the List
================================ EOPN
Python Program to Create a Linked List & Display the Elements in the List
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: -2
Enter data item: 1
Enter data item: 5
Enter data item: 0
The linked list: 3 -2 1 5 0 

Case 2:
How many elements would you like to add? 1
Enter data item: 6
The linked list: 6 

Case 3:
How many elements would you like to add? 4
Enter data item: 2
Enter data item: 9
Enter data item: 3
Enter data item: 2
The linked list: 2 9 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Search for an Element in the Linked List using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 5
5 is at index 1.

Case 2:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 7
7 is at index 4.

Case 3:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 4
4 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        return self.find_index_helper(key, 0, self.head)

    def find_index_helper(self, key, start, node):
        if node is None:
            return -1

        if node.data == key:
            return start
        else:
            return self.find_index_helper(key, start + 1, node.next)

a_llist = LinkedList()
for data in [3, 5, 0, 10, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 9
9 is at index 4.

Case 2:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 11
11 is at index 5.

Case 3:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 3
3 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        current = self.head

        index = 0
        while current:
            if current.data == key:
                return index
            current = current.next
            index = index + 1

        return -1

a_llist = LinkedList()
for data in [4, -3, 1, 0, 9, 11]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: 8
Enter data item: 14
Enter data item: 2
Enter data item: 1
The reversed linked list: 1 2 14 8 3 

Case 2:
How many elements would you like to add? 1
Enter data item: 3
The reversed linked list: 3 

Case 3:
How many elements would you like to add? 2
Enter data item: 0
Enter data item: 1
The reversed linked list: 1 0
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        self.display_reversed_helper(self.head)

    def display_reversed_helper(self, current):
        if current is None:
            return

        self.display_reversed_helper(current.next)
        print(current.data, end = ' ')

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 3
Enter data item: 7
Enter data item: 2
Enter data item: 1
The linked list: 7 2 1 

Case 2:
How many elements would you like to add? 1
Enter data item: 2
The linked list: 2 

Case 3:
How many elements would you like to add? 5
Enter data item: 4
Enter data item: 2
Enter data item: 3
Enter data item: 5
Enter data item: 1
The linked list: 4 2 3 5 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        self.display_helper(self.head)

    def display_helper(self, current):
        if current is None:
            return

        print(current.data, end = ' ')
        self.display_helper(current.next)

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOPN
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 7
Enter data item: 2
Enter data item: 1
Enter data item: 9
The reversed linked list: 9 1 2 7 

Case 2:
How many elements would you like to add? 1
Enter data item: 5
The reversed linked list: 5 

Case 3:
How many elements would you like to add? 2
Enter data item: 3
Enter data item: 1
The reversed linked list: 1 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        end_node = None

        while end_node != self.head:
            current = self.head
            while current.next != end_node:
                current = current.next
            print(current.data, end = ' ')
            end_node = current

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Find the Length of the Linked List using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 4 10
The length of the linked list is 3.

Case 2:
Please enter the elements in the linked list: 7
The length of the linked list is 1.

Case 3:
Please enter the elements in the linked list: 3 4 1 -1 3 9
The length of the linked list is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        return self.length_helper(self.head)

    def length_helper(self, current):
        if current is None:
            return 0
        return 1 + self.length_helper(current.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Find the Length of the Linked List without using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 8 1
The length of the linked list is 2.

Case 2:
Please enter the elements in the linked list: 
The length of the linked list is 0.

Case 3:
Please enter the elements in the linked list: 7 5 9 12
The length of the linked list is 4.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        current = self.head
        length = 0
        while current:
            length = length + 1
            current = current.next
        return length

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 3
3 occurs 2 time(s) in the list.

Case 2:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 7
7 occurs 4 time(s) in the list.

Case 3:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 2
2 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        return self.count_helper(self.head, key)

    def count_helper(self, current, key):
        if current is None:
            return 0

        if current.data == key:
            return 1 + self.count_helper(current.next, key)
        else:
            return self.count_helper(current.next, key)

a_llist = LinkedList()
for data in [7, 3, 7, 4, 7, 11, 4, 0, 3, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 5
5 occurs 3 time(s) in the list.

Case 2:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 3
3 occurs 1 time(s) in the list.

Case 3:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 7
7 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        current = self.head

        count = 0
        while current:
            if current.data == key:
                count = count + 1
            current = current.next

        return count

a_llist = LinkedList()
for data in [5, 1, 3, 5, 5, 15, 4, 9, 2]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 1 40 3 10
The alternate nodes of the linked list: 7 1 3 

Case 2:
Please enter the elements in the linked list: 4 9 1
The alternate nodes of the linked list: 4 1 

Case 3:
Please enter the elements in the linked list: 3
The alternate nodes of the linked list: 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        self.alternate_helper(self.head)

    def alternate_helper(self, current):
        if current is None:
            return
        print(current.data, end = ' ')
        if current.next:
            self.alternate_helper(current.next.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 4 1 9 10 3
The alternate nodes of the linked list: 7 4 9 3 

Case 2:
Please enter the elements in the linked list: 1 2
The alternate nodes of the linked list: 1 

Case 3:
Please enter the elements in the linked list: 9
The alternate nodes of the linked list: 9
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            if current.next is not None:
                current = current.next.next
            else:
                break

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Implement a Stack using Linked List
================================ EOPN
Python Program to Implement a Stack using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 15
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Popped value:  15
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Stack:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node

    def pop(self):
        if self.head is None:
            return None
        else:
            popped = self.head.data
            self.head = self.head.next
            return popped

a_stack = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        a_stack.push(int(do[1]))
    elif operation == 'pop':
        popped = a_stack.pop()
        if popped is None:
            print('Stack is empty.')
        else:
            print('Popped value: ', int(popped))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue Data Structure using Linked List
================================ EOPN
Python Program to Implement Queue Data Structure using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 5
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  5
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.last = None

    def enqueue(self, data):
        if self.last is None:
            self.head = Node(data)
            self.last = self.head
        else:
            self.last.next = Node(data)
            self.last = self.last.next

    def dequeue(self):
        if self.head is None:
            return None
        else:
            to_return = self.head.data
            self.head = self.head.next
            return to_return

a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        dequeued = a_queue.dequeue()
        if dequeued is None:
            print('Queue is empty.')
        else:
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Binary Tree using Linked List
================================ EOPN
Python Program to Implement Binary Tree using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 5 left of 3
inorder traversal of binary tree: 5 3 
What would you like to do? insert 2 right of 5
inorder traversal of binary tree: 5 2 3 
What would you like to do? insert 11 right of 3
inorder traversal of binary tree: 5 2 3 11 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 left of 2
inorder traversal of binary tree: 4 2 1 3 
What would you like to do? insert 5 right of 2
inorder traversal of binary tree: 4 2 5 1 3 
What would you like to do? insert 6 left of 3
inorder traversal of binary tree: 4 2 5 1 6 3 
What would you like to do? insert 7 right of 3
inorder traversal of binary tree: 4 2 5 1 6 3 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether 2 Linked Lists are Same
================================ EOPN
Python Program to Check whether 2 Linked Lists are Same
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 5 8 10 12
Please enter the elements in the second linked list: 5 8 10 12
The two linked lists are the same.

Case 2:
Please enter the elements in the first linked list: 12 3 4 5 0
Please enter the elements in the second linked list: 12 3
The two linked list are not the same.

Case 3:
Please enter the elements in the first linked list: 4 1
Please enter the elements in the second linked list: 2 19 4
The two linked list are not the same.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def is_equal(llist1, llist2):
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        if current1.data != current2.data:
            return False
        current1 = current1.next
        current2 = current2.next
    if current1 is None and current2 is None:
        return True
    else:
        return False


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

if is_equal(llist1, llist2):
    print('The two linked lists are the same.')
else:
    print('The two linked list are not the same.', end = '')
 ETP  
 
Python Program to Detect the Cycle in a Linked List
================================ EOPN
Python Program to Detect the Cycle in a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3
Enter the index [0-2] of the node to which you want the last node to point (enter nothing to make it point to None): 0
The linked list has a cycle.

Case 2:
Please enter the elements in the linked list: 4 5
Enter the index [0-1] of the node to which you want the last node to point (enter nothing to make it point to None): 1
The linked list has a cycle.

Case 3:
Please enter the elements in the linked list: 9 1 4 5
Enter the index [0-3] of the node to which you want the last node to point (enter nothing to make it point to None): 
The linked list does not have a cycle.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            current = current.next
            if current is None:
                return None
        return current


def has_cycle(llist):
    slow = llist.head
    fast = llist.head
    while (fast != None and fast.next != None):
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

length = len(data_list)
if length != 0:
    values = '0-' + str(length - 1)
    last_ptr = input('Enter the index [' + values + '] of the node'
                     ' to which you want the last node to point'
                     ' (enter nothing to make it point to None): ').strip()
    if last_ptr == '':
        last_ptr = None
    else:
        last_ptr = a_llist.get_node(int(last_ptr))
        a_llist.last_node.next = last_ptr

if has_cycle(a_llist):
    print('The linked list has a cycle.')
else:
    print('The linked list does not have a cycle.')
 ETP  
 
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOPN
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the doubly linked list: 5 10 9 3
The largest element is 10.

Case 2:
Please enter the elements in the doubly linked list: 
The list is empty.

Case 3:
Please enter the elements in the doubly linked list: 234 10 4 200
The largest element is 234.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def append(self, data):
        self.insert_at_end(Node(data))

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            new_node.prev = self.last
            self.last.next = new_node
            self.last = new_node


def find_largest(dllist):
    if dllist.first is None:
        return None
    largest = dllist.first.data
    current = dllist.first.next
    while current:
        if current.data > largest:
            largest = current.data
        current = current.next
    return largest


a_dllist = DoublyLinkedList()

data_list = input('Please enter the elements in the doubly linked list: ').split()
for data in data_list:
    a_dllist.append(int(data))

largest = find_largest(a_dllist)
if largest:
    print('The largest element is {}.'.format(largest))
else:
    print('The list is empty.')
 ETP  
 
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOPN
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 9 10 15
Please enter the elements in the second linked list: 2 5 4
The sum linked list: 3 14 14 15 

Case 2:
Please enter the elements in the first linked list: 3 4 5
Please enter the elements in the second linked list: 
The sum linked list: 3 4 5 

Case 3:
Please enter the elements in the first linked list: 7 10
Please enter the elements in the second linked list: 6 5 4 3 2
The sum linked list: 13 15 4 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next


def add_linked_lists(llist1, llist2):
    sum_llist = LinkedList()
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        sum = current1.data + current2.data
        sum_llist.append(sum)
        current1 = current1.next
        current2 = current2.next
    if current1 is None:
        while current2:
            sum_llist.append(current2.data)
            current2 = current2.next
    else:
        while current1:
            sum_llist.append(current1.data)
            current1 = current1.next
    return sum_llist



llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

sum_llist = add_linked_lists(llist1, llist2)

print('The sum linked list: ', end = '')
sum_llist.display()
 ETP  
 
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOPN
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 4 5 1 3 10
Please enter the elements in the second linked list: 8 3 40 1
The element that appears first in the first linked list that is common to both is 1.

Case 2:
Please enter the elements in the first linked list: 1 4 5
Please enter the elements in the second linked list: 3 10
The two lists have no common elements.

Case 3:
Please enter the elements in the first linked list: 6 8 9
Please enter the elements in the second linked list: 7 10 6 4 9 8
The element that appears first in the first linked list that is common to both is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def first_common(llist1, llist2):
    current1 = llist1.head
    while current1:
        data = current1.data
        current2 = llist2.head
        while current2:
            if data == current2.data:
                return data
            current2 = current2.next
        current1 = current1.next
    return None


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

common = first_common(llist1, llist2)

if common:
    print('The element that appears first in the first linked list that'
          ' is common to both is {}.'.format(common))
else:
    print('The two lists have no common elements.')
 ETP  
 
Python Program to Remove Duplicates from a Linked List
================================ EOPN
Python Program to Remove Duplicates from a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 5 2 1 4 5 4 5
The list with duplicates removed: 
1 5 2 4 

Case 2:
Please enter the elements in the linked list: 3 4 1
The list with duplicates removed: 
3 4 1 

Case 3:
Please enter the elements in the linked list: 1 3 3 14 5 1 0
The list with duplicates removed: 
1 3 14 5 0
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        data = current1.data
        current2 = current1.next
        while current2:
            if current2.data == data:
                llist.remove(current2)
            current2 = current2.next
        current1 = current1.next


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

remove_duplicates(a_llist)

print('The list with duplicates removed: ')
a_llist.display()
 ETP  
 
Python Program to Reverse a Linked List
================================ EOPN
Python Program to Reverse a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 30 4
The reversed list: 
4 30 1 7 

Case 2:
Please enter the elements in the linked list: 3
The reversed list: 
3 

Case 3:
Please enter the elements in the linked list: 1 2
The reversed list: 
2 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist):
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    while after:
        current.next = before
        before = current
        current = after
        after = after.next
    current.next = before
    llist.head = current


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

reverse_llist(a_llist)

print('The reversed list: ')
a_llist.display()
 ETP  
 
Python Program to Reverse only First N Elements of a Linked List
================================ EOPN
Python Program to Reverse only First N Elements of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7
Enter the number of elements you want to reverse in the list: 4
The new list: 
4 3 2 1 5 6 7 

Case 2:
Please enter the elements in the linked list: 7 2 4
Enter the number of elements you want to reverse in the list: 1
The new list: 
7 2 4 

Case 3:
Please enter the elements in the linked list: 8 3 2
Enter the number of elements you want to reverse in the list: 3
The new list: 
2 3 8
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist, n):
    if n == 0:
        return
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    for i in range(n):
        current.next = before
        before = current
        current = after
        if after is None:
            break
        after = after.next
    llist.head.next = current
    llist.head = before


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))
n = int(input('Enter the number of elements you want to reverse in the list: '))

reverse_llist(a_llist, n)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Print Middle most Node of a Linked List
================================ EOPN
Python Program to Print Middle most Node of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7 8
The two middle elements are 4 and 5.

Case 2:
Please enter the elements in the linked list: 5
The middle element is 5.

Case 3:
Please enter the elements in the linked list: 3 1 0 4 2
The middle element is 0.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def print_middle(llist):
    current = llist.head
    length = 0
    while current:
        current = current.next
        length = length + 1

    current = llist.head
    for i in range((length - 1)//2):
        current = current.next

    if current:
        if length % 2 == 0:
            print('The two middle elements are {} and {}.'
                .format(current.data, current.next.data))
        else:
            print('The middle element is {}.'.format(current.data))
    else:
        print('The list is empty.')


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_middle(a_llist)
 ETP  
 
Python Program to Print Nth Node from the last of a Linked List
================================ EOPN
Python Program to Print Nth Node from the last of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 10 20 40 50 60
The nth element from the end will be printed. Please enter n: 3
The nth element from the end: 40

Case 2:
Please enter the elements in the linked list: 4 23 3
The nth element from the end will be printed. Please enter n: 1
The nth element from the end: 3

Case 3:
Please enter the elements in the linked list: 1 2
The nth element from the end will be printed. Please enter n: 2
The nth element from the end: 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def length_llist(llist):
    length = 0
    current = llist.head
    while current:
        current = current.next
        length = length + 1
    return length


def return_n_from_last(llist, n):
    l = length_llist(llist)
    current = llist.head
    for i in range(l - n):
        current = current.next
    return current.data


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

n = int(input('The nth element from the end will be printed. Please enter n: '))
value = return_n_from_last(a_llist, n)

print('The nth element from the end: {}'.format(value))
 ETP  
 
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOPN
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 2 3 4 5
Please enter the elements in the second linked list: 3 4 5 6 7 8
Their union: 
1 2 3 4 5 6 7 8 
Their intersection: 
3 4 5 

Case 2:
Please enter the elements in the first linked list: 
Please enter the elements in the second linked list: 7 8
Their union: 
7 8 
Their intersection: 

Case 3:
Please enter the elements in the first linked list: 8 4 2 1 10 3 4 7 8
Please enter the elements in the second linked list: 5 6 3 4 3 2 5 2 8
Their union: 
8 4 2 1 10 3 7 5 6 
Their intersection: 
8 4 2 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def duplicate(self):
        copy = LinkedList()
        current = self.head
        while current:
            node = Node(current.data)
            copy.insert_at_end(node)
            current = current.next
        return copy

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        current2 = current1.next
        data = current1.data
        while current2:
            temp = current2
            current2 = current2.next
            if temp.data == data:
                llist.remove(temp)
        current1 = current1.next


def find_union(llist1, llist2):
    if llist1.head is None:
        union = llist2.duplicate()
        remove_duplicates(union)
        return union
    if llist2.head is None:
        union = llist1.duplicate()
        remove_duplicates(union)
        return union

    union = llist1.duplicate()
    last_node = union.head
    while last_node.next is not None:
        last_node = last_node.next
    llist2_copy = llist2.duplicate()
    last_node.next = llist2_copy.head
    remove_duplicates(union)

    return union


def find_intersection(llist1, llist2):
    if (llist1.head is None or llist2.head is None):
        return LinkedList()

    intersection = LinkedList()
    current1 = llist1.head
    while current1:
        current2 = llist2.head
        data = current1.data
        while current2:
            if current2.data == data:
                node = Node(data)
                intersection.insert_at_end(node)
                break
            current2 = current2.next
        current1 = current1.next
    remove_duplicates(intersection)

    return intersection


a_llist1 = LinkedList()
a_llist2 = LinkedList()
data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist1.insert_at_end(node)
data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist2.insert_at_end(node)

union = find_union(a_llist1, a_llist2)
intersection = find_intersection(a_llist1, a_llist2)

print('Their union: ')
union.display()
print()
print('Their intersection: ')
intersection.display()
print()
 ETP  
 
Python Program to Solve Josephus Problem using Linked List
================================ EOPN
Python Program to Solve Josephus Problem using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Input number of people: 5
The kth person will be executed. Input k: 3
The person at position 4 won't be killed.

Case 2:
Input number of people: 15
The kth person will be executed. Input k: 7
The person at position 5 won't be killed.

Case 3:
Input number of people: 8
The kth person will be executed. Input k: 2
The person at position 1 won't be killed.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        node = Node(data)
        self.insert_at_end(node)

    def get_node(self, index, start):
        if self.head is None:
            return None
        current = start
        for i in range(index):
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next


def has_one_node(cllist):
    if cllist.head.next == cllist.head:
        return True
    else:
        return False


def get_josephus_solution(cllist, k):
    if cllist.head is None:
        return None
    start = cllist.head
    while not has_one_node(cllist):
        to_remove = cllist.get_node(k - 1, start)
        start = to_remove.next
        cllist.remove(to_remove)
    return cllist.head.data


a_cllist = CircularLinkedList()
n = int(input('Input number of people: '))
k = int(input('The kth person will be executed. Input k: '))
for i in range(1, n + 1):
    a_cllist.append(i)

ans = get_josephus_solution(a_cllist, k)
print('The person at position {} won\'t be killed.'.format(ans))
 ETP  
 
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOPN
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
Please enter the two indices of the two elements that you want to exchange: 0 1
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 5 1
Please enter the two indices of the two elements that you want to exchange: 1 2
The new list: 
4 1 5 

Case 3:
Please enter the elements in the linked list: 3 1 30 4 5 10 23
Please enter the two indices of the two elements that you want to exchange: 2 5
The new list: 
3 1 10 4 5 30 23
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def interchange(llist, n, m):
    node1 = llist.get_node(n)
    node2 = llist.get_node(m)
    prev_node1 = llist.get_prev_node(node1)
    prev_node2 = llist.get_prev_node(node2)
    if prev_node1 is not None:
        prev_node1.next = node2
    else:
        llist.head = node2
    if prev_node2 is not None:
        prev_node2.next = node1
    else:
        llist.head = node1
    temp = node2.next
    node2.next = node1.next
    node1.next = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

ans = input('Please enter the two indices of the two elements that'
            ' you want to exchange: ').split()
n = int(ans[0])
m = int(ans[1])

interchange(a_llist, n, m)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOPN
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 1 0 4 30 12
The new list: 
12 30 4 0 3 1 

Case 2:
Please enter the elements in the linked list: 1 2
The new list: 
2 1 

Case 3:
Please enter the elements in the linked list: 1 2 3 4 5
The new list: 
4 2 1 3 5
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next


def move_even_before_odd(llist):
    current = llist.head
    while current:
        temp = current.next
        if current.data % 2 == 0:
            llist.remove(current)
            llist.insert_at_beg(current)
        current = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

move_even_before_odd(a_llist)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOPN
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
The nodes at indices n and n+1 will be interchanged. Please enter n: 0
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 1 5
The nodes at indices n and n+1 will be interchanged. Please enter n: 2
The new list: 
5 1 4 

Case 3:
Please enter the elements in the linked list: 3 18 40 1 6
The nodes at indices n and n+1 will be interchanged. Please enter n: 3
The new list: 
3 18 40 6 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def append(self, data):
        self.insert_at_end(Node(data))

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break

def interchange(llist, n):
    current = llist.get_node(n)
    current2 = current.next
    if current2.next != current:
        before = llist.get_prev_node(current)
        after = current2.next
        before.next = current2
        current2.next = current
        current.next = after
    if llist.head == current:
        llist.head = current2
    elif llist.head == current2:
        llist.head = current


a_cllist = CircularLinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_cllist.append(int(data))

n = int(input('The nodes at indices n and n+1 will be interchanged.'
              ' Please enter n: '))

interchange(a_cllist, n)

print('The new list: ')
a_cllist.display()
 ETP  
 
Python Program to Illustrate the Operations of Singly Linked List
================================ EOPN
Python Program to Illustrate the Operations of Singly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 3 at end
The list: 7 3 
What would you like to do? insert 1 after 0
The list: 7 1 3 
What would you like to do? insert 9 before 2
The list: 7 1 9 3 
What would you like to do? remove 2
The list: 7 1 3 
What would you like to do? insert 12 at end
The list: 7 1 3 12 
What would you like to do? remove 0
The list: 1 3 12 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 after 0
No such index.
The list: 
What would you like to do? insert 3 at end
The list: 3 
What would you like to do? insert 1 after 0
The list: 3 1 
What would you like to do? insert 2 before 1
The list: 3 2 1 
What would you like to do? insert 0 at end
The list: 3 2 1 0 
What would you like to do? remove 3
The list: 3 2 1 
What would you like to do? remove 2
The list: 3 2 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_llist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_llist.insert_at_beg(new_node)
            elif position == 'end':
                a_llist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_llist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_llist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_llist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_llist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_llist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOPN
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 8 1 8 7
The linked lists is palindromic.

Case 2:
Please enter the elements in the linked list: 1 2 3 3 2 1
The linked list is palindromic.

Case 3:
Please enter the elements in the linked list: 1 4 5 4 5 1
The linked list is not palindromic.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def is_palindrome(llist):
    start = llist.head
    end = llist.last_node
    while (start != end and end.next != start):
        if start.data != end.data:
            return False
        start = start.next
        end = llist.get_prev_node(end)
    return True


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

if is_palindrome(a_llist):
    print('The linked list is palindromic.')
else:
    print('The linked list is not palindromic.')
 ETP  
 
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOPN
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 3 40 1
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 7.

Case 2:
Please enter the elements in the linked list: 3
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 3.

Case 3:
Please enter the elements in the linked list: 1 2
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 1.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def convert_to_circular(llist):
    if llist.last_node:
        llist.last_node.next = llist.head


def print_last_node_points_to(llist):
    last = llist.last_node
    if last is None:
        print('List is empty.')
        return
    if last.next is None:
        print('Last node points to None.')
    else:
        print('Last node points to element with data {}.'.format(last.next.data))


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_last_node_points_to(a_llist)

print('Converting linked list to a circular linked list...')
convert_to_circular(a_llist)

print_last_node_points_to(a_llist)
 ETP  
 
Python Program to Implement Circular Doubly Linked List
================================ EOPN
Python Program to Implement Circular Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 at beg
The list: 3 
What would you like to do? insert 5 at end
The list: 3 5 
What would you like to do? insert 1 after 0
The list: 3 1 5 
What would you like to do? insert 2 after 2
The list: 3 1 5 2 
What would you like to do? remove 0
The list: 1 5 2 
What would you like to do? remove 2
The list: 1 5 
What would you like to do? remove 1
The list: 1 
What would you like to do? remove 0
The list: 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 10 at end
The list: 10 
What would you like to do? insert 1 at beg
The list: 1 10 
What would you like to do? insert 5 before 0
The list: 1 10 5 
What would you like to do? insert 9 at beg
The list: 9 1 10 5 
What would you like to do? remove 3
The list: 9 1 10 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class CircularDoublyLinkedList:
    def __init__(self):
        self.first = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            current = current.next
            if current == self.first:
                return None
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        new_node.next = ref_node.next
        new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        self.insert_after(ref_node.prev, new_node)

    def insert_at_end(self, new_node):
        if self.first is None:
            self.first = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            self.insert_after(self.first.prev, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.first = new_node

    def remove(self, node):
        if self.first.next == self.first:
            self.first = None
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
            if self.first == node:
                self.first = node.next

    def display(self):
        if self.first is None:
            return
        current = self.first
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.first:
                break


a_cdllist = CircularDoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cdllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cdllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cdllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cdllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cdllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cdllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cdllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cdllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Demonstrate Circular Single Linked List
================================ EOPN
Python Program to Demonstrate Circular Single Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 1 before 0
The list: 7 1 
What would you like to do? insert 10 after 0
The list: 7 10 1 
What would you like to do? insert 3 at end
The list: 7 10 1 3 
What would you like to do? remove 2
The list: 7 10 3 
What would you like to do? remove 0
The list: 10 3 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 1 at beg
The list: 1 
What would you like to do? insert 3 after 2
No such index.
The list: 1 
What would you like to do? remove 1
No such index.
The list: 1 
What would you like to do? insert 6 after 0
The list: 1 6 
What would you like to do? remove 0
The list: 6 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.head = new_node

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break


a_cllist = CircularLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOPN
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 at beg
The list: 5 
What would you like to do? insert 3 at beg
The list: 3 5 
What would you like to do? insert 1 at end
The list: 3 5 1 
What would you like to do? insert 10 after 1
The list: 3 5 10 1 
What would you like to do? insert 0 before 2
The list: 3 5 0 10 1 
What would you like to do? remove 4
The list: 3 5 0 10 
What would you like to do? remove 1
The list: 3 0 10 
What would you like to do? remove 5
No such index.
The list: 3 0 10 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 2 at beg
The list: 2 
What would you like to do? insert 3 before 0
The list: 3 2 
What would you like to do? remove 0
The list: 2 
What would you like to do? remove 0
The list: 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        if ref_node.next is None:
            self.last = new_node
        else:
            new_node.next = ref_node.next
            new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        new_node.next = ref_node
        if ref_node.prev is None:
            self.first = new_node
        else:
            new_node.prev = ref_node.prev
            new_node.prev.next = new_node
        ref_node.prev = new_node

    def insert_at_beg(self, new_node):
        if self.first is None:
            self.first = new_node
            self.last = new_node
        else:
            self.insert_before(self.first, new_node)

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            self.insert_after(self.last, new_node)

    def remove(self, node):
        if node.prev is None:
            self.first = node.next
        else:
            node.prev.next = node.next

        if node.next is None:
            self.last = node.prev
        else:
            node.next.prev = node.prev

    def display(self):
        current = self.first
        while current:
            print(current.data, end = ' ')
            current = current.next


a_dllist = DoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_dllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_dllist.insert_at_beg(new_node)
            elif position == 'end':
                a_dllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_dllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_dllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_dllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_dllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_dllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Stack
================================ EOPN
Python Program to Implement a Stack
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? push 5
push <value>
pop
quit
What would you like to do? pop
Popped value:  5
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? push 1
push <value>
pop
quit
What would you like to do? pop
Popped value:  1
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Reverse a Stack using Recursion
================================ EOPN
Python Program to Reverse a Stack using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements to push: 7 3 1 5
The stack:
5
1
3
7
After reversing:
7
3
1
5

Case 2:
Please enter the elements to push: 3
The stack:
3
After reversing:
3

Case 3:
Please enter the elements to push: 1 2
The stack:
2
1
After reversing:
1
2
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def display(self):
        for data in reversed(self.items):
            print(data)

def insert_at_bottom(s, data):
    if s.is_empty():
        s.push(data)
    else:
        popped = s.pop()
        insert_at_bottom(s, data)
        s.push(popped)


def reverse_stack(s):
    if not s.is_empty():
        popped = s.pop()
        reverse_stack(s)
        insert_at_bottom(s, popped)


s = Stack()
data_list = input('Please enter the elements to push: ').split()
for data in data_list:
    s.push(int(data))

print('The stack:')
s.display()
reverse_stack(s)
print('After reversing:')
s.display()
 ETP  
 
Python Program to Implement Stack using One Queue
================================ EOPN
Python Program to Implement Stack using One Queue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? push 3
What would you like to do? push 5
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.q = Queue()

    def is_empty(self):
        return self.q.is_empty()

    def push(self, data):
        self.q.enqueue(data)

    def pop(self):
        for _ in range(self.q.get_size() - 1):
            dequeued = self.q.dequeue()
            self.q.enqueue(dequeued)
        return self.q.dequeue()


class Queue:
    def __init__(self):
        self.items = []
        self.size = 0

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.size += 1
        self.items.append(data)

    def dequeue(self):
        self.size -= 1
        return self.items.pop(0)

    def get_size(self):
        return self.size


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Stack Using Two Queues
================================ EOPN
Python Program to Implement Stack Using Two Queues
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? pop
Popped value:  2
What would you like to do? quit

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 5
What would you like to do? push 0
What would you like to do? pop
Popped value:  0
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def is_empty(self):
        return self.queue2.is_empty()

    def push(self, data):
        self.queue1.enqueue(data)
        while not self.queue2.is_empty():
            x = self.queue2.dequeue()
            self.queue1.enqueue(x)
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        return self.queue2.dequeue()

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue
================================ EOPN
Python Program to Implement Queue
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  1
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


q = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        q.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if q.is_empty():
            print('Queue is empty.')
        else:
            print('Dequeued value: ', q.dequeue())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dequeue
================================ EOPN
Python Program to Implement Dequeue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 3
What would you like to do? append 4
What would you like to do? appendleft 2
What would you like to do? appendleft 1
What would you like to do? pop
Popped value from right:  4
What would you like to do? popleft
Popped value from left:  1
What would you like to do? pop
Popped value from right:  3
What would you like to do? popleft
Popped value from left:  2
What would you like to do? pop
Dequeue is empty.
What would you like to do? quit

Case 2:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? pop
Popped value from right:  2
What would you like to do? pop
Popped value from right:  1
What would you like to do? appendleft 1
What would you like to do? appendleft 2
What would you like to do? pop
Popped value from right:  1
What would you like to do? pop
Popped value from right:  2
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? popleft
Popped value from left:  1
What would you like to do? popleft
Popped value from left:  2
What would you like to do? quit
--------------------------------
class Dequeue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def append(self, data):
        self.items.append(data)

    def append_left(self, data):
        self.items.insert(0, data)

    def pop(self):
        return self.items.pop()

    def pop_left(self):
        return self.items.pop(0)


q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queues using Stacks
================================ EOPN
Python Program to Implement Queues using Stacks
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? enqueue 8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 2
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  1
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.inbox = Stack()
        self.outbox = Stack()

    def is_empty(self):
        return (self.inbox.is_empty() and self.outbox.is_empty())

    def enqueue(self, data):
        self.inbox.push(data)

    def dequeue(self):
        if self.outbox.is_empty():
            while not self.inbox.is_empty():
                popped = self.inbox.pop()
                self.outbox.push(popped)
        return self.outbox.pop()


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if a_queue.is_empty():
            print('Queue is empty.')
        else:
            dequeued = a_queue.dequeue()
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check String is Palindrome using Stack
================================ EOPN
Python Program to Check String is Palindrome using Stack
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the string: madam
The string is a palindrome.

Case 2:
Please enter the string: racecar
The string is a palindrome.

Case 3:
Please enter the string: palace
The string is not a palindrome.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
text = input('Please enter the string: ')

for character in text:
    s.push(character)

reversed_text = ''
while not s.is_empty():
    reversed_text = reversed_text + s.pop()

if text == reversed_text:
    print('The string is a palindrome.')
else:
    print('The string is not a palindrome.')
 ETP  
 
Python Program to Check if Expression is correctly Parenthesized
================================ EOPN
Python Program to Check if Expression is correctly Parenthesized
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the expression: (3 + 4 * (1 + (2))/(7 * (8 + 9)))
Expression is correctly parenthesized.

Case 2:
Please enter the expression: (a + b))(3)
Expression is not correctly parenthesized.

Case 3:
Please enter the expression: (4 + (3 * 2)
Expression is not correctly parenthesized.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
exp = input('Please enter the expression: ')

for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False

if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')
 ETP  
 
Python Program to Implement Linear Search
================================ EOPN
Python Program to Implement Linear Search
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 4 3 2 1 10 11 2
The number to search for: 1
1 was found at index 4.

Case 2:
Enter the list of numbers: 5 2 1 5 -3
The number to search for: 2
2 was found at index 1.

Case 3:
Enter the list of numbers: 3 5 6
The number to search for: 2
2 was not found.
--------------------------------
def linear_search(alist, key):
    """Return index of key in alist. Return -1 if key not present."""
    for i in range(len(alist)):
        if alist[i] == key:
            return i
    return -1


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = linear_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search without Recursion
================================ EOPN
Python Program to Implement Binary Search without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 3 5 10 12 15 20
The number to search for: 12
12 was found at index 3.

Case 2:
Enter the sorted list of numbers: -3 0 1 5 6 7 8
The number to search for: 2
2 was not found.

Case 3:
Enter the sorted list of numbers: 5
The number to search for: 5
5 was found at index 0.
--------------------------------
def binary_search(alist, key):
    """Search key in alist[start... end - 1]."""
    start = 0
    end = len(alist)
    while start < end:
        mid = (start + end)//2
        if alist[mid] > key:
            end = mid
        elif alist[mid] < key:
            start = mid + 1
        else:
            return mid
    return -1


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search with Recursion
================================ EOPN
Python Program to Implement Binary Search with Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 4 5 6 7 8 9 10
The number to search for: 9
9 was found at index 5.

Case 2:
Enter the sorted list of numbers: 3 4 5 10
The number to search for: 8
8 was not found.

Case 3:
Enter the sorted list of numbers: 7
The number to search for: 7
7 was found at index 0.
--------------------------------
def binary_search(alist, start, end, key):
    """Search key in alist[start... end - 1]."""
    if not start < end:
        return -1

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, mid + 1, end, key)
    elif alist[mid] > key:
        return binary_search(alist, start, mid, key)
    else:
        return mid


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, 0, len(alist), key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 10 2 -1 0 2
The ith smallest element will be found. Enter i: 2
Result: 0.

Case 2:
Enter the list of numbers: 7
The ith smallest element will be found. Enter i: 1
Result: 7.

Case 3:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 5.
--------------------------------
def select(alist, start, end, i):
    """Find ith smallest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[start... pivot]
    k = pivot - start + 1

    if i < k:
        return select(alist, start, pivot, i)
    elif i > k:
        return select(alist, pivot + 1, end, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 10 7 2 -2
The ith smallest element will be found. Enter i: 2
Result: 7.

Case 2:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 1.

Case 3:
Enter the list of numbers: 3
The ith smallest element will be found. Enter i: 1
Result: 3.
--------------------------------
def select(alist, start, end, i):
    """Find ith largest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[pivot... end - 1]
    k = end - pivot

    if i < k:
        return select(alist, pivot + 1, end, i)
    elif i > k:
        return select(alist, start, pivot, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Implement Bubble Sort 
================================ EOPN
Python Program to Implement Bubble Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 38 10 5
Sorted list: [2, 4, 5, 10, 38]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7 3 1 -5 2 10
Sorted list: [-5, 1, 2, 3, 7, 10]
--------------------------------
def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Selection Sort
================================ EOPN
Python Program to Implement Selection Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 4 5 2 6
Sorted list: [1, 2, 3, 4, 5, 6]

Case 2:
Enter the list of numbers: 2 10 5 38 1 7
Sorted list: [1, 2, 5, 7, 10, 38]

Case 3:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]
--------------------------------
def selection_sort(alist):
    for i in range(0, len(alist) - 1):
        smallest = i
        for j in range(i + 1, len(alist)):
            if alist[j] < alist[smallest]:
                smallest = j
        alist[i], alist[smallest] = alist[smallest], alist[i]


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
selection_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Insertion Sort
================================ EOPN
Python Program to Implement Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 4 1 5 8 0
Sorted list: [0, 1, 2, 4, 5, 8]

Case 2:
Enter the list of numbers: 5 4 3 2 0 -1
Sorted list: [-1, 0, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3 4 1 4 5 0 7
Sorted list: [0, 1, 3, 4, 4, 5, 7]
--------------------------------
def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Merge Sort
================================ EOPN
Python Program to Implement Merge Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 8 2 5 1 3
Sorted list: [1, 1, 2, 3, 3, 5, 5, 8]

Case 2:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)

def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Quicksort
================================ EOPN
Python Program to Implement Quicksort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 8 10 3 0 4
Sorted list: [0, 2, 3, 4, 5, 8, 10]

Case 2:
Enter the list of numbers: 7 4 3 2 1
Sorted list: [1, 2, 3, 4, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def quicksort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        p = partition(alist, start, end)
        quicksort(alist, start, p)
        quicksort(alist, p + 1, end)


def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
quicksort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Heapsort
================================ EOPN
Python Program to Implement Heapsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 2 2 1 0 -2 5 7
Sorted list: [-2, 0, 1, 2, 2, 3, 5, 7]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def heapsort(alist):
    build_max_heap(alist)
    for i in range(len(alist) - 1, 0, -1):
        alist[0], alist[i] = alist[i], alist[0]
        max_heapify(alist, index=0, size=i)

def parent(i):
    return (i - 1)//2

def left(i):
    return 2*i + 1

def right(i):
    return 2*i + 2

def build_max_heap(alist):
    length = len(alist)
    start = parent(length - 1)
    while start >= 0:
        max_heapify(alist, index=start, size=length)
        start = start - 1

def max_heapify(alist, index, size):
    l = left(index)
    r = right(index)
    if (l < size and alist[l] > alist[index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[r] > alist[largest]):
        largest = r
    if (largest != index):
        alist[largest], alist[index] = alist[index], alist[largest]
        max_heapify(alist, largest, size)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
heapsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Counting Sort
================================ EOPN
Python Program to Implement Counting Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 4 1 3 6 1 8
Sorted list: [1, 1, 1, 2, 3, 4, 6, 8]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 4 3 2
Sorted list: [2, 3, 4, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 1
Sorted list: [1]
--------------------------------
def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)

    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1

    return result


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
 Python Program to Implement Radix Sort 
================================ EOPN
 Python Program to Implement Radix Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 38 20 1 3 4 0 2 5 1 3 8 2 9 10
Sorted list: [0, 1, 1, 2, 2, 3, 3, 4, 5, 8, 9, 10, 20, 38]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 3
Sorted list: [3]
--------------------------------
def radix_sort(alist, base=10):
    if alist == []:
        return

    def key_factory(digit, base):
        def key(alist, index):
            return ((alist[index]//(base**digit)) % base)
        return key
    largest = max(alist)
    exp = 0
    while base**exp <= largest:
        alist = counting_sort(alist, base - 1, key_factory(exp, base))
        exp = exp + 1
    return alist

def counting_sort(alist, largest, key):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[key(alist, i)] = c[key(alist, i)] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)
    for i in range(len(alist) - 1, -1, -1):
        result[c[key(alist, i)]] = alist[i]
        c[key(alist, i)] = c[key(alist, i)] - 1

    return result

alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = radix_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Bucket Sort
================================ EOPN
Python Program to Implement Bucket Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 5 10 3 5 7
Sorted list: [1, 2, 3, 5, 5, 7, 10]

Case 2:
Enter the list of (nonnegative) numbers: 8 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7, 8]

Case 3:
Enter the list of (nonnegative) numbers: 5
Sorted list: [5]
--------------------------------
def bucket_sort(alist):
    largest = max(alist)
    length = len(alist)
    size = largest/length

    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(alist[i]/size)
        if j != length:
            buckets[j].append(alist[i])
        else:
            buckets[length - 1].append(alist[i])

    for i in range(length):
        insertion_sort(buckets[i])

    result = []
    for i in range(length):
        result = result + buckets[i]

    return result

def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = bucket_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Gnome Sort
================================ EOPN
Python Program to Implement Gnome Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 3 2 51 38 1 10 3 0 7 8
Sorted list: [0, 1, 2, 2, 3, 3, 7, 8, 10, 38, 51]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7
Sorted list: [7]
--------------------------------
def gnome_sort(alist):
    for pos in range(1, len(alist)):
        while (pos != 0 and alist[pos] < alist[pos - 1]):
            alist[pos], alist[pos - 1] = alist[pos - 1], alist[pos]
            pos = pos - 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
gnome_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Cocktail Shaker Sort
================================ EOPN
Python Program to Implement Cocktail Shaker Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 18 5 2 10 0 7 4
Sorted list: [0, 2, 3, 4, 5, 7, 10, 18]

Case 2:
Enter the list of numbers: 6 5 4 3 2
Sorted list: [2, 3, 4, 5, 6]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def cocktail_shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    upper = len(alist) - 1
    lower = 0

    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1

        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
cocktail_shaker_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Comb Sort
================================ EOPN
Python Program to Implement Comb Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 8 4 3 7 10 23 4 5
Sorted list: [2, 3, 4, 4, 5, 7, 8, 10, 23]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3
Sorted list: [3]
--------------------------------
def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    gap = len(alist)
    shrink = 1.3

    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)

        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False

        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Shell Sort
================================ EOPN
Python Program to Implement Shell Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 3 1 10
Sorted list: [1, 2, 3, 5, 10]

Case 2:
Enter the list of numbers: 7 6 5 4
Sorted list: [4, 5, 6, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def gaps(size):
    # uses the gap sequence 2^k - 1: 1, 3, 7, 15, 31, ...
    length = size.bit_length()
    for k in range(length - 1, 0, -1):
        yield 2**k - 1


def shell_sort(alist):
    def insertion_sort_with_gap(gap):
        for i in range(gap, len(alist)):
            temp = alist[i]
            j = i - gap
            while (j >= 0 and temp < alist[j]):
                alist[j + gap] = alist[j]
                j = j - gap
            alist[j + gap] = temp

    for g in gaps(len(alist)):
        insertion_sort_with_gap(g)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
shell_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Introsort
================================ EOPN
Python Program to Implement Introsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 2 3 10 9 3 7 2 1 0 9
Sorted list: [0, 1, 2, 2, 3, 3, 3, 5, 7, 9, 9, 10]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 5
Sorted list: [5]
--------------------------------
def introsort(alist):
    maxdepth = (len(alist).bit_length() - 1)*2
    introsort_helper(alist, 0, len(alist), maxdepth)

def introsort_helper(alist, start, end, maxdepth):
    if end - start <= 1:
        return
    elif maxdepth == 0:
        heapsort(alist, start, end)
    else:
        p = partition(alist, start, end)
        introsort_helper(alist, start, p + 1, maxdepth - 1)
        introsort_helper(alist, p + 1, end, maxdepth - 1)

def partition(alist, start, end):
    pivot = alist[start]
    i = start - 1
    j = end

    while True:
        i = i + 1
        while alist[i] < pivot:
            i = i + 1
        j = j - 1
        while alist[j] > pivot:
            j = j - 1

        if i >= j:
            return j

        swap(alist, i, j)

def swap(alist, i, j):
    alist[i], alist[j] = alist[j], alist[i]

def heapsort(alist, start, end):
    build_max_heap(alist, start, end)
    for i in range(end - 1, start, -1):
        swap(alist, start, i)
        max_heapify(alist, index=0, start=start, end=i)

def build_max_heap(alist, start, end):
    def parent(i):
        return (i - 1)//2
    length = end - start
    index = parent(length - 1)
    while index >= 0:
        max_heapify(alist, index, start, end)
        index = index - 1

def max_heapify(alist, index, start, end):
    def left(i):
        return 2*i + 1
    def right(i):
        return 2*i + 2

    size = end - start
    l = left(index)
    r = right(index)
    if (l < size and alist[start + l] > alist[start + index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[start + r] > alist[start + largest]):
        largest = r
    if largest != index:
        swap(alist, start + largest, start + index)
        max_heapify(alist, largest, start, end)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
introsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Binary Insertion Sort
================================ EOPN
Python Program to Implement Binary Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 7 10 3 5 2 1 8 9
Sorted list: [1, 2, 2, 3, 5, 5, 7, 8, 9, 10]

Case 2:
Enter the list of numbers: 7 5 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5, 5, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def binary_insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        pos = binary_search(alist, temp, 0, i) + 1

        for k in range(i, pos, -1):
            alist[k] = alist[k - 1]

        alist[pos] = temp

def binary_search(alist, key, start, end):
    '''If key is in the list at index p, then return p.
    If there are multiple such keys in the list, then return the index of any one.
    If key is not in the list and a < key < b where a and b are elements in the list, then return the index of a.
    If key is not in the list and key < a where a is the first element in the list, then return -1.
    Only elements with indexes start to end - 1 inclusive are considered.
    '''
    if end - start <= 1:
        if key < alist[start]:
            return start - 1
        else:
            return start

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, key, mid, end)
    elif alist[mid] > key:
        return binary_search(alist, key, start, mid)
    else:
        return mid


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
binary_insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Sort using a Binary Search Tree
================================ EOPN
Python Program to Sort using a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 3 4 5 6 1 7 9 10 3
Sorted list: 1 2 3 3 4 4 5 6 7 9 10 

Case 2:
Enter the list of numbers: 6 5 4 3 2 1
Sorted list: 1 2 3 4 5 6 

Case 3:
Enter the list of numbers: 5
Sorted list: 5
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key <= node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)


bstree = BSTree()

alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
for x in alist:
    bstree.add(x)
print('Sorted list: ', end='')
bstree.inorder()
 ETP  
 
Python Program for Depth First Binary Tree Search using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 5
What would you like to do? insert 7 right of 5
What would you like to do? dfs
depth-first search traversal:
entering 1...
entering 2...
entering 4...
at 4...
leaving 4...
at 2...
entering 5...
entering 6...
at 6...
leaving 6...
at 5...
entering 7...
at 7...
leaving 7...
leaving 5...
leaving 2...
at 1...
entering 3...
at 3...
leaving 3...
leaving 1...

What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 4 left of 3
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 4
What would you like to do? dfs
depth-first search traversal:
entering 3...
entering 4...
entering 6...
at 6...
leaving 6...
at 4...
leaving 4...
at 3...
entering 5...
at 5...
leaving 5...
leaving 3...

What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def depth_first(self):
        print('entering {}...'.format(self.key))
        if self.left is not None:
            self.left.depth_first()
        print('at {}...'.format(self.key))
        if self.right is not None:
            self.right.depth_first()
        print('leaving {}...'.format(self.key))


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('depth-first search traversal:')
        if btree is not None:
            btree.depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? dfs
pre-order dfs traversal: 1 2 4 5 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? insert 8 left of 7
What would you like to do? insert 10 right of 7
What would you like to do? dfs
pre-order dfs traversal: 3 6 7 8 10 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def preorder_depth_first(self):
        s = Stack()
        s.push(self)
        while (not s.is_empty()):
            node = s.pop()
            print(node.key, end=' ')
            if node.right is not None:
                s.push(node.right)
            if node.left is not None:
                s.push(node.left)


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


btree = BinaryTree()

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('pre-order dfs traversal: ', end='')
        if btree is not None:
            btree.preorder_depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOPN
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? inorder 1
nth term of inorder traversal: 2
What would you like to do? inorder 2
nth term of inorder traversal: 1
What would you like to do? inorder 3
nth term of inorder traversal: 3
What would you like to do? inorder 4
index exceeds maximum possible index.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 3 left of 1
What would you like to do? insert 7 right of 1
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 5
What would you like to do? inorder 1
nth term of inorder traversal: 3
What would you like to do? inorder 2
nth term of inorder traversal: 6
What would you like to do? inorder 3
nth term of inorder traversal: 5
What would you like to do? inorder 4
nth term of inorder traversal: 1
What would you like to do? inorder 5
nth term of inorder traversal: 7
What would you like to do? inorder 6
index exceeds maximum possible index.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_nth(self, n):
        return self.inorder_nth_helper(n, [])

    def inorder_nth_helper(self, n, inord):
        if self.left is not None:
            temp = self.left.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp
        inord.append(self)
        if n == len(inord):
            return self
        if self.right is not None:
            temp = self.right.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('inorder <index>')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'inorder':
        if btree is not None:
            index = int(do[1].strip().lower())
            node = btree.inorder_nth(index)
            if node is not None:
                print('nth term of inorder traversal: {}'.format(node.key))
            else:
                print('index exceeds maximum possible index.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOPN
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 1 at rot
What would you like to do? largest
Largest element: 1
What would you like to do? insert 2 left of 1
What would you like to do? largest
Largest element: 2
What would you like to do? insert 3 right of 1
What would you like to do? largest
Largest element: 3
What would you like to do? insert 10 left of 3
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 3 at root
What would you like to do? insert 5 left of 3
What would you like to do? insert 2 right of 3
What would you like to do? largest
Largest element: 5
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_largest(self):
        # largest will be a single element list
        # this is a workaround to reference an integer
        largest = []
        self.inorder_largest_helper(largest)
        return largest[0]

    def inorder_largest_helper(self, largest):
        if self.left is not None:
            self.left.inorder_largest_helper(largest)
        if largest == []:
            largest.append(self.key)
        elif largest[0] < self.key:
            largest[0] = self.key
        if self.right is not None:
            self.right.inorder_largest_helper(largest)

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'largest':
        if btree is None:
            print('Tree is empty.')
        else:
            print('Largest element: {}'.format(btree.inorder_largest()))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOPN
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 2
What would you like to do? add 5 below 1
What would you like to do? add 6 below 1
What would you like to do? dfs
Post-order traversal: 3 4 2 5 6 1 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 3 at root
What would you like to do? add 5 below 3
What would you like to do? add 2 below 3
What would you like to do? add 1 below 5
What would you like to do? add 6 below 5
What would you like to do? dfs
Post-order traversal: 1 6 5 2 3 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def postorder(self):
        for child in self.children:
            child.postorder()
        print(self.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'dfs':
        print('Post-order traversal: ', end='')
        tree.postorder()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOPN
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 left of 3
What would you like to do? insert 6 right of 3
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 4 5 6 
BFS traversal of mirror: 
1 3 2 6 5 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 
BFS traversal of mirror: 
1 
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 
BFS traversal of mirror: 
1 3 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def mirror_copy(self):
        mirror = BinaryTree(self.key)
        if self.right is not None:
            mirror.left = self.right.mirror_copy()
        if self.left is not None:
            mirror.right = self.left.mirror_copy()
        return mirror

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            if popped.left is not None:
                queue.append(popped.left)
            if popped.right is not None:
                queue.append(popped.right)
            print(popped.key, end=' ')


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('mirror')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'mirror':
        if btree is not None:
            print('Creating mirror copy...')
            mirror = btree.mirror_copy()
            print('BFS traversal of original tree: ')
            btree.bfs()
            print()
            print('BFS traversal of mirror: ')
            mirror.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOPN
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOKW
--------------------------------
output:
Case 1:
Input post-order traversal: 4 5 2 8 6 7 3 1
Input in-order traversal: 4 2 5 1 6 8 3 7
Binary tree constructed.
Verifying:
Post-order traversal: 4 5 2 8 6 7 3 1 
In-order traversal: 4 2 5 1 6 8 3 7 

Case 2:
Input post-order traversal: 2 1 3
Input in-order traversal: 2 3 1
Binary tree constructed.
Verifying:
Post-order traversal: 2 1 3 
In-order traversal: 2 3 1
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def postorder(self):
        if self.left is not None:
            self.left.postorder()
        if self.right is not None:
            self.right.postorder()
        print(self.key, end=' ')


def construct_btree(postord, inord):
    if postord == [] or inord == []:
        return None
    key = postord[-1]
    node = BinaryTree(key)
    index = inord.index(key)
    node.left = construct_btree(postord[:index], inord[:index])
    node.right = construct_btree(postord[index:-1], inord[index + 1:])
    return node


postord = input('Input post-order traversal: ').split()
postord = [int(x) for x in postord]
inord = input('Input in-order traversal: ').split()
inord = [int(x) for x in inord]

btree = construct_btree(postord, inord)
print('Binary tree constructed.')
print('Verifying:')
print('Post-order traversal: ', end='')
btree.postorder()
print()
print('In-order traversal: ', end='')
btree.inorder()
print()
 ETP  
 
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOPN
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 5
What would you like to do? add 1
What would you like to do? add 10
What would you like to do? add 7
What would you like to do? add 3
What would you like to do? inorder
Inorder traversal: 1 3 5 7 10 
What would you like to do? remove 3
What would you like to do? remove 7
What would you like to do? inorder
Inorder traversal: 1 5 10 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 1 10 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 2
What would you like to do? add 8
What would you like to do? inorder
Inorder traversal: 2 8 
What would you like to do? add 5
What would you like to do? inorder
Inorder traversal: 2 5 8 
What would you like to do? remove 2
What would you like to do? remove 8
What would you like to do? inorder
Inorder traversal: 5 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def replace_node_of_parent(self, new_node):
        if self.parent is not None:
            if new_node is not None:
                new_node.parent = self.parent
            if self.parent.left == self:
                self.parent.left = new_node
            elif self.parent.right == self:
                self.parent.right = new_node
        else:
            self.key = new_node.key
            self.left = new_node.left
            self.right = new_node.right
            if new_node.left is not None:
                new_node.left.parent = self
            if new_node.right is not None:
                new_node.right.parent = self

    def find_min(self):
        current = self
        while current.left is not None:
            current = current.left
        return current

    def remove(self):
        if (self.left is not None and self.right is not None):
            successor = self.right.find_min()
            self.key = successor.key
            successor.remove()
        elif self.left is not None:
            self.replace_node_of_parent(self.left)
        elif self.right is not None:
            self.replace_node_of_parent(self.right)
        else:
            self.replace_node_of_parent(None)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def remove(self, key):
        to_remove = self.search(key)
        if (self.root == to_remove
            and self.root.left is None and self.root.right is None):
            self.root = None
        else:
            to_remove.remove()

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('remove <key>')
print('inorder')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    elif operation == 'remove':
        key = int(do[1])
        bstree.remove(key)
    elif operation == 'inorder':
        print('Inorder traversal: ', end='')
        bstree.inorder()
        print()
    elif operation == 'quit':
        break
 ETP  
 
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOPN
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 3
What would you like to do? add 2
What would you like to do? add 10
What would you like to do? add 4
What would you like to do? smallest
Smallest element: 2
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 10
What would you like to do? smallest
Smallest element: 10
What would you like to do? largest
Largest element: 10
What would you like to do? add 4
What would you like to do? add 12
What would you like to do? smallest
Smallest element: 4
What would you like to do? largest
Largest element: 12
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)

    def get_smallest(self):
        if self.root is not None:
            current = self.root
            while current.left is not None:
                current = current.left
            return current.key

    def get_largest(self):
        if self.root is not None:
            current = self.root
            while current.right is not None:
                current = current.right
            return current.key


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('smallest')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    if operation == 'smallest':
        smallest = bstree.get_smallest()
        print('Smallest element: {}'.format(smallest))
    if operation == 'largest':
        largest = bstree.get_largest()
        print('Largest element: {}'.format(largest))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Leaf Node in a Tree
================================ EOPN
Python Program to Count Number of Leaf Node in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of leaf nodes: 2
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 2 at root
What would you like to do? add 7 below 2
What would you like to do? add 8 below 7
What would you like to do? add 9 below 8
What would you like to do? count
Number of leaf nodes: 1
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_leaf_nodes(self):
        leaf_nodes = []
        self.count_leaf_nodes_helper(leaf_nodes)
        return len(leaf_nodes)

    def count_leaf_nodes_helper(self, leaf_nodes):
        if self.children == []:
            leaf_nodes.append(self)
        else:
            for child in self.children:
                child.count_leaf_nodes_helper(leaf_nodes)


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_leaf_nodes()
            print('Number of leaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 right of 2
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? count
Number of nodes in tree: 4
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? count
Number of nodes in tree: 0
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? count
Number of nodes in tree: 1
inorder traversal of binary tree: 1 
What would you like to do? insert 2 right of 1
inorder traversal of binary tree: 1 2 
What would you like to do? count
Number of nodes in tree: 2
inorder traversal of binary tree: 1 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def count_nodes(node):
    if node is None:
        return 0
    return 1 + count_nodes(node.left) + count_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('count')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'count':
        print('Number of nodes in tree: {}'.format(count_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOPN
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? border
Border of tree: 
1 2 3 
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? border
Border of tree: 
1 2 4 5 6 7 3 
What would you like to do? insert 8 left of 4
What would you like to do? insert 9 right of 4
What would you like to do? insert 10 left of 5
What would you like to do? insert 11 right of 5
What would you like to do? insert 12 left of 6
What would you like to do? insert 13 right of 6
What would you like to do? insert 14 left of 7
What would you like to do? insert 15 right of 7
What would you like to do? border
Border of tree: 
1 2 4 8 9 10 11 12 13 14 15 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 left of 2
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? insert 6 right of 4
What would you like to do? insert 7 right of 1
What would you like to do? insert 8 right of 7
What would you like to do? border
Border of tree: 
1 2 3 5 6 8 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left_boundary(self):
        current = self
        while True:
            if current.left is not None:
                print(current.key, end=' ')
                current = current.left
            elif current.right is not None:
                print(current.key, end=' ')
                current = current.right
            else:
                break

    def print_right_boundary(self):
        if self.right is not None:
            self.right.print_right_boundary()
            print(self.key, end=' ')
        elif self.left is not None:
            self.left.print_right_boundary()
            print(self.key, end=' ')


    def print_leaves(self):
        if self.left is not None:
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
        if (self.left is None
            and self.right is None):
            print(self.key, end=' ')

    def print_border(self):
        print(self.key, end=' ')
        if self.left is not None:
            self.left.print_left_boundary()
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
            self.right.print_right_boundary()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('border')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'border':
        if btree is not None:
            print('Border of tree: ')
            btree.print_border()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOPN
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? count
Number of nonleaf nodes: 0
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of nonleaf nodes: 1
What would you like to do? add 4 below 2
What would you like to do? count
Number of nonleaf nodes: 2
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 3
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 3
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 6 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 7 below 6
What would you like to do? count
Number of nonleaf nodes: 5
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_nonleaf_nodes(self):
        nonleaf_count = 0
        if self.children != []:
            nonleaf_count = 1
        for child in self.children:
            nonleaf_count = nonleaf_count + child.count_nonleaf_nodes()
        return nonleaf_count


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_nonleaf_nodes()
            print('Number of nonleaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of all Nodes in a Tree
================================ EOPN
Python Program to Find the Sum of all Nodes in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? sum
Tree is empty.
What would you like to do? add 3 at root
What would you like to do? sum
Sum of all nodes: 3
What would you like to do? add 4 below 3
What would you like to do? sum
Sum of all nodes: 7
What would you like to do? add 5 below 3
What would you like to do? add 10 below 4
What would you like to do? sum
Sum of all nodes: 22
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 1
What would you like to do? add 5 below 2
What would you like to do? add 6 below 3
What would you like to do? add 7 below 4
What would you like to do? sum
Sum of all nodes: 28
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def sum_nodes(self):
        summation = self.key
        for child in self.children:
            summation = summation + child.sum_nodes()
        return summation


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('sum')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'sum':
        if tree is None:
            print('Tree is empty.')
        else:
            summation = tree.sum_nodes()
            print('Sum of all nodes: {}'.format(summation))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOPN
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 2
What would you like to do? add 5 below 2
What would you like to do? display
BFS traversal display: 1 2 3 4 5 
What would you like to do? remove 1
What would you like to do? display
BFS traversal display: 4 2 3 5 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 4 2 3 
What would you like to do? remove 4
What would you like to do? display
BFS traversal display: 2 3 
What would you like to do? remove 3
What would you like to do? remove 2
What would you like to do? display
Tree is empty.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 9 below 7
What would you like to do? add 11 below 9
What would you like to do? add 12 below 7
What would you like to do? display
BFS traversal display: 5 7 9 12 11 
What would you like to do? remove 9
What would you like to do? display
BFS traversal display: 5 7 11 12 
What would you like to do? remove 12
What would you like to do? display
BFS traversal display: 5 7 11 
What would you like to do? remove 7
What would you like to do? display
BFS traversal display: 5 11 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 11 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None, parent=None):
        self.key = data
        self.children = []
        self.parent = parent

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def remove(self):
        parent = self.parent
        index = parent.children.index(self)
        parent.children.remove(self)
        for child in reversed(self.children):
            parent.children.insert(index, child)
            child.parent = parent

    def bfs_display(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('remove <data>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            new_node.parent = ref_node
            ref_node.add(new_node)

    elif operation == 'remove':
        data = int(do[1])
        to_remove = tree.search(data)
        if tree == to_remove:
            if tree.children == []:
                tree = None
            else:
                leaf = tree.children[0]
                while leaf.children != []:
                    leaf = leaf.children[0]
                leaf.parent.children.remove(leaf)
                leaf.parent = None
                leaf.children = tree.children
                tree = leaf
        else:
            to_remove.remove()

    elif operation == 'display':
        if tree is not None:
            print('BFS traversal display: ', end='')
            tree.bfs_display()
            print()
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOPN
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 1 at root
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 0 left of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 2 right of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 3 left of 2
What would you like to do? bst
Tree is not a binary search tree.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 5 at root
What would you like to do? insert 1 left of 5
What would you like to do? insert 10 right of 5
What would you like to do? insert 0 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 15 right of 10
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def is_bst_p(self):
        if self.left is not None:
            if self.key < self.left.key:
                return False
            elif not self.left.is_bst_p():
                return False
        if self.right is not None:
            if self.key > self.right.key:
                return False
            elif not self.right.is_bst_p():
                return False
        return True


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('bst')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'bst':
        if btree is not None:
            if btree.is_bst_p():
                print('Tree is a binary search tree.')
            else:
                print('Tree is not a binary search tree.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOPN
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? paths
Tree is empty.
What would you like to do? add 1 at root
What would you like to do? paths
1 
What would you like to do? add 2 below 1
What would you like to do? paths
1 2 
What would you like to do? add 3 below 1
What would you like to do? paths
1 2 
1 3 
What would you like to do? add 4 below 1
What would you like to do? paths
1 2 
1 3 
1 4 
What would you like to do? add 8 below 2
What would you like to do? paths
1 2 8 
1 3 
1 4 
What would you like to do? add 7 below 2
What would you like to do? paths
1 2 8 
1 2 7 
1 3 
1 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? add 1 at root
What would you like to do? add 10 below 1
What would you like to do? add 11 below 10
What would you like to do? add 12 below 11
What would you like to do? add 20 below 1
What would you like to do? add 21 below 20
What would you like to do? add 30 below 1
What would you like to do? paths
1 10 11 12 
1 20 21 
1 30 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def print_all_paths_to_leaf(self):
        self.print_all_paths_to_leaf_helper([])

    def print_all_paths_to_leaf_helper(self, path_till_now):
        path_till_now.append(self.key)
        if self.children == []:
            for key in path_till_now:
                print(key, end=' ')
            print()
        else:
            for child in self.children:
                child.print_all_paths_to_leaf_helper(path_till_now[:])


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('paths')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'paths':
        if tree is None:
            print('Tree is empty.')
        else:
            tree.print_all_paths_to_leaf()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print only Nodes in Left SubTree
================================ EOPN
Python Program to Print only Nodes in Left SubTree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? left
Nodes of left subtree: 4 2 5 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 10 at root
What would you like to do? left
Nodes of left subtree: 
What would you like to do? insert 1 right of 10
What would you like to do? insert 2 left of 10
What would you like to do? insert 3 right of 2
What would you like to do? left
Nodes of left subtree: 2 3 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left(self):
        if self.left is not None:
            self.left.inorder()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('left')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'left':
        print('Nodes of left subtree: ', end='')
        if btree is not None:
            btree.print_left()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOPN
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 1 2 
What would you like to do? add 3 below 1
What would you like to do? add 10 below 2
What would you like to do? add 12 below 2
What would you like to do? add 14 below 3
What would you like to do? add 7 below 14
What would you like to do? bfs
BFS traversal: 1 2 3 10 12 14 7 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 8 below 5
What would you like to do? add 4 below 7
What would you like to do? add 3 below 7
What would you like to do? add 1 below 8
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 5 7 8 4 3 1 2 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('bfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'bfs':
        if tree is None:
            print('Tree is empty.')
        else:
            print('BFS traversal: ', end='')
            tree.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 7 left of 3
inorder traversal of binary tree: 7 3 
What would you like to do? sum
Sum of nodes in tree: 10
inorder traversal of binary tree: 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 2 at root
inorder traversal of binary tree: 2 
What would you like to do? insert 10 left of 2
inorder traversal of binary tree: 10 2 
What would you like to do? insert 1 right of 2
inorder traversal of binary tree: 10 2 1 
What would you like to do? insert 5 left of 1
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? sum
Sum of nodes in tree: 18
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def sum_nodes(node):
    if node is None:
        return 0
    return node.key + sum_nodes(node.left) + sum_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('sum')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'sum':
        print('Sum of nodes in tree: {}'.format(sum_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Graph
================================ EOPN
Python Program to Implement Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? display
Vertices: 1 2 
Edges: 

What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 

What would you like to do? add edge 1 3
What would you like to do? add edge 3 1
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 
(src=1, dest=3, weight=1) 
(src=3, dest=1, weight=1) 

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 4 5
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 

What would you like to do? add edge 5 4
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 
(src=5, dest=4, weight=1) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> [weight]')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    if len(do) == 5:
                        weight = int(do[4])
                        g.add_edge(src, dest, weight)
                    else:
                        g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Breadth-First Search on a Graph
================================ EOPN
Python Program to Implement Breadth-First Search on a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add vertex 9
What would you like to do? add vertex 10
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 1 5
What would you like to do? add edge 2 6
What would you like to do? add edge 3 7
What would you like to do? add edge 3 8
What would you like to do? add edge 4 8
What would you like to do? add edge 8 10
What would you like to do? add edge 5 10
What would you like to do? add edge 6 9
What would you like to do? add edge 9 10
What would you like to do? bfs 1
Breadth-first Traversal: 1 3 2 5 7 8 6 10 9 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bfs 1
Breadth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 
What would you like to do? bfs 2
Breadth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? bfs 2
Breadth-first Traversal: 2 1 
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 3 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def display_bfs(vertex):
    """Display BFS Traversal starting at vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        print(current.get_key(), end=' ')
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('bfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'bfs':
        key = int(do[1])
        print('Breadth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_bfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1, 4]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 5 4
What would you like to do? reachable 4
All nodes reachable from 4: [4]
What would you like to do? reachable 5
All nodes reachable from 5: [4, 5]
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2, 3]
What would you like to do? reachable 3
All nodes reachable from 3: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_all_reachable_nodes(vertex):
    """Return set containing all vertices reachable from vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)
    return visited


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 5 1
What would you like to do? add edge 4 2
What would you like to do? components
Component 1: [5, 2, 4, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
Vertex already exists.
What would you like to do? components
Component 1: [2, 3, 1]
Component 2: [4]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        component[current] = label
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            component_vertices = [v.get_key() for v in component
                                  if component[v] == label]
            print('Component {}:'.format(label), component_vertices)



    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOPN
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
What would you like to do? add edge 1 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 1): 3 1
Vertex 2 (distance 1): 2 1
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? add edge 4 5
What would you like to do? add edge 4 6
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 3): 5 4 2 1
Vertex 6 (distance 3): 6 4 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? add edge 2 6
What would you like to do? add edge 1 5
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 1): 5 1
Vertex 6 (distance 2): 6 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        # dictionary containing destination vertices mapped to the weight of the
        # edge with which they are joined to this vertex
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_shortest_paths(src):
    """Returns tuple of two dictionaries: (parent, distance)

    parent contains vertices mapped to their parent vertex in the shortest
    path from src to that vertex.
    distance contains vertices mapped to their shortest distance from src.
    """
    parent = {src: None}
    distance = {src: 0}

    visited = set()
    q = Queue()
    q.enqueue(src)
    visited.add(src)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                distance[dest] = distance[current] + 1
                q.enqueue(dest)
    return (parent, distance)

g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('shortest <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        src = g.get_vertex(key)
        parent, distance = find_shortest_paths(src)

        print('Path from destination vertices to source vertex {}:'.format(key))
        for v in parent:
            print('Vertex {} (distance {}): '.format(v.get_key(), distance[v]),
                  end='')
            while parent[v] is not None:
                print(v.get_key(), end = ' ')
                v = parent[v]
            print(src.get_key()) # print source vertex

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 2 4
What would you like to do? add edge 2 5
What would you like to do? add edge 6 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 6 2
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_cycle_present(vertex, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {vertex: None}
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                q.enqueue(dest)
            else:
                if parent[current] is not dest:
                    return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 5 6
What would you like to do? add edge 6 7
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 7 1
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    visited.add(vertex)
    q = Queue()
    q.enqueue(vertex)
    while not q.is_empty():
        current = q.dequeue()

        next_colour = 1 - colour[current] # switch colour
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                colour[dest] = next_colour
                q.enqueue(dest)
            else:
                if colour[dest] != next_colour:
                    return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 3 5
What would you like to do? add edge 1 6
What would you like to do? add edge 6 2
What would you like to do? dfs 1
Depth-first Traversal: 1 6 2 3 4 5 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 1 2 
What would you like to do? dfs 2
Depth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? dfs 2
Depth-first Traversal: 2 3 4 1 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def display_dfs(v):
    """Display DFS traversal starting at vertex v."""
    display_dfs_helper(v, set())


def display_dfs_helper(v, visited):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes."""
    visited.add(v)
    print(v.get_key(), end=' ')
    for dest in v.get_neighbours():
        if dest not in visited:
            display_dfs_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? add edge 3 7
What would you like to do? dfs 1
Depth-first Traversal: 1 5 6 2 3 7 4 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


def display_dfs(v):
    visited = set()
    s = Stack()
    s.push(vertex)
    while not s.is_empty():
        current = s.pop()
        if current in visited:
            continue
        print(current.get_key(), end=' ')
        visited.add(current)
        for dest in current.get_neighbours():
            if dest not in visited:
                s.push(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print DFS Numbering of a Graph
================================ EOPN
Python Program to Print DFS Numbering of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Visiting 3... discovered time = 3
Visiting 4... discovered time = 4
Leaving 4... finished time = 5
Leaving 3... finished time = 6
Leaving 2... finished time = 7
Visiting 5... discovered time = 8
Visiting 6... discovered time = 9
Leaving 6... finished time = 10
Leaving 5... finished time = 11
Leaving 1... finished time = 12

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Leaving 1... finished time = 2

What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Leaving 2... finished time = 3
Leaving 1... finished time = 4

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to

def dfs(v, pre, post):
    """Display DFS traversal starting at vertex v. Stores pre and post times in
    dictionaries pre and post."""
    dfs_helper(v, set(), pre, post, [0])

def dfs_helper(v, visited, pre, post, time):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes, dictionaries pre and post to store
    discovered and finished times and the one-element list time to keep track of
    current time."""
    visited.add(v)
    time[0] = time[0] + 1
    pre[v] = time[0]
    print('Visiting {}... discovered time = {}'.format(v.get_key(), time[0]))
    for dest in v.get_neighbours():
        if dest not in visited:
            dfs_helper(dest, visited, pre, post, time)
    time[0] = time[0] + 1
    post[v] = time[0]
    print('Leaving {}... finished time = {}'.format(v.get_key(), time[0]))


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ')
        vertex = g.get_vertex(key)
        pre = dict()
        post = dict()
        dfs(vertex, pre, post)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 4 5
What would you like to do? add edge 5 6
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 4
All nodes reachable from 4: [6, 4, 5]
What would you like to do? reachable 7
All nodes reachable from 7: [7]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def find_all_reachable_nodes(v):
    """Return set containing all vertices reachable from vertex."""
    reachable = set()
    find_all_reachable_nodes_helper(v, reachable)
    return reachable


def find_all_reachable_nodes_helper(v, visited):
    """Add all vertices visited by DFS traversal starting at v to the set visited."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            find_all_reachable_nodes_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [2, 1]
Component 2: [3]
Component 3: [4]
Component 4: [5]
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 1 5
What would you like to do? components
Component 1: [2, 5, 1]
Component 2: [4, 3]
What would you like to do? add edge 2 4
What would you like to do? components
Component 1: [4, 2, 5, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? components
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? components
Component 1: [1]
Component 2: [2]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [1, 2]
What would you like to do? add vertex 3
What would you like to do? components
Component 1: [1, 2]
Component 2: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    label_all_reachable_helper(vertex, set(), component, label)


def label_all_reachable_helper(vertex, visited, component, label):
    """Set component[v] = label for all v in the component containing
    vertex. Uses set visited to keep track of nodes alread visited."""
    visited.add(vertex)
    component[vertex] = label
    for dest in vertex.get_neighbours():
        if dest not in visited:
            label_all_reachable_helper(dest, visited, component, label)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            print('Component {}:'.format(label),
                  [v.get_key() for v in component if component[v] == label])


    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 5 1
What would you like to do? add edge 6 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 5
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    return is_bipartite_helper(vertex, visited, colour)


def is_bipartite_helper(v, visited, colour):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited. Uses dictionary colour to keep
    track of colour of each vertex."""
    visited.add(v)
    next_colour = 1 - colour[v] # switch colour
    for dest in v.get_neighbours():
        if dest not in visited:
            colour[dest] = next_colour
            if not is_bipartite_helper(dest, visited, colour):
                return False
        else:
            if colour[dest] != next_colour:
                return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add vertex 5
What would you like to do? add edge 4 5
What would you like to do? add edge 5 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(v, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {v: None}
    return is_cycle_present_helper(v, visited, parent)


def is_cycle_present_helper(v, visited, parent):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited. Uses dictionary parent to keep
    track of parents of nodes in the DFS tree."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            parent[dest] = v
            if is_cycle_present_helper(dest, visited, parent):
                return True
        else:
            if parent[v] is not dest:
                return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 4
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 3 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(graph):
    """Return True if cycle is present in the graph."""
    on_stack = set()
    visited = set()
    for v in graph:
        if v not in visited:
            if is_cycle_present_helper(v, visited, on_stack):
                return True
    return False


def is_cycle_present_helper(v, visited, on_stack):
    """Return True if the DFS traversal starting at vertex v detects a
    cycle. Uses set visited to keep track of nodes that have been visited. Uses
    set on_stack to keep track of nodes that are 'on the stack' of the recursive
    calls."""
    if v in on_stack:
        return True
    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if is_cycle_present_helper(dest, visited, on_stack):
                return True
    on_stack.remove(v)
    visited.add(v)
    return False


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_edge_exist(v1, v2):
                    g.add_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        if is_cycle_present(g):
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOPN
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? topological
Topological Sorting: [3, 2, 1]
What would you like to do? add edge 1 2
What would you like to do? topological
Topological Sorting: [3, 1, 2]
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 4 5
What would you like to do? topological
Topological Sorting: [7, 6, 4, 5, 1, 2, 3]
What would you like to do? add edge 4 6
What would you like to do? topological
Topological Sorting: [7, 4, 5, 6, 1, 2, 3]
What would you like to do? add edge 5 7
What would you like to do? topological
Topological Sorting: [4, 5, 7, 6, 1, 2, 3]
What would you like to do? add edge 3 4
What would you like to do? topological
Topological Sorting: [1, 2, 3, 4, 5, 7, 6]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? topological
Topological Sorting: [1]
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add edge 3 2
What would you like to do? topological
Graph is not a DAG.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def get_topological_sorting(graph):
    """Return a topological sorting of the DAG. Return None if graph is not a DAG."""
    tlist = []
    visited = set()
    on_stack = set()
    for v in graph:
        if v not in visited:
            if not get_topological_sorting_helper(v, visited, on_stack, tlist):
                return None
    return tlist


def get_topological_sorting_helper(v, visited, on_stack, tlist):
    """Perform DFS traversal starting at vertex v and store a topological
    sorting of the DAG in tlist. Return False if it is found that the graph is
    not a DAG. Uses set visited to keep track of already visited nodes."""
    if v in on_stack:
        # graph has cycles and is therefore not a DAG.
        return False

    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if not get_topological_sorting_helper(dest, visited, on_stack, tlist):
                return False
    on_stack.remove(v)
    visited.add(v)
    tlist.insert(0, v.get_key()) # prepend node key to tlist
    return True


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('topological')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'topological':
        tlist = get_topological_sorting(g)
        if tlist is not None:
            print('Topological Sorting: ', end='')
            print(tlist)
        else:
            print('Graph is not a DAG.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOPN
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 80
What would you like to do? add edge 3 4 70
What would you like to do? add edge 2 5 20
What would you like to do? add edge 2 3 6
What would you like to do? add edge 5 6 50
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? shortest 1
Distances from 1: 
Distance to 6: 45
Distance to 3: 16
Distance to 4: 86
Distance to 5: 30
Distance to 2: 10
Distance to 7: 40
Distance to 1: 0

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 20
What would you like to do? add edge 3 4 30
What would you like to do? add edge 1 4 100
What would you like to do? shortest 1
Distances from 1: 
Distance to 2: 10
Distance to 4: 60
Distance to 3: 30
Distance to 1: 0
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('shortest <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = dijkstra(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Bellman-Ford Algorithm
================================ EOPN
Python Program to Implement Bellman-Ford Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 8 8
What would you like to do? add edge 2 6 2
What would you like to do? add edge 3 2 1
What would you like to do? add edge 3 4 1
What would you like to do? add edge 4 5 3
What would you like to do? add edge 5 6 -1
What would you like to do? add edge 6 3 -2
What would you like to do? add edge 7 2 -4
What would you like to do? add edge 7 6 -1
What would you like to do? add edge 8 7 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 5: 9
Distance to 6: 7
Distance to 7: 9
Distance to 2: 5
Distance to 1: 0
Distance to 8: 8
Distance to 3: 5
Distance to 4: 6

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0

What would you like to do? add vertex 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 2: inf

What would you like to do? add edge 1 2 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 3 -1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 2

What would you like to do? add edge 3 2 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 1

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('bellman-ford <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'bellman-ford':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = bellman_ford(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Floyd-Warshall Algorithm
================================ EOPN
Python Program to Implement Floyd-Warshall Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 1 3 8
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 5 -> 4 -> 3 -> 2 (distance 1)
From 1 to 3: 1 -> 5 -> 4 -> 3 (distance -3)
From 1 to 4: 1 -> 5 -> 4 (distance 2)
From 1 to 5: 1 -> 5 (distance -4)
From 2 to 1: 2 -> 4 -> 1 (distance 3)
From 2 to 3: 2 -> 4 -> 3 (distance -4)
From 2 to 4: 2 -> 4 (distance 1)
From 2 to 5: 2 -> 4 -> 1 -> 5 (distance -1)
From 3 to 1: 3 -> 2 -> 4 -> 1 (distance 7)
From 3 to 2: 3 -> 2 (distance 4)
From 3 to 4: 3 -> 2 -> 4 (distance 5)
From 3 to 5: 3 -> 2 -> 4 -> 1 -> 5 (distance 3)
From 4 to 1: 4 -> 1 (distance 2)
From 4 to 2: 4 -> 3 -> 2 (distance -1)
From 4 to 3: 4 -> 3 (distance -5)
From 4 to 5: 4 -> 1 -> 5 (distance -2)
From 5 to 1: 5 -> 4 -> 1 (distance 8)
From 5 to 2: 5 -> 4 -> 3 -> 2 (distance 5)
From 5 to 3: 5 -> 4 -> 3 (distance 1)
From 5 to 4: 5 -> 4 (distance 6)
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 -7
What would you like to do? add edge 1 3 5
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 2 (distance 10)
From 1 to 3: 1 -> 2 -> 3 (distance 3)
From 2 to 3: 2 -> 3 (distance -7)
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def floyd_warshall(g):
    """Return dictionaries distance and next_v.

    distance[u][v] is the shortest distance from vertex u to v.
    next_v[u][v] is the next vertex after vertex v in the shortest path from u
    to v. It is None if there is no path between them. next_v[u][u] should be
    None for all u.

    g is a Graph object which can have negative edge weights.
    """
    distance = {v:dict.fromkeys(g, float('inf')) for v in g}
    next_v = {v:dict.fromkeys(g, None) for v in g}

    for v in g:
        for n in v.get_neighbours():
            distance[v][n] = v.get_weight(n)
            next_v[v][n] = n

    for v in g:
         distance[v][v] = 0
         next_v[v][v] = None

    for p in g: 
        for v in g:
            for w in g:
                if distance[v][w] > distance[v][p] + distance[p][w]:
                    distance[v][w] = distance[v][p] + distance[p][w]
                    next_v[v][w] = next_v[v][p]

    return distance, next_v


def print_path(next_v, u, v):
    """Print shortest path from vertex u to v.

    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u
    in the shortest path from u to v. It is None if there is no path between
    them. next_v[u][u] should be None for all u.

    u and v are Vertex objects.
    """
    p = u
    while (next_v[p][v]):
        print('{} -> '.format(p.get_key()), end='')
        p = next_v[p][v]
    print('{} '.format(v.get_key()), end='')


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('floyd-warshall')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'floyd-warshall':
        distance, next_v = floyd_warshall(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                if next_v[start][end]:
                    print('From {} to {}: '.format(start.get_key(),
                                                    end.get_key()),
                            end = '')
                    print_path(next_v, start, end)
                    print('(distance {})'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Transitive Closure of a Graph
================================ EOPN
Python Program to Find Transitive Closure of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
transitive-closure
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
2, 2
What would you like to do? add edge 1 2 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
2, 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
1, 3
2, 2
2, 3
3, 3
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
transitive-closure
display
quit
What would you like to do? add vertex 0
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 0 1
What would you like to do? add edge 0 2
What would you like to do? add edge 1 2
What would you like to do? add edge 2 0
What would you like to do? add edge 2 3
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
0, 0
0, 1
0, 2
0, 3
1, 0
1, 1
1, 2
1, 3
2, 0
2, 1
2, 2
2, 3
3, 3
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def transitive_closure(g):
    """Return dictionary reachable.

    reachable[u][v] = True iff there is a path from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    reachable = {v:dict.fromkeys(g, False) for v in g}

    for v in g:
        for n in v.get_neighbours():
            reachable[v][n] = True

    for v in g:
         reachable[v][v] = True

    for p in g: 
        for v in g:
            for w in g:
                if reachable[v][p] and reachable[p][w]:
                    reachable[v][w] = True

    return reachable


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('transitive-closure')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'transitive-closure':
        reachable = transitive_closure(g)
        print('All pairs (u, v) such that there is a path from u to v: ')
        for start in g:
            for end in g:
                if reachable[start][end]:
                    print('{}, {}'.format(start.get_key(), end.get_key()))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 3 18
What would you like to do? add edge 1 2 10
What would you like to do? add edge 3 4 70
What would you like to do? add edge 3 2 6
What would you like to do? add edge 2 5 20
What would you like to do? add edge 5 6 10
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 7 
Edges: 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=2, dest=3, weight=6) 
(src=3, dest=2, weight=6) 
(src=3, dest=4, weight=70) 
(src=4, dest=3, weight=70) 
(src=5, dest=6, weight=10) 
(src=5, dest=2, weight=20) 
(src=6, dest=5, weight=10) 
(src=6, dest=7, weight=5) 
(src=7, dest=6, weight=5) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 100
What would you like to do? add edge 1 3 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=10) 
(src=1, dest=3, weight=50) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=50) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_prim(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    # if graph is empty
    if not g:
        return mst

    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    nearest_neighbour = {}
    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    smallest_distance = {}
    # v is in unvisited iff v has not been added to the MST
    unvisited = set(g)

    u = next(iter(g)) # select any one vertex from g
    mst.add_vertex(u.get_key()) # add a copy of it to the MST
    unvisited.remove(u)

    # for each neighbour of vertex u
    for n in u.get_neighbours():
        if n is u:
            # avoid self-loops
            continue
        # update dictionaries
        nearest_neighbour[n] = mst.get_vertex(u.get_key())
        smallest_distance[n] = u.get_weight(n)

    # loop until smallest_distance becomes empty
    while (smallest_distance):
        # get nearest vertex outside the MST
        outside_mst = min(smallest_distance, key=smallest_distance.get)
        # get the nearest neighbour inside the MST
        inside_mst = nearest_neighbour[outside_mst]

        # add a copy of the outside vertex to the MST
        mst.add_vertex(outside_mst.get_key())
        # add the edge to the MST
        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),
                     smallest_distance[outside_mst])
        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),
                     smallest_distance[outside_mst])

        # now that outside_mst has been added to the MST, remove it from our
        # dictionaries and the set unvisited
        unvisited.remove(outside_mst)
        del smallest_distance[outside_mst]
        del nearest_neighbour[outside_mst]

        # update dictionaries
        for n in outside_mst.get_neighbours():
            if n in unvisited:
                if n not in smallest_distance:
                    smallest_distance[n] = outside_mst.get_weight(n)
                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())
                else:
                    if smallest_distance[n] > outside_mst.get_weight(n):
                        smallest_distance[n] = outside_mst.get_weight(n)
                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_prim(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 5 30
What would you like to do? add edge 1 4 40
What would you like to do? add edge 2 5 20
What would you like to do? add edge 4 5 40
What would you like to do? add edge 5 3 40
What would you like to do? add edge 5 6 70
What would you like to do? add edge 3 6 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 
Edges: 
(src=1, dest=4, weight=40) 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=3, dest=5, weight=40) 
(src=3, dest=6, weight=50) 
(src=4, dest=1, weight=40) 
(src=5, dest=2, weight=20) 
(src=5, dest=3, weight=40) 
(src=6, dest=3, weight=50) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 20
What would you like to do? add edge 2 3 30
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=3, weight=20) 
(src=1, dest=2, weight=10) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=20) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_vertex_exist(self, key):
        return key in self.vertices

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_krusal(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    if len(g) == 1:
        u = next(iter(g)) # get the single vertex
        mst.add_vertex(u.get_key()) # add a copy of it to mst
        return mst

    # get all the edges in a list
    edges = []
    for v in g:
        for n in v.get_neighbours():
            # avoid adding two edges for each edge of the undirected graph
            if v.get_key() < n.get_key():
                edges.append((v, n))

    # sort edges
    edges.sort(key=lambda edge: edge[0].get_weight(edge[1]))

    # initially, each vertex is in its own component
    component = {}
    for i, v in enumerate(g):
        component[v] = i

    # next edge to try
    edge_index = 0

    # loop until mst has the same number of vertices as g
    while len(mst) < len(g):
        u, v = edges[edge_index]
        edge_index += 1

        # if adding edge (u, v) will not form a cycle
        if component[u] != component[v]:

            # add to mst
            if not mst.does_vertex_exist(u.get_key()):
                mst.add_vertex(u.get_key())
            if not mst.does_vertex_exist(v.get_key()):
                mst.add_vertex(v.get_key())
            mst.add_edge(u.get_key(), v.get_key(), u.get_weight(v))
            mst.add_edge(v.get_key(), u.get_key(), u.get_weight(v))

            # merge components of u and v
            for w in g:
                if component[w] == component[v]:
                    component[w] = component[u]

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_krusal(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Johnsons Algorithm
================================ EOPN
Python Program to Implement Johnsons Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 3 8
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 1
1 to 3 distance -3
1 to 4 distance 2
1 to 5 distance -4
2 to 1 distance 3
2 to 2 distance 0
2 to 3 distance -4
2 to 4 distance 1
2 to 5 distance -1
3 to 1 distance 7
3 to 2 distance 4
3 to 3 distance 0
3 to 4 distance 5
3 to 5 distance 3
4 to 1 distance 2
4 to 2 distance -1
4 to 3 distance -5
4 to 4 distance 0
4 to 5 distance -2
5 to 1 distance 8
5 to 2 distance 5
5 to 3 distance 1
5 to 4 distance 6
5 to 5 distance 0
What would you like to do? quit

Case 2:
python 226__graph_johnson.py
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance inf
2 to 1 distance inf
2 to 2 distance 0
What would you like to do? add edge 1 2 100
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 -50
What would you like to do? add edge 1 3 60
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 100
1 to 3 distance 50
2 to 1 distance inf
2 to 2 distance 0
2 to 3 distance -50
3 to 1 distance inf
3 to 2 distance inf
3 to 3 distance 0
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def set_weight(self, dest, weight):
        """Set weight of edge from this vertex to dest."""
        self.points_to[dest] = weight

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def johnson(g):
    """Return distance where distance[u][v] is the min distance from u to v.

    distance[u][v] is the shortest distance from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    # add new vertex q
    g.add_vertex('q')
    # let q point to all other vertices in g with zero-weight edges
    for v in g:
        g.add_edge('q', v.get_key(), 0)

    # compute shortest distance from vertex q to all other vertices
    bell_dist = bellman_ford(g, g.get_vertex('q'))

    # set weight(u, v) = weight(u, v) + bell_dist(u) - bell_dist(v) for each
    # edge (u, v)
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[v] - bell_dist[n])

    # remove vertex q
    # This implementation of the graph stores edge (u, v) in Vertex object u
    # Since no other vertex points back to q, we do not need to worry about
    # removing edges pointing to q from other vertices.
    del g.vertices['q']

    # distance[u][v] will hold smallest distance from vertex u to v
    distance = {}
    # run dijkstra's algorithm on each source vertex
    for v in g:
        distance[v] = dijkstra(g, v)

    # correct distances
    for v in g:
        for w in g:
            distance[v][w] += bell_dist[w] - bell_dist[v]

    # correct weights in original graph
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[n] - bell_dist[v])

    return distance


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('johnson')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'johnson':
        distance = johnson(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                print('{} to {}'.format(start.get_key(), end.get_key()), end=' ')
                print('distance {}'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Read a Linked List in Reverse
================================ EOPN
Python Program to Read a Linked List in Reverse
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 5
Enter data item: 3
Enter data item: 10
Enter data item: 2
The linked list: 2 10 3 5 

Case 2:
How many elements would you like to add? 1
Enter data item: 8
The linked list: 8 

Case 3:
How many elements would you like to add? 3
Enter data item: 1
Enter data item: 2
Enter data item: 3
The linked list: 3 2 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    node = Node(data)
    a_llist.insert_at_beg(node)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Create a Linked List & Display the Elements in the List
================================ EOPN
Python Program to Create a Linked List & Display the Elements in the List
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: -2
Enter data item: 1
Enter data item: 5
Enter data item: 0
The linked list: 3 -2 1 5 0 

Case 2:
How many elements would you like to add? 1
Enter data item: 6
The linked list: 6 

Case 3:
How many elements would you like to add? 4
Enter data item: 2
Enter data item: 9
Enter data item: 3
Enter data item: 2
The linked list: 2 9 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
Python Program to Search for an Element in the Linked List using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 5
5 is at index 1.

Case 2:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 7
7 is at index 4.

Case 3:
The linked list: 3 5 0 10 7 
What data item would you like to search for? 4
4 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        return self.find_index_helper(key, 0, self.head)

    def find_index_helper(self, key, start, node):
        if node is None:
            return -1

        if node.data == key:
            return start
        else:
            return self.find_index_helper(key, start + 1, node.next)

a_llist = LinkedList()
for data in [3, 5, 0, 10, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Search for an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 9
9 is at index 4.

Case 2:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 11
11 is at index 5.

Case 3:
The linked list: 4 -3 1 0 9 11 
What data item would you like to search for? 3
3 was not found.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next

    def find_index(self, key):
        current = self.head

        index = 0
        while current:
            if current.data == key:
                return index
            current = current.next
            index = index + 1

        return -1

a_llist = LinkedList()
for data in [4, -3, 1, 0, 9, 11]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('What data item would you like to search for? '))
index = a_llist.find_index(key)
if index == -1:
    print(str(key) + ' was not found.')
else:
    print(str(key) + ' is at index ' + str(index) + '.')
 ETP  
 
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOPN
Python Program to Display the Nodes of a Linked List in Reverse using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 5
Enter data item: 3
Enter data item: 8
Enter data item: 14
Enter data item: 2
Enter data item: 1
The reversed linked list: 1 2 14 8 3 

Case 2:
How many elements would you like to add? 1
Enter data item: 3
The reversed linked list: 3 

Case 3:
How many elements would you like to add? 2
Enter data item: 0
Enter data item: 1
The reversed linked list: 1 0
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        self.display_reversed_helper(self.head)

    def display_reversed_helper(self, current):
        if current is None:
            return

        self.display_reversed_helper(current.next)
        print(current.data, end = ' ')

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Display all the Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 3
Enter data item: 7
Enter data item: 2
Enter data item: 1
The linked list: 7 2 1 

Case 2:
How many elements would you like to add? 1
Enter data item: 2
The linked list: 2 

Case 3:
How many elements would you like to add? 5
Enter data item: 4
Enter data item: 2
Enter data item: 3
Enter data item: 5
Enter data item: 1
The linked list: 4 2 3 5 1
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        self.display_helper(self.head)

    def display_helper(self, current):
        if current is None:
            return

        print(current.data, end = ' ')
        self.display_helper(current.next)

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The linked list: ', end = '')
a_llist.display()
 ETP  
 
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOPN
 Python Program to Display the Nodes of a Linked List in Reverse without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
How many elements would you like to add? 4
Enter data item: 7
Enter data item: 2
Enter data item: 1
Enter data item: 9
The reversed linked list: 9 1 2 7 

Case 2:
How many elements would you like to add? 1
Enter data item: 5
The reversed linked list: 5 

Case 3:
How many elements would you like to add? 2
Enter data item: 3
Enter data item: 1
The reversed linked list: 1 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display_reversed(self):
        end_node = None

        while end_node != self.head:
            current = self.head
            while current.next != end_node:
                current = current.next
            print(current.data, end = ' ')
            end_node = current

a_llist = LinkedList()
n = int(input('How many elements would you like to add? '))
for i in range(n):
    data = int(input('Enter data item: '))
    a_llist.append(data)

print('The reversed linked list: ', end = '')
a_llist.display_reversed()
 ETP  
 
Python Program to Find the Length of the Linked List using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 4 10
The length of the linked list is 3.

Case 2:
Please enter the elements in the linked list: 7
The length of the linked list is 1.

Case 3:
Please enter the elements in the linked list: 3 4 1 -1 3 9
The length of the linked list is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        return self.length_helper(self.head)

    def length_helper(self, current):
        if current is None:
            return 0
        return 1 + self.length_helper(current.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Find the Length of the Linked List without using Recursion
================================ EOPN
Python Program to Find the Length of the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 8 1
The length of the linked list is 2.

Case 2:
Please enter the elements in the linked list: 
The length of the linked list is 0.

Case 3:
Please enter the elements in the linked list: 7 5 9 12
The length of the linked list is 4.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def length(self):
        current = self.head
        length = 0
        while current:
            length = length + 1
            current = current.next
        return length

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The length of the linked list is ' + str(a_llist.length()) + '.', end = '')
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 3
3 occurs 2 time(s) in the list.

Case 2:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 7
7 occurs 4 time(s) in the list.

Case 3:
The linked list: 7 3 7 4 7 11 4 0 3 7 
Enter data item: 2
2 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        return self.count_helper(self.head, key)

    def count_helper(self, current, key):
        if current is None:
            return 0

        if current.data == key:
            return 1 + self.count_helper(current.next, key)
        else:
            return self.count_helper(current.next, key)

a_llist = LinkedList()
for data in [7, 3, 7, 4, 7, 11, 4, 0, 3, 7]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOPN
Python Program to Count the Number of Occurrences of an Element in the Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 5
5 occurs 3 time(s) in the list.

Case 2:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 3
3 occurs 1 time(s) in the list.

Case 3:
The linked list: 5 1 3 5 5 15 4 9 2 
Enter data item: 7
7 occurs 0 time(s) in the list.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def count(self, key):
        current = self.head

        count = 0
        while current:
            if current.data == key:
                count = count + 1
            current = current.next

        return count

a_llist = LinkedList()
for data in [5, 1, 3, 5, 5, 15, 4, 9, 2]:
    a_llist.append(data)
print('The linked list: ', end = '')
a_llist.display()
print()

key = int(input('Enter data item: '))
count = a_llist.count(key)
print('{0} occurs {1} time(s) in the list.'.format(key, count))
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 1 40 3 10
The alternate nodes of the linked list: 7 1 3 

Case 2:
Please enter the elements in the linked list: 4 9 1
The alternate nodes of the linked list: 4 1 

Case 3:
Please enter the elements in the linked list: 3
The alternate nodes of the linked list: 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        self.alternate_helper(self.head)

    def alternate_helper(self, current):
        if current is None:
            return
        print(current.data, end = ' ')
        if current.next:
            self.alternate_helper(current.next.next)

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOPN
Python Program to Print the Alternate Nodes in a Linked List without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 4 1 9 10 3
The alternate nodes of the linked list: 7 4 9 3 

Case 2:
Please enter the elements in the linked list: 1 2
The alternate nodes of the linked list: 1 

Case 3:
Please enter the elements in the linked list: 9
The alternate nodes of the linked list: 9
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def alternate(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            if current.next is not None:
                current = current.next.next
            else:
                break

a_llist = LinkedList()
data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print('The alternate nodes of the linked list: ', end = '')
a_llist.alternate()
 ETP  
 
Python Program to Implement a Stack using Linked List
================================ EOPN
Python Program to Implement a Stack using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 15
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Popped value:  15
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Stack:
    def __init__(self):
        self.head = None

    def push(self, data):
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node

    def pop(self):
        if self.head is None:
            return None
        else:
            popped = self.head.data
            self.head = self.head.next
            return popped

a_stack = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        a_stack.push(int(do[1]))
    elif operation == 'pop':
        popped = a_stack.pop()
        if popped is None:
            print('Stack is empty.')
        else:
            print('Popped value: ', int(popped))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue Data Structure using Linked List
================================ EOPN
Python Program to Implement Queue Data Structure using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  4
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 5
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  5
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.last = None

    def enqueue(self, data):
        if self.last is None:
            self.head = Node(data)
            self.last = self.head
        else:
            self.last.next = Node(data)
            self.last = self.last.next

    def dequeue(self):
        if self.head is None:
            return None
        else:
            to_return = self.head.data
            self.head = self.head.next
            return to_return

a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        dequeued = a_queue.dequeue()
        if dequeued is None:
            print('Queue is empty.')
        else:
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Binary Tree using Linked List
================================ EOPN
Python Program to Implement Binary Tree using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 5 left of 3
inorder traversal of binary tree: 5 3 
What would you like to do? insert 2 right of 5
inorder traversal of binary tree: 5 2 3 
What would you like to do? insert 11 right of 3
inorder traversal of binary tree: 5 2 3 11 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 left of 2
inorder traversal of binary tree: 4 2 1 3 
What would you like to do? insert 5 right of 2
inorder traversal of binary tree: 4 2 5 1 3 
What would you like to do? insert 6 left of 3
inorder traversal of binary tree: 4 2 5 1 6 3 
What would you like to do? insert 7 right of 3
inorder traversal of binary tree: 4 2 5 1 6 3 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether 2 Linked Lists are Same
================================ EOPN
Python Program to Check whether 2 Linked Lists are Same
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 5 8 10 12
Please enter the elements in the second linked list: 5 8 10 12
The two linked lists are the same.

Case 2:
Please enter the elements in the first linked list: 12 3 4 5 0
Please enter the elements in the second linked list: 12 3
The two linked list are not the same.

Case 3:
Please enter the elements in the first linked list: 4 1
Please enter the elements in the second linked list: 2 19 4
The two linked list are not the same.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def is_equal(llist1, llist2):
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        if current1.data != current2.data:
            return False
        current1 = current1.next
        current2 = current2.next
    if current1 is None and current2 is None:
        return True
    else:
        return False


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

if is_equal(llist1, llist2):
    print('The two linked lists are the same.')
else:
    print('The two linked list are not the same.', end = '')
 ETP  
 
Python Program to Detect the Cycle in a Linked List
================================ EOPN
Python Program to Detect the Cycle in a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3
Enter the index [0-2] of the node to which you want the last node to point (enter nothing to make it point to None): 0
The linked list has a cycle.

Case 2:
Please enter the elements in the linked list: 4 5
Enter the index [0-1] of the node to which you want the last node to point (enter nothing to make it point to None): 1
The linked list has a cycle.

Case 3:
Please enter the elements in the linked list: 9 1 4 5
Enter the index [0-3] of the node to which you want the last node to point (enter nothing to make it point to None): 
The linked list does not have a cycle.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            current = current.next
            if current is None:
                return None
        return current


def has_cycle(llist):
    slow = llist.head
    fast = llist.head
    while (fast != None and fast.next != None):
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

length = len(data_list)
if length != 0:
    values = '0-' + str(length - 1)
    last_ptr = input('Enter the index [' + values + '] of the node'
                     ' to which you want the last node to point'
                     ' (enter nothing to make it point to None): ').strip()
    if last_ptr == '':
        last_ptr = None
    else:
        last_ptr = a_llist.get_node(int(last_ptr))
        a_llist.last_node.next = last_ptr

if has_cycle(a_llist):
    print('The linked list has a cycle.')
else:
    print('The linked list does not have a cycle.')
 ETP  
 
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOPN
Python Program to Find the Largest Element in a Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the doubly linked list: 5 10 9 3
The largest element is 10.

Case 2:
Please enter the elements in the doubly linked list: 
The list is empty.

Case 3:
Please enter the elements in the doubly linked list: 234 10 4 200
The largest element is 234.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def append(self, data):
        self.insert_at_end(Node(data))

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            new_node.prev = self.last
            self.last.next = new_node
            self.last = new_node


def find_largest(dllist):
    if dllist.first is None:
        return None
    largest = dllist.first.data
    current = dllist.first.next
    while current:
        if current.data > largest:
            largest = current.data
        current = current.next
    return largest


a_dllist = DoublyLinkedList()

data_list = input('Please enter the elements in the doubly linked list: ').split()
for data in data_list:
    a_dllist.append(int(data))

largest = find_largest(a_dllist)
if largest:
    print('The largest element is {}.'.format(largest))
else:
    print('The list is empty.')
 ETP  
 
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOPN
Python Program to Add Corresponding Positioned Elements of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 9 10 15
Please enter the elements in the second linked list: 2 5 4
The sum linked list: 3 14 14 15 

Case 2:
Please enter the elements in the first linked list: 3 4 5
Please enter the elements in the second linked list: 
The sum linked list: 3 4 5 

Case 3:
Please enter the elements in the first linked list: 7 10
Please enter the elements in the second linked list: 6 5 4 3 2
The sum linked list: 13 15 4 3 2
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end = ' ')
            current = current.next


def add_linked_lists(llist1, llist2):
    sum_llist = LinkedList()
    current1 = llist1.head
    current2 = llist2.head
    while (current1 and current2):
        sum = current1.data + current2.data
        sum_llist.append(sum)
        current1 = current1.next
        current2 = current2.next
    if current1 is None:
        while current2:
            sum_llist.append(current2.data)
            current2 = current2.next
    else:
        while current1:
            sum_llist.append(current1.data)
            current1 = current1.next
    return sum_llist



llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

sum_llist = add_linked_lists(llist1, llist2)

print('The sum linked list: ', end = '')
sum_llist.display()
 ETP  
 
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOPN
Python Program to Find the first Common Element between the 2 given Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 4 5 1 3 10
Please enter the elements in the second linked list: 8 3 40 1
The element that appears first in the first linked list that is common to both is 1.

Case 2:
Please enter the elements in the first linked list: 1 4 5
Please enter the elements in the second linked list: 3 10
The two lists have no common elements.

Case 3:
Please enter the elements in the first linked list: 6 8 9
Please enter the elements in the second linked list: 7 10 6 4 9 8
The element that appears first in the first linked list that is common to both is 6.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def first_common(llist1, llist2):
    current1 = llist1.head
    while current1:
        data = current1.data
        current2 = llist2.head
        while current2:
            if data == current2.data:
                return data
            current2 = current2.next
        current1 = current1.next
    return None


llist1 = LinkedList()
llist2 = LinkedList()

data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    llist1.append(int(data))

data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    llist2.append(int(data))

common = first_common(llist1, llist2)

if common:
    print('The element that appears first in the first linked list that'
          ' is common to both is {}.'.format(common))
else:
    print('The two lists have no common elements.')
 ETP  
 
Python Program to Remove Duplicates from a Linked List
================================ EOPN
Python Program to Remove Duplicates from a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 5 2 1 4 5 4 5
The list with duplicates removed: 
1 5 2 4 

Case 2:
Please enter the elements in the linked list: 3 4 1
The list with duplicates removed: 
3 4 1 

Case 3:
Please enter the elements in the linked list: 1 3 3 14 5 1 0
The list with duplicates removed: 
1 3 14 5 0
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        data = current1.data
        current2 = current1.next
        while current2:
            if current2.data == data:
                llist.remove(current2)
            current2 = current2.next
        current1 = current1.next


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

remove_duplicates(a_llist)

print('The list with duplicates removed: ')
a_llist.display()
 ETP  
 
Python Program to Reverse a Linked List
================================ EOPN
Python Program to Reverse a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 1 30 4
The reversed list: 
4 30 1 7 

Case 2:
Please enter the elements in the linked list: 3
The reversed list: 
3 

Case 3:
Please enter the elements in the linked list: 1 2
The reversed list: 
2 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist):
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    while after:
        current.next = before
        before = current
        current = after
        after = after.next
    current.next = before
    llist.head = current


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

reverse_llist(a_llist)

print('The reversed list: ')
a_llist.display()
 ETP  
 
Python Program to Reverse only First N Elements of a Linked List
================================ EOPN
Python Program to Reverse only First N Elements of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7
Enter the number of elements you want to reverse in the list: 4
The new list: 
4 3 2 1 5 6 7 

Case 2:
Please enter the elements in the linked list: 7 2 4
Enter the number of elements you want to reverse in the list: 1
The new list: 
7 2 4 

Case 3:
Please enter the elements in the linked list: 8 3 2
Enter the number of elements you want to reverse in the list: 3
The new list: 
2 3 8
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def reverse_llist(llist, n):
    if n == 0:
        return
    before = None
    current = llist.head
    if current is None:
        return
    after = current.next
    for i in range(n):
        current.next = before
        before = current
        current = after
        if after is None:
            break
        after = after.next
    llist.head.next = current
    llist.head = before


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))
n = int(input('Enter the number of elements you want to reverse in the list: '))

reverse_llist(a_llist, n)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Print Middle most Node of a Linked List
================================ EOPN
Python Program to Print Middle most Node of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2 3 4 5 6 7 8
The two middle elements are 4 and 5.

Case 2:
Please enter the elements in the linked list: 5
The middle element is 5.

Case 3:
Please enter the elements in the linked list: 3 1 0 4 2
The middle element is 0.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def print_middle(llist):
    current = llist.head
    length = 0
    while current:
        current = current.next
        length = length + 1

    current = llist.head
    for i in range((length - 1)//2):
        current = current.next

    if current:
        if length % 2 == 0:
            print('The two middle elements are {} and {}.'
                .format(current.data, current.next.data))
        else:
            print('The middle element is {}.'.format(current.data))
    else:
        print('The list is empty.')


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_middle(a_llist)
 ETP  
 
Python Program to Print Nth Node from the last of a Linked List
================================ EOPN
Python Program to Print Nth Node from the last of a Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 10 20 40 50 60
The nth element from the end will be printed. Please enter n: 3
The nth element from the end: 40

Case 2:
Please enter the elements in the linked list: 4 23 3
The nth element from the end will be printed. Please enter n: 1
The nth element from the end: 3

Case 3:
Please enter the elements in the linked list: 1 2
The nth element from the end will be printed. Please enter n: 2
The nth element from the end: 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def length_llist(llist):
    length = 0
    current = llist.head
    while current:
        current = current.next
        length = length + 1
    return length


def return_n_from_last(llist, n):
    l = length_llist(llist)
    current = llist.head
    for i in range(l - n):
        current = current.next
    return current.data


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

n = int(input('The nth element from the end will be printed. Please enter n: '))
value = return_n_from_last(a_llist, n)

print('The nth element from the end: {}'.format(value))
 ETP  
 
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOPN
Python Program to Find Intersection & Union of 2 Linked Lists
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the first linked list: 1 2 3 4 5
Please enter the elements in the second linked list: 3 4 5 6 7 8
Their union: 
1 2 3 4 5 6 7 8 
Their intersection: 
3 4 5 

Case 2:
Please enter the elements in the first linked list: 
Please enter the elements in the second linked list: 7 8
Their union: 
7 8 
Their intersection: 

Case 3:
Please enter the elements in the first linked list: 8 4 2 1 10 3 4 7 8
Please enter the elements in the second linked list: 5 6 3 4 3 2 5 2 8
Their union: 
8 4 2 1 10 3 7 5 6 
Their intersection: 
8 4 2 3
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def duplicate(self):
        copy = LinkedList()
        current = self.head
        while current:
            node = Node(current.data)
            copy.insert_at_end(node)
            current = current.next
        return copy

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


def remove_duplicates(llist):
    current1 = llist.head
    while current1:
        current2 = current1.next
        data = current1.data
        while current2:
            temp = current2
            current2 = current2.next
            if temp.data == data:
                llist.remove(temp)
        current1 = current1.next


def find_union(llist1, llist2):
    if llist1.head is None:
        union = llist2.duplicate()
        remove_duplicates(union)
        return union
    if llist2.head is None:
        union = llist1.duplicate()
        remove_duplicates(union)
        return union

    union = llist1.duplicate()
    last_node = union.head
    while last_node.next is not None:
        last_node = last_node.next
    llist2_copy = llist2.duplicate()
    last_node.next = llist2_copy.head
    remove_duplicates(union)

    return union


def find_intersection(llist1, llist2):
    if (llist1.head is None or llist2.head is None):
        return LinkedList()

    intersection = LinkedList()
    current1 = llist1.head
    while current1:
        current2 = llist2.head
        data = current1.data
        while current2:
            if current2.data == data:
                node = Node(data)
                intersection.insert_at_end(node)
                break
            current2 = current2.next
        current1 = current1.next
    remove_duplicates(intersection)

    return intersection


a_llist1 = LinkedList()
a_llist2 = LinkedList()
data_list = input('Please enter the elements in the first linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist1.insert_at_end(node)
data_list = input('Please enter the elements in the second linked list: ').split()
for data in data_list:
    node = Node(int(data))
    a_llist2.insert_at_end(node)

union = find_union(a_llist1, a_llist2)
intersection = find_intersection(a_llist1, a_llist2)

print('Their union: ')
union.display()
print()
print('Their intersection: ')
intersection.display()
print()
 ETP  
 
Python Program to Solve Josephus Problem using Linked List
================================ EOPN
Python Program to Solve Josephus Problem using Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Input number of people: 5
The kth person will be executed. Input k: 3
The person at position 4 won't be killed.

Case 2:
Input number of people: 15
The kth person will be executed. Input k: 7
The person at position 5 won't be killed.

Case 3:
Input number of people: 8
The kth person will be executed. Input k: 2
The person at position 1 won't be killed.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        node = Node(data)
        self.insert_at_end(node)

    def get_node(self, index, start):
        if self.head is None:
            return None
        current = start
        for i in range(index):
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next


def has_one_node(cllist):
    if cllist.head.next == cllist.head:
        return True
    else:
        return False


def get_josephus_solution(cllist, k):
    if cllist.head is None:
        return None
    start = cllist.head
    while not has_one_node(cllist):
        to_remove = cllist.get_node(k - 1, start)
        start = to_remove.next
        cllist.remove(to_remove)
    return cllist.head.data


a_cllist = CircularLinkedList()
n = int(input('Input number of people: '))
k = int(input('The kth person will be executed. Input k: '))
for i in range(1, n + 1):
    a_cllist.append(i)

ans = get_josephus_solution(a_cllist, k)
print('The person at position {} won\'t be killed.'.format(ans))
 ETP  
 
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOPN
Python Program to Interchange two Elements of the List without touching the Key Field
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
Please enter the two indices of the two elements that you want to exchange: 0 1
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 5 1
Please enter the two indices of the two elements that you want to exchange: 1 2
The new list: 
4 1 5 

Case 3:
Please enter the elements in the linked list: 3 1 30 4 5 10 23
Please enter the two indices of the two elements that you want to exchange: 2 5
The new list: 
3 1 10 4 5 30 23
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def interchange(llist, n, m):
    node1 = llist.get_node(n)
    node2 = llist.get_node(m)
    prev_node1 = llist.get_prev_node(node1)
    prev_node2 = llist.get_prev_node(node2)
    if prev_node1 is not None:
        prev_node1.next = node2
    else:
        llist.head = node2
    if prev_node2 is not None:
        prev_node2.next = node1
    else:
        llist.head = node1
    temp = node2.next
    node2.next = node1.next
    node1.next = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

ans = input('Please enter the two indices of the two elements that'
            ' you want to exchange: ').split()
n = int(ans[0])
m = int(ans[1])

interchange(a_llist, n, m)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOPN
Python Program to Modify the Linked List such that All Even Numbers appear before all the Odd Numbers in the Modified Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 3 1 0 4 30 12
The new list: 
12 30 4 0 3 1 

Case 2:
Please enter the elements in the linked list: 1 2
The new list: 
2 1 

Case 3:
Please enter the elements in the linked list: 1 2 3 4 5
The new list: 
4 2 1 3 5
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next


def move_even_before_odd(llist):
    current = llist.head
    while current:
        temp = current.next
        if current.data % 2 == 0:
            llist.remove(current)
            llist.insert_at_beg(current)
        current = temp


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

move_even_before_odd(a_llist)

print('The new list: ')
a_llist.display()
 ETP  
 
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOPN
Python Program to Interchange the two Adjacent Nodes given a circular Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 1 2
The nodes at indices n and n+1 will be interchanged. Please enter n: 0
The new list: 
2 1 

Case 2:
Please enter the elements in the linked list: 4 1 5
The nodes at indices n and n+1 will be interchanged. Please enter n: 2
The new list: 
5 1 4 

Case 3:
Please enter the elements in the linked list: 3 18 40 1 6
The nodes at indices n and n+1 will be interchanged. Please enter n: 3
The new list: 
3 18 40 6 1
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def append(self, data):
        self.insert_at_end(Node(data))

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break

def interchange(llist, n):
    current = llist.get_node(n)
    current2 = current.next
    if current2.next != current:
        before = llist.get_prev_node(current)
        after = current2.next
        before.next = current2
        current2.next = current
        current.next = after
    if llist.head == current:
        llist.head = current2
    elif llist.head == current2:
        llist.head = current


a_cllist = CircularLinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_cllist.append(int(data))

n = int(input('The nodes at indices n and n+1 will be interchanged.'
              ' Please enter n: '))

interchange(a_cllist, n)

print('The new list: ')
a_cllist.display()
 ETP  
 
Python Program to Illustrate the Operations of Singly Linked List
================================ EOPN
Python Program to Illustrate the Operations of Singly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 3 at end
The list: 7 3 
What would you like to do? insert 1 after 0
The list: 7 1 3 
What would you like to do? insert 9 before 2
The list: 7 1 9 3 
What would you like to do? remove 2
The list: 7 1 3 
What would you like to do? insert 12 at end
The list: 7 1 3 12 
What would you like to do? remove 0
The list: 1 3 12 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 after 0
No such index.
The list: 
What would you like to do? insert 3 at end
The list: 3 
What would you like to do? insert 1 after 0
The list: 3 1 
What would you like to do? insert 2 before 1
The list: 3 2 1 
What would you like to do? insert 0 at end
The list: 3 2 1 0 
What would you like to do? remove 3
The list: 3 2 1 
What would you like to do? remove 2
The list: 3 2 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        current = self.head
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_beg(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head = new_node

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def remove(self, node):
        prev_node = self.get_prev_node(node)
        if prev_node is None:
            self.head = self.head.next
        else:
            prev_node.next = node.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end = ' ')
            current = current.next


a_llist = LinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_llist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_llist.insert_at_beg(new_node)
            elif position == 'end':
                a_llist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_llist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_llist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_llist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_llist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_llist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOPN
Python Program to Check whether a Singly Linked List is a Palindrome
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 8 1 8 7
The linked lists is palindromic.

Case 2:
Please enter the elements in the linked list: 1 2 3 3 2 1
The linked list is palindromic.

Case 3:
Please enter the elements in the linked list: 1 4 5 4 5 1
The linked list is not palindromic.
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current


def is_palindrome(llist):
    start = llist.head
    end = llist.last_node
    while (start != end and end.next != start):
        if start.data != end.data:
            return False
        start = start.next
        end = llist.get_prev_node(end)
    return True


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

if is_palindrome(a_llist):
    print('The linked list is palindromic.')
else:
    print('The linked list is not palindromic.')
 ETP  
 
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOPN
Python Program to Convert a given Singly Linked List to a Circular List
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements in the linked list: 7 2 3 40 1
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 7.

Case 2:
Please enter the elements in the linked list: 3
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 3.

Case 3:
Please enter the elements in the linked list: 1 2
Last node points to None.
Converting linked list to a circular linked list...
Last node points to element with data 1.
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next


def convert_to_circular(llist):
    if llist.last_node:
        llist.last_node.next = llist.head


def print_last_node_points_to(llist):
    last = llist.last_node
    if last is None:
        print('List is empty.')
        return
    if last.next is None:
        print('Last node points to None.')
    else:
        print('Last node points to element with data {}.'.format(last.next.data))


a_llist = LinkedList()

data_list = input('Please enter the elements in the linked list: ').split()
for data in data_list:
    a_llist.append(int(data))

print_last_node_points_to(a_llist)

print('Converting linked list to a circular linked list...')
convert_to_circular(a_llist)

print_last_node_points_to(a_llist)
 ETP  
 
Python Program to Implement Circular Doubly Linked List
================================ EOPN
Python Program to Implement Circular Doubly Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 at beg
The list: 3 
What would you like to do? insert 5 at end
The list: 3 5 
What would you like to do? insert 1 after 0
The list: 3 1 5 
What would you like to do? insert 2 after 2
The list: 3 1 5 2 
What would you like to do? remove 0
The list: 1 5 2 
What would you like to do? remove 2
The list: 1 5 
What would you like to do? remove 1
The list: 1 
What would you like to do? remove 0
The list: 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 10 at end
The list: 10 
What would you like to do? insert 1 at beg
The list: 1 10 
What would you like to do? insert 5 before 0
The list: 1 10 5 
What would you like to do? insert 9 at beg
The list: 9 1 10 5 
What would you like to do? remove 3
The list: 9 1 10 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class CircularDoublyLinkedList:
    def __init__(self):
        self.first = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            current = current.next
            if current == self.first:
                return None
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        new_node.next = ref_node.next
        new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        self.insert_after(ref_node.prev, new_node)

    def insert_at_end(self, new_node):
        if self.first is None:
            self.first = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            self.insert_after(self.first.prev, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.first = new_node

    def remove(self, node):
        if self.first.next == self.first:
            self.first = None
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
            if self.first == node:
                self.first = node.next

    def display(self):
        if self.first is None:
            return
        current = self.first
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.first:
                break


a_cdllist = CircularDoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cdllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cdllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cdllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cdllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cdllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cdllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cdllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cdllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Demonstrate Circular Single Linked List
================================ EOPN
Python Program to Demonstrate Circular Single Linked List
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 7 at beg
The list: 7 
What would you like to do? insert 1 before 0
The list: 7 1 
What would you like to do? insert 10 after 0
The list: 7 10 1 
What would you like to do? insert 3 at end
The list: 7 10 1 3 
What would you like to do? remove 2
The list: 7 10 3 
What would you like to do? remove 0
The list: 10 3 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 1 at beg
The list: 1 
What would you like to do? insert 3 after 2
No such index.
The list: 1 
What would you like to do? remove 1
No such index.
The list: 1 
What would you like to do? insert 6 after 0
The list: 1 6 
What would you like to do? remove 0
The list: 6 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class CircularLinkedList:
    def __init__(self):
        self.head = None

    def get_node(self, index):
        if self.head is None:
            return None
        current = self.head
        for i in range(index):
            current = current.next
            if current == self.head:
                return None
        return current

    def get_prev_node(self, ref_node):
        if self.head is None:
            return None
        current = self.head
        while current.next != ref_node:
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.next = ref_node.next
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        prev_node = self.get_prev_node(ref_node)
        self.insert_after(prev_node, new_node)

    def insert_at_end(self, new_node):
        if self.head is None:
            self.head = new_node
            new_node.next = new_node
        else:
            self.insert_before(self.head, new_node)

    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.head = new_node

    def remove(self, node):
        if self.head.next == self.head:
            self.head = None
        else:
            prev_node = self.get_prev_node(node)
            prev_node.next = node.next
            if self.head == node:
                self.head = node.next

    def display(self):
        if self.head is None:
            return
        current = self.head
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.head:
                break


a_cllist = CircularLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_cllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_cllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOPN
Python Program to Implement a Doubly Linked List & provide Insertion, Deletion & Display Operations
================================ EOKW
--------------------------------
output:
Case 1:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 5 at beg
The list: 5 
What would you like to do? insert 3 at beg
The list: 3 5 
What would you like to do? insert 1 at end
The list: 3 5 1 
What would you like to do? insert 10 after 1
The list: 3 5 10 1 
What would you like to do? insert 0 before 2
The list: 3 5 0 10 1 
What would you like to do? remove 4
The list: 3 5 0 10 
What would you like to do? remove 1
The list: 3 0 10 
What would you like to do? remove 5
No such index.
The list: 3 0 10 
What would you like to do? quit

Case 2:
Menu
insert <data> after <index>
insert <data> before <index>
insert <data> at beg
insert <data> at end
remove <index>
quit
The list: 
What would you like to do? insert 3 after 0
No such index.
The list: 
What would you like to do? insert 2 at beg
The list: 2 
What would you like to do? insert 3 before 0
The list: 3 2 
What would you like to do? remove 0
The list: 2 
What would you like to do? remove 0
The list: 
What would you like to do? quit
--------------------------------
class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.first = None
        self.last = None

    def get_node(self, index):
        current = self.first
        for i in range(index):
            if current is None:
                return None
            current = current.next
        return current

    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        if ref_node.next is None:
            self.last = new_node
        else:
            new_node.next = ref_node.next
            new_node.next.prev = new_node
        ref_node.next = new_node

    def insert_before(self, ref_node, new_node):
        new_node.next = ref_node
        if ref_node.prev is None:
            self.first = new_node
        else:
            new_node.prev = ref_node.prev
            new_node.prev.next = new_node
        ref_node.prev = new_node

    def insert_at_beg(self, new_node):
        if self.first is None:
            self.first = new_node
            self.last = new_node
        else:
            self.insert_before(self.first, new_node)

    def insert_at_end(self, new_node):
        if self.last is None:
            self.last = new_node
            self.first = new_node
        else:
            self.insert_after(self.last, new_node)

    def remove(self, node):
        if node.prev is None:
            self.first = node.next
        else:
            node.prev.next = node.next

        if node.next is None:
            self.last = node.prev
        else:
            node.next.prev = node.prev

    def display(self):
        current = self.first
        while current:
            print(current.data, end = ' ')
            current = current.next


a_dllist = DoublyLinkedList()

print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')

while True:
    print('The list: ', end = '')
    a_dllist.display()
    print()
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()

    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_dllist.insert_at_beg(new_node)
            elif position == 'end':
                a_dllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_dllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_dllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_dllist.insert_before(ref_node, new_node)

    elif operation == 'remove':
        index = int(do[1])
        node = a_dllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_dllist.remove(node)

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement a Stack
================================ EOPN
Python Program to Implement a Stack
================================ EOKW
--------------------------------
output:
Case 1:
push <value>
pop
quit
What would you like to do? push 3
push <value>
pop
quit
What would you like to do? push 5
push <value>
pop
quit
What would you like to do? pop
Popped value:  5
push <value>
pop
quit
What would you like to do? pop
Popped value:  3
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? quit

Case 2:
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
push <value>
pop
quit
What would you like to do? push 1
push <value>
pop
quit
What would you like to do? pop
Popped value:  1
push <value>
pop
quit
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Reverse a Stack using Recursion
================================ EOPN
Python Program to Reverse a Stack using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the elements to push: 7 3 1 5
The stack:
5
1
3
7
After reversing:
7
3
1
5

Case 2:
Please enter the elements to push: 3
The stack:
3
After reversing:
3

Case 3:
Please enter the elements to push: 1 2
The stack:
2
1
After reversing:
1
2
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()

    def display(self):
        for data in reversed(self.items):
            print(data)

def insert_at_bottom(s, data):
    if s.is_empty():
        s.push(data)
    else:
        popped = s.pop()
        insert_at_bottom(s, data)
        s.push(popped)


def reverse_stack(s):
    if not s.is_empty():
        popped = s.pop()
        reverse_stack(s)
        insert_at_bottom(s, popped)


s = Stack()
data_list = input('Please enter the elements to push: ').split()
for data in data_list:
    s.push(int(data))

print('The stack:')
s.display()
reverse_stack(s)
print('After reversing:')
s.display()
 ETP  
 
Python Program to Implement Stack using One Queue
================================ EOPN
Python Program to Implement Stack using One Queue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? push 3
What would you like to do? push 5
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.q = Queue()

    def is_empty(self):
        return self.q.is_empty()

    def push(self, data):
        self.q.enqueue(data)

    def pop(self):
        for _ in range(self.q.get_size() - 1):
            dequeued = self.q.dequeue()
            self.q.enqueue(dequeued)
        return self.q.dequeue()


class Queue:
    def __init__(self):
        self.items = []
        self.size = 0

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.size += 1
        self.items.append(data)

    def dequeue(self):
        self.size -= 1
        return self.items.pop(0)

    def get_size(self):
        return self.size


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Stack Using Two Queues
================================ EOPN
Python Program to Implement Stack Using Two Queues
================================ EOKW
--------------------------------
output:
Case 1:
Menu
push <value>
pop
quit
What would you like to do? pop
Stack is empty.
What would you like to do? push 3
What would you like to do? push 4
What would you like to do? pop
Popped value:  4
What would you like to do? pop
Popped value:  3
What would you like to do? pop
Stack is empty.
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? pop
Popped value:  2
What would you like to do? quit

Case 2:
Menu
push <value>
pop
quit
What would you like to do? push 1
What would you like to do? push 2
What would you like to do? push 5
What would you like to do? push 0
What would you like to do? pop
Popped value:  0
What would you like to do? pop
Popped value:  5
What would you like to do? pop
Popped value:  2
What would you like to do? pop
Popped value:  1
What would you like to do? pop
Stack is empty.
What would you like to do? quit
--------------------------------
class Stack:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def is_empty(self):
        return self.queue2.is_empty()

    def push(self, data):
        self.queue1.enqueue(data)
        while not self.queue2.is_empty():
            x = self.queue2.dequeue()
            self.queue1.enqueue(x)
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self):
        return self.queue2.dequeue()

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


s = Stack()

print('Menu')
print('push <value>')
print('pop')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queue
================================ EOPN
Python Program to Implement Queue
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 3
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  3
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  1
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  0
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued value:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


q = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        q.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if q.is_empty():
            print('Queue is empty.')
        else:
            print('Dequeued value: ', q.dequeue())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dequeue
================================ EOPN
Python Program to Implement Dequeue
================================ EOKW
--------------------------------
output:
Case 1:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 3
What would you like to do? append 4
What would you like to do? appendleft 2
What would you like to do? appendleft 1
What would you like to do? pop
Popped value from right:  4
What would you like to do? popleft
Popped value from left:  1
What would you like to do? pop
Popped value from right:  3
What would you like to do? popleft
Popped value from left:  2
What would you like to do? pop
Dequeue is empty.
What would you like to do? quit

Case 2:
Menu
append <value>
appendleft <value>
pop
popleft
quit
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? pop
Popped value from right:  2
What would you like to do? pop
Popped value from right:  1
What would you like to do? appendleft 1
What would you like to do? appendleft 2
What would you like to do? pop
Popped value from right:  1
What would you like to do? pop
Popped value from right:  2
What would you like to do? append 1
What would you like to do? append 2
What would you like to do? popleft
Popped value from left:  1
What would you like to do? popleft
Popped value from left:  2
What would you like to do? quit
--------------------------------
class Dequeue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def append(self, data):
        self.items.append(data)

    def append_left(self, data):
        self.items.insert(0, data)

    def pop(self):
        return self.items.pop()

    def pop_left(self):
        return self.items.pop(0)


q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Queues using Stacks
================================ EOPN
Python Program to Implement Queues using Stacks
================================ EOKW
--------------------------------
output:
Case 1:
enqueue <value>
dequeue
quit
What would you like to do? enqueue 7
enqueue <value>
dequeue
quit
What would you like to do? enqueue 8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  7
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  8
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? quit

Case 2:
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Queue is empty.
enqueue <value>
dequeue
quit
What would you like to do? enqueue 1
enqueue <value>
dequeue
quit
What would you like to do? enqueue 2
enqueue <value>
dequeue
quit
What would you like to do? dequeue
Dequeued element:  1
enqueue <value>
dequeue
quit
What would you like to do? quit
--------------------------------
class Queue:
    def __init__(self):
        self.inbox = Stack()
        self.outbox = Stack()

    def is_empty(self):
        return (self.inbox.is_empty() and self.outbox.is_empty())

    def enqueue(self, data):
        self.inbox.push(data)

    def dequeue(self):
        if self.outbox.is_empty():
            while not self.inbox.is_empty():
                popped = self.inbox.pop()
                self.outbox.push(popped)
        return self.outbox.pop()


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if a_queue.is_empty():
            print('Queue is empty.')
        else:
            dequeued = a_queue.dequeue()
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check String is Palindrome using Stack
================================ EOPN
Python Program to Check String is Palindrome using Stack
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the string: madam
The string is a palindrome.

Case 2:
Please enter the string: racecar
The string is a palindrome.

Case 3:
Please enter the string: palace
The string is not a palindrome.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
text = input('Please enter the string: ')

for character in text:
    s.push(character)

reversed_text = ''
while not s.is_empty():
    reversed_text = reversed_text + s.pop()

if text == reversed_text:
    print('The string is a palindrome.')
else:
    print('The string is not a palindrome.')
 ETP  
 
Python Program to Check if Expression is correctly Parenthesized
================================ EOPN
Python Program to Check if Expression is correctly Parenthesized
================================ EOKW
--------------------------------
output:
Case 1:
Please enter the expression: (3 + 4 * (1 + (2))/(7 * (8 + 9)))
Expression is correctly parenthesized.

Case 2:
Please enter the expression: (a + b))(3)
Expression is not correctly parenthesized.

Case 3:
Please enter the expression: (4 + (3 * 2)
Expression is not correctly parenthesized.
--------------------------------
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


s = Stack()
exp = input('Please enter the expression: ')

for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False

if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')
 ETP  
 
Python Program to Implement Linear Search
================================ EOPN
Python Program to Implement Linear Search
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 4 3 2 1 10 11 2
The number to search for: 1
1 was found at index 4.

Case 2:
Enter the list of numbers: 5 2 1 5 -3
The number to search for: 2
2 was found at index 1.

Case 3:
Enter the list of numbers: 3 5 6
The number to search for: 2
2 was not found.
--------------------------------
def linear_search(alist, key):
    """Return index of key in alist. Return -1 if key not present."""
    for i in range(len(alist)):
        if alist[i] == key:
            return i
    return -1


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = linear_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search without Recursion
================================ EOPN
Python Program to Implement Binary Search without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 3 5 10 12 15 20
The number to search for: 12
12 was found at index 3.

Case 2:
Enter the sorted list of numbers: -3 0 1 5 6 7 8
The number to search for: 2
2 was not found.

Case 3:
Enter the sorted list of numbers: 5
The number to search for: 5
5 was found at index 0.
--------------------------------
def binary_search(alist, key):
    """Search key in alist[start... end - 1]."""
    start = 0
    end = len(alist)
    while start < end:
        mid = (start + end)//2
        if alist[mid] > key:
            end = mid
        elif alist[mid] < key:
            start = mid + 1
        else:
            return mid
    return -1


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Implement Binary Search with Recursion
================================ EOPN
Python Program to Implement Binary Search with Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Enter the sorted list of numbers: 4 5 6 7 8 9 10
The number to search for: 9
9 was found at index 5.

Case 2:
Enter the sorted list of numbers: 3 4 5 10
The number to search for: 8
8 was not found.

Case 3:
Enter the sorted list of numbers: 7
The number to search for: 7
7 was found at index 0.
--------------------------------
def binary_search(alist, start, end, key):
    """Search key in alist[start... end - 1]."""
    if not start < end:
        return -1

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, mid + 1, end, key)
    elif alist[mid] > key:
        return binary_search(alist, start, mid, key)
    else:
        return mid


alist = input('Enter the sorted list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
key = int(input('The number to search for: '))

index = binary_search(alist, 0, len(alist), key)
if index < 0:
    print('{} was not found.'.format(key))
else:
    print('{} was found at index {}.'.format(key, index))
 ETP  
 
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Smallest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 10 2 -1 0 2
The ith smallest element will be found. Enter i: 2
Result: 0.

Case 2:
Enter the list of numbers: 7
The ith smallest element will be found. Enter i: 1
Result: 7.

Case 3:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 5.
--------------------------------
def select(alist, start, end, i):
    """Find ith smallest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[start... pivot]
    k = pivot - start + 1

    if i < k:
        return select(alist, start, pivot, i)
    elif i > k:
        return select(alist, pivot + 1, end, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOPN
Python Program to Select the ith Largest Element from a List in Expected Linear Time
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 10 7 2 -2
The ith smallest element will be found. Enter i: 2
Result: 7.

Case 2:
Enter the list of numbers: 5 4 3 2 1
The ith smallest element will be found. Enter i: 5
Result: 1.

Case 3:
Enter the list of numbers: 3
The ith smallest element will be found. Enter i: 1
Result: 3.
--------------------------------
def select(alist, start, end, i):
    """Find ith largest element in alist[start... end-1]."""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)

    # number of elements in alist[pivot... end - 1]
    k = end - pivot

    if i < k:
        return select(alist, pivot + 1, end, i)
    elif i > k:
        return select(alist, start, pivot, i - k)

    return alist[pivot]

def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))

ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))
 ETP  
 
Python Program to Implement Bubble Sort 
================================ EOPN
Python Program to Implement Bubble Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 38 10 5
Sorted list: [2, 4, 5, 10, 38]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7 3 1 -5 2 10
Sorted list: [-5, 1, 2, 3, 7, 10]
--------------------------------
def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Selection Sort
================================ EOPN
Python Program to Implement Selection Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 4 5 2 6
Sorted list: [1, 2, 3, 4, 5, 6]

Case 2:
Enter the list of numbers: 2 10 5 38 1 7
Sorted list: [1, 2, 5, 7, 10, 38]

Case 3:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]
--------------------------------
def selection_sort(alist):
    for i in range(0, len(alist) - 1):
        smallest = i
        for j in range(i + 1, len(alist)):
            if alist[j] < alist[smallest]:
                smallest = j
        alist[i], alist[smallest] = alist[smallest], alist[i]


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
selection_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Insertion Sort
================================ EOPN
Python Program to Implement Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 4 1 5 8 0
Sorted list: [0, 1, 2, 4, 5, 8]

Case 2:
Enter the list of numbers: 5 4 3 2 0 -1
Sorted list: [-1, 0, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3 4 1 4 5 0 7
Sorted list: [0, 1, 3, 4, 4, 5, 7]
--------------------------------
def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Merge Sort
================================ EOPN
Python Program to Implement Merge Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 1 5 8 2 5 1 3
Sorted list: [1, 1, 2, 3, 3, 5, 5, 8]

Case 2:
Enter the list of numbers: 5 3 2 1 0
Sorted list: [0, 1, 2, 3, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)

def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Quicksort
================================ EOPN
Python Program to Implement Quicksort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 8 10 3 0 4
Sorted list: [0, 2, 3, 4, 5, 8, 10]

Case 2:
Enter the list of numbers: 7 4 3 2 1
Sorted list: [1, 2, 3, 4, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def quicksort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        p = partition(alist, start, end)
        quicksort(alist, start, p)
        quicksort(alist, p + 1, end)


def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1

    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1

        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
quicksort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Heapsort
================================ EOPN
Python Program to Implement Heapsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 2 2 1 0 -2 5 7
Sorted list: [-2, 0, 1, 2, 2, 3, 5, 7]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 1
Sorted list: [1]
--------------------------------
def heapsort(alist):
    build_max_heap(alist)
    for i in range(len(alist) - 1, 0, -1):
        alist[0], alist[i] = alist[i], alist[0]
        max_heapify(alist, index=0, size=i)

def parent(i):
    return (i - 1)//2

def left(i):
    return 2*i + 1

def right(i):
    return 2*i + 2

def build_max_heap(alist):
    length = len(alist)
    start = parent(length - 1)
    while start >= 0:
        max_heapify(alist, index=start, size=length)
        start = start - 1

def max_heapify(alist, index, size):
    l = left(index)
    r = right(index)
    if (l < size and alist[l] > alist[index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[r] > alist[largest]):
        largest = r
    if (largest != index):
        alist[largest], alist[index] = alist[index], alist[largest]
        max_heapify(alist, largest, size)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
heapsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Counting Sort
================================ EOPN
Python Program to Implement Counting Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 4 1 3 6 1 8
Sorted list: [1, 1, 1, 2, 3, 4, 6, 8]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 4 3 2
Sorted list: [2, 3, 4, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 1
Sorted list: [1]
--------------------------------
def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)

    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1

    return result


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
 Python Program to Implement Radix Sort 
================================ EOPN
 Python Program to Implement Radix Sort 
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 38 20 1 3 4 0 2 5 1 3 8 2 9 10
Sorted list: [0, 1, 1, 2, 2, 3, 3, 4, 5, 8, 9, 10, 20, 38]

Case 2:
Enter the list of (nonnegative) numbers: 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7]

Case 3:
Enter the list of (nonnegative) numbers: 3
Sorted list: [3]
--------------------------------
def radix_sort(alist, base=10):
    if alist == []:
        return

    def key_factory(digit, base):
        def key(alist, index):
            return ((alist[index]//(base**digit)) % base)
        return key
    largest = max(alist)
    exp = 0
    while base**exp <= largest:
        alist = counting_sort(alist, base - 1, key_factory(exp, base))
        exp = exp + 1
    return alist

def counting_sort(alist, largest, key):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[key(alist, i)] = c[key(alist, i)] + 1

    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]

    result = [None]*len(alist)
    for i in range(len(alist) - 1, -1, -1):
        result[c[key(alist, i)]] = alist[i]
        c[key(alist, i)] = c[key(alist, i)] - 1

    return result

alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = radix_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Bucket Sort
================================ EOPN
Python Program to Implement Bucket Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of (nonnegative) numbers: 2 1 5 10 3 5 7
Sorted list: [1, 2, 3, 5, 5, 7, 10]

Case 2:
Enter the list of (nonnegative) numbers: 8 7 5 3 2 1
Sorted list: [1, 2, 3, 5, 7, 8]

Case 3:
Enter the list of (nonnegative) numbers: 5
Sorted list: [5]
--------------------------------
def bucket_sort(alist):
    largest = max(alist)
    length = len(alist)
    size = largest/length

    buckets = [[] for _ in range(length)]
    for i in range(length):
        j = int(alist[i]/size)
        if j != length:
            buckets[j].append(alist[i])
        else:
            buckets[length - 1].append(alist[i])

    for i in range(length):
        insertion_sort(buckets[i])

    result = []
    for i in range(length):
        result = result + buckets[i]

    return result

def insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        j = i - 1
        while (j >= 0 and temp < alist[j]):
            alist[j + 1] = alist[j]
            j = j - 1
        alist[j + 1] = temp


alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
sorted_list = bucket_sort(alist)
print('Sorted list: ', end='')
print(sorted_list)
 ETP  
 
Python Program to Implement Gnome Sort
================================ EOPN
Python Program to Implement Gnome Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 3 2 51 38 1 10 3 0 7 8
Sorted list: [0, 1, 2, 2, 3, 3, 7, 8, 10, 38, 51]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 7
Sorted list: [7]
--------------------------------
def gnome_sort(alist):
    for pos in range(1, len(alist)):
        while (pos != 0 and alist[pos] < alist[pos - 1]):
            alist[pos], alist[pos - 1] = alist[pos - 1], alist[pos]
            pos = pos - 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
gnome_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Cocktail Shaker Sort
================================ EOPN
Python Program to Implement Cocktail Shaker Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 18 5 2 10 0 7 4
Sorted list: [0, 2, 3, 4, 5, 7, 10, 18]

Case 2:
Enter the list of numbers: 6 5 4 3 2
Sorted list: [2, 3, 4, 5, 6]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def cocktail_shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    upper = len(alist) - 1
    lower = 0

    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1

        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
cocktail_shaker_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Comb Sort
================================ EOPN
Python Program to Implement Comb Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 2 8 4 3 7 10 23 4 5
Sorted list: [2, 3, 4, 4, 5, 7, 8, 10, 23]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 3
Sorted list: [3]
--------------------------------
def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]

    gap = len(alist)
    shrink = 1.3

    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)

        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False

        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Shell Sort
================================ EOPN
Python Program to Implement Shell Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 3 1 10
Sorted list: [1, 2, 3, 5, 10]

Case 2:
Enter the list of numbers: 7 6 5 4
Sorted list: [4, 5, 6, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def gaps(size):
    # uses the gap sequence 2^k - 1: 1, 3, 7, 15, 31, ...
    length = size.bit_length()
    for k in range(length - 1, 0, -1):
        yield 2**k - 1


def shell_sort(alist):
    def insertion_sort_with_gap(gap):
        for i in range(gap, len(alist)):
            temp = alist[i]
            j = i - gap
            while (j >= 0 and temp < alist[j]):
                alist[j + gap] = alist[j]
                j = j - gap
            alist[j + gap] = temp

    for g in gaps(len(alist)):
        insertion_sort_with_gap(g)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
shell_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Introsort
================================ EOPN
Python Program to Implement Introsort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 3 5 2 3 10 9 3 7 2 1 0 9
Sorted list: [0, 1, 2, 2, 3, 3, 3, 5, 7, 9, 9, 10]

Case 2:
Enter the list of numbers: 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5]

Case 3:
Enter the list of numbers: 5
Sorted list: [5]
--------------------------------
def introsort(alist):
    maxdepth = (len(alist).bit_length() - 1)*2
    introsort_helper(alist, 0, len(alist), maxdepth)

def introsort_helper(alist, start, end, maxdepth):
    if end - start <= 1:
        return
    elif maxdepth == 0:
        heapsort(alist, start, end)
    else:
        p = partition(alist, start, end)
        introsort_helper(alist, start, p + 1, maxdepth - 1)
        introsort_helper(alist, p + 1, end, maxdepth - 1)

def partition(alist, start, end):
    pivot = alist[start]
    i = start - 1
    j = end

    while True:
        i = i + 1
        while alist[i] < pivot:
            i = i + 1
        j = j - 1
        while alist[j] > pivot:
            j = j - 1

        if i >= j:
            return j

        swap(alist, i, j)

def swap(alist, i, j):
    alist[i], alist[j] = alist[j], alist[i]

def heapsort(alist, start, end):
    build_max_heap(alist, start, end)
    for i in range(end - 1, start, -1):
        swap(alist, start, i)
        max_heapify(alist, index=0, start=start, end=i)

def build_max_heap(alist, start, end):
    def parent(i):
        return (i - 1)//2
    length = end - start
    index = parent(length - 1)
    while index >= 0:
        max_heapify(alist, index, start, end)
        index = index - 1

def max_heapify(alist, index, start, end):
    def left(i):
        return 2*i + 1
    def right(i):
        return 2*i + 2

    size = end - start
    l = left(index)
    r = right(index)
    if (l < size and alist[start + l] > alist[start + index]):
        largest = l
    else:
        largest = index
    if (r < size and alist[start + r] > alist[start + largest]):
        largest = r
    if largest != index:
        swap(alist, start + largest, start + index)
        max_heapify(alist, largest, start, end)


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
introsort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Implement Binary Insertion Sort
================================ EOPN
Python Program to Implement Binary Insertion Sort
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 5 2 7 10 3 5 2 1 8 9
Sorted list: [1, 2, 2, 3, 5, 5, 7, 8, 9, 10]

Case 2:
Enter the list of numbers: 7 5 5 4 3 2 1
Sorted list: [1, 2, 3, 4, 5, 5, 7]

Case 3:
Enter the list of numbers: 2
Sorted list: [2]
--------------------------------
def binary_insertion_sort(alist):
    for i in range(1, len(alist)):
        temp = alist[i]
        pos = binary_search(alist, temp, 0, i) + 1

        for k in range(i, pos, -1):
            alist[k] = alist[k - 1]

        alist[pos] = temp

def binary_search(alist, key, start, end):
    '''If key is in the list at index p, then return p.
    If there are multiple such keys in the list, then return the index of any one.
    If key is not in the list and a < key < b where a and b are elements in the list, then return the index of a.
    If key is not in the list and key < a where a is the first element in the list, then return -1.
    Only elements with indexes start to end - 1 inclusive are considered.
    '''
    if end - start <= 1:
        if key < alist[start]:
            return start - 1
        else:
            return start

    mid = (start + end)//2
    if alist[mid] < key:
        return binary_search(alist, key, mid, end)
    elif alist[mid] > key:
        return binary_search(alist, key, start, mid)
    else:
        return mid


alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
binary_insertion_sort(alist)
print('Sorted list: ', end='')
print(alist)
 ETP  
 
Python Program to Sort using a Binary Search Tree
================================ EOPN
Python Program to Sort using a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Enter the list of numbers: 4 2 3 4 5 6 1 7 9 10 3
Sorted list: 1 2 3 3 4 4 5 6 7 9 10 

Case 2:
Enter the list of numbers: 6 5 4 3 2 1
Sorted list: 1 2 3 4 5 6 

Case 3:
Enter the list of numbers: 5
Sorted list: 5
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key <= node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)


bstree = BSTree()

alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
for x in alist:
    bstree.add(x)
print('Sorted list: ', end='')
bstree.inorder()
 ETP  
 
Python Program for Depth First Binary Tree Search using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 5
What would you like to do? insert 7 right of 5
What would you like to do? dfs
depth-first search traversal:
entering 1...
entering 2...
entering 4...
at 4...
leaving 4...
at 2...
entering 5...
entering 6...
at 6...
leaving 6...
at 5...
entering 7...
at 7...
leaving 7...
leaving 5...
leaving 2...
at 1...
entering 3...
at 3...
leaving 3...
leaving 1...

What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 4 left of 3
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 4
What would you like to do? dfs
depth-first search traversal:
entering 3...
entering 4...
entering 6...
at 6...
leaving 6...
at 4...
leaving 4...
at 3...
entering 5...
at 5...
leaving 5...
leaving 3...

What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def depth_first(self):
        print('entering {}...'.format(self.key))
        if self.left is not None:
            self.left.depth_first()
        print('at {}...'.format(self.key))
        if self.right is not None:
            self.right.depth_first()
        print('leaving {}...'.format(self.key))


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('depth-first search traversal:')
        if btree is not None:
            btree.depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOPN
Python Program for Depth First Binary Tree Search without using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? dfs
pre-order dfs traversal: 1 2 4 5 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
dfs
quit
What would you like to do? insert 3 at root
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? insert 8 left of 7
What would you like to do? insert 10 right of 7
What would you like to do? dfs
pre-order dfs traversal: 3 6 7 8 10 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def preorder_depth_first(self):
        s = Stack()
        s.push(self)
        while (not s.is_empty()):
            node = s.pop()
            print(node.key, end=' ')
            if node.right is not None:
                s.push(node.right)
            if node.left is not None:
                s.push(node.left)


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


btree = BinaryTree()

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'dfs':
        print('pre-order dfs traversal: ', end='')
        if btree is not None:
            btree.preorder_depth_first()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOPN
Python Program to Find Nth Node in the Inorder Traversal of a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? inorder 1
nth term of inorder traversal: 2
What would you like to do? inorder 2
nth term of inorder traversal: 1
What would you like to do? inorder 3
nth term of inorder traversal: 3
What would you like to do? inorder 4
index exceeds maximum possible index.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
inorder <index>
quit
What would you like to do? insert 1 at root
What would you like to do? insert 3 left of 1
What would you like to do? insert 7 right of 1
What would you like to do? insert 5 right of 3
What would you like to do? insert 6 left of 5
What would you like to do? inorder 1
nth term of inorder traversal: 3
What would you like to do? inorder 2
nth term of inorder traversal: 6
What would you like to do? inorder 3
nth term of inorder traversal: 5
What would you like to do? inorder 4
nth term of inorder traversal: 1
What would you like to do? inorder 5
nth term of inorder traversal: 7
What would you like to do? inorder 6
index exceeds maximum possible index.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_nth(self, n):
        return self.inorder_nth_helper(n, [])

    def inorder_nth_helper(self, n, inord):
        if self.left is not None:
            temp = self.left.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp
        inord.append(self)
        if n == len(inord):
            return self
        if self.right is not None:
            temp = self.right.inorder_nth_helper(n, inord)
            if temp is not None:
                return temp

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('inorder <index>')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'inorder':
        if btree is not None:
            index = int(do[1].strip().lower())
            node = btree.inorder_nth(index)
            if node is not None:
                print('nth term of inorder traversal: {}'.format(node.key))
            else:
                print('index exceeds maximum possible index.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOPN
Python Program to Find the Largest value in a Tree using Inorder Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 1 at rot
What would you like to do? largest
Largest element: 1
What would you like to do? insert 2 left of 1
What would you like to do? largest
Largest element: 2
What would you like to do? insert 3 right of 1
What would you like to do? largest
Largest element: 3
What would you like to do? insert 10 left of 3
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
largest
quit
What would you like to do? insert 3 at root
What would you like to do? insert 5 left of 3
What would you like to do? insert 2 right of 3
What would you like to do? largest
Largest element: 5
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder_largest(self):
        # largest will be a single element list
        # this is a workaround to reference an integer
        largest = []
        self.inorder_largest_helper(largest)
        return largest[0]

    def inorder_largest_helper(self, largest):
        if self.left is not None:
            self.left.inorder_largest_helper(largest)
        if largest == []:
            largest.append(self.key)
        elif largest[0] < self.key:
            largest[0] = self.key
        if self.right is not None:
            self.right.inorder_largest_helper(largest)

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'largest':
        if btree is None:
            print('Tree is empty.')
        else:
            print('Largest element: {}'.format(btree.inorder_largest()))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOPN
Python Program to Implement Depth First Search Traversal using Post Order
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 2
What would you like to do? add 5 below 1
What would you like to do? add 6 below 1
What would you like to do? dfs
Post-order traversal: 3 4 2 5 6 1 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
dfs
quit
What would you like to do? add 3 at root
What would you like to do? add 5 below 3
What would you like to do? add 2 below 3
What would you like to do? add 1 below 5
What would you like to do? add 6 below 5
What would you like to do? dfs
Post-order traversal: 1 6 5 2 3 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def postorder(self):
        for child in self.children:
            child.postorder()
        print(self.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('dfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'dfs':
        print('Post-order traversal: ', end='')
        tree.postorder()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOPN
Python Program to Create a Mirror Copy of a Tree and Display using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 left of 3
What would you like to do? insert 6 right of 3
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 4 5 6 
BFS traversal of mirror: 
1 3 2 6 5 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
mirror
quit
What would you like to do? insert 1 at root
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 
BFS traversal of mirror: 
1 
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? mirror
Creating mirror copy...
BFS traversal of original tree: 
1 2 3 
BFS traversal of mirror: 
1 3 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def mirror_copy(self):
        mirror = BinaryTree(self.key)
        if self.right is not None:
            mirror.left = self.right.mirror_copy()
        if self.left is not None:
            mirror.right = self.left.mirror_copy()
        return mirror

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            if popped.left is not None:
                queue.append(popped.left)
            if popped.right is not None:
                queue.append(popped.right)
            print(popped.key, end=' ')


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('mirror')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'mirror':
        if btree is not None:
            print('Creating mirror copy...')
            mirror = btree.mirror_copy()
            print('BFS traversal of original tree: ')
            btree.bfs()
            print()
            print('BFS traversal of mirror: ')
            mirror.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOPN
Python Program to Build Binary Tree if Inorder or Postorder Traversal as Input
================================ EOKW
--------------------------------
output:
Case 1:
Input post-order traversal: 4 5 2 8 6 7 3 1
Input in-order traversal: 4 2 5 1 6 8 3 7
Binary tree constructed.
Verifying:
Post-order traversal: 4 5 2 8 6 7 3 1 
In-order traversal: 4 2 5 1 6 8 3 7 

Case 2:
Input post-order traversal: 2 1 3
Input in-order traversal: 2 3 1
Binary tree constructed.
Verifying:
Post-order traversal: 2 1 3 
In-order traversal: 2 3 1
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def postorder(self):
        if self.left is not None:
            self.left.postorder()
        if self.right is not None:
            self.right.postorder()
        print(self.key, end=' ')


def construct_btree(postord, inord):
    if postord == [] or inord == []:
        return None
    key = postord[-1]
    node = BinaryTree(key)
    index = inord.index(key)
    node.left = construct_btree(postord[:index], inord[:index])
    node.right = construct_btree(postord[index:-1], inord[index + 1:])
    return node


postord = input('Input post-order traversal: ').split()
postord = [int(x) for x in postord]
inord = input('Input in-order traversal: ').split()
inord = [int(x) for x in inord]

btree = construct_btree(postord, inord)
print('Binary tree constructed.')
print('Verifying:')
print('Post-order traversal: ', end='')
btree.postorder()
print()
print('In-order traversal: ', end='')
btree.inorder()
print()
 ETP  
 
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOPN
Python Program to Construct a Binary Search Tree and perform deletion and inorder traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 5
What would you like to do? add 1
What would you like to do? add 10
What would you like to do? add 7
What would you like to do? add 3
What would you like to do? inorder
Inorder traversal: 1 3 5 7 10 
What would you like to do? remove 3
What would you like to do? remove 7
What would you like to do? inorder
Inorder traversal: 1 5 10 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 1 10 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
remove <key>
inorder
quit
What would you like to do? add 2
What would you like to do? add 8
What would you like to do? inorder
Inorder traversal: 2 8 
What would you like to do? add 5
What would you like to do? inorder
Inorder traversal: 2 5 8 
What would you like to do? remove 2
What would you like to do? remove 8
What would you like to do? inorder
Inorder traversal: 5 
What would you like to do? remove 5
What would you like to do? inorder
Inorder traversal: 
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def replace_node_of_parent(self, new_node):
        if self.parent is not None:
            if new_node is not None:
                new_node.parent = self.parent
            if self.parent.left == self:
                self.parent.left = new_node
            elif self.parent.right == self:
                self.parent.right = new_node
        else:
            self.key = new_node.key
            self.left = new_node.left
            self.right = new_node.right
            if new_node.left is not None:
                new_node.left.parent = self
            if new_node.right is not None:
                new_node.right.parent = self

    def find_min(self):
        current = self
        while current.left is not None:
            current = current.left
        return current

    def remove(self):
        if (self.left is not None and self.right is not None):
            successor = self.right.find_min()
            self.key = successor.key
            successor.remove()
        elif self.left is not None:
            self.replace_node_of_parent(self.left)
        elif self.right is not None:
            self.replace_node_of_parent(self.right)
        else:
            self.replace_node_of_parent(None)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def inorder(self):
        if self.root is not None:
            self.root.inorder()

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def remove(self, key):
        to_remove = self.search(key)
        if (self.root == to_remove
            and self.root.left is None and self.root.right is None):
            self.root = None
        else:
            to_remove.remove()

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('remove <key>')
print('inorder')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    elif operation == 'remove':
        key = int(do[1])
        bstree.remove(key)
    elif operation == 'inorder':
        print('Inorder traversal: ', end='')
        bstree.inorder()
        print()
    elif operation == 'quit':
        break
 ETP  
 
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOPN
Python Program To Find the Smallest and Largest Elements in the Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 3
What would you like to do? add 2
What would you like to do? add 10
What would you like to do? add 4
What would you like to do? smallest
Smallest element: 2
What would you like to do? largest
Largest element: 10
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <key>
smallest
largest
quit
What would you like to do? add 10
What would you like to do? smallest
Smallest element: 10
What would you like to do? largest
Largest element: 10
What would you like to do? add 4
What would you like to do? add 12
What would you like to do? smallest
Smallest element: 4
What would you like to do? largest
Largest element: 12
What would you like to do? quit
--------------------------------
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def insert(self, node):
        if self.key > node.key:
            if self.left is None:
                self.left = node
                node.parent = self
            else:
                self.left.insert(node)
        elif self.key < node.key:
            if self.right is None:
                self.right = node
                node.parent = self
            else:
                self.right.insert(node)

    def search(self, key):
        if self.key > key:
            if self.left is not None:
                return self.left.search(key)
            else:
                return None
        elif self.key < key:
            if self.right is not None:
                return self.right.search(key)
            else:
                return None
        return self


class BSTree:
    def __init__(self):
        self.root = None

    def add(self, key):
        new_node = BSTNode(key)
        if self.root is None:
            self.root = new_node
        else:
            self.root.insert(new_node)

    def search(self, key):
        if self.root is not None:
            return self.root.search(key)

    def get_smallest(self):
        if self.root is not None:
            current = self.root
            while current.left is not None:
                current = current.left
            return current.key

    def get_largest(self):
        if self.root is not None:
            current = self.root
            while current.right is not None:
                current = current.right
            return current.key


bstree = BSTree()

print('Menu (this assumes no duplicate keys)')
print('add <key>')
print('smallest')
print('largest')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        key = int(do[1])
        bstree.add(key)
    if operation == 'smallest':
        smallest = bstree.get_smallest()
        print('Smallest element: {}'.format(smallest))
    if operation == 'largest':
        largest = bstree.get_largest()
        print('Largest element: {}'.format(largest))
    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Leaf Node in a Tree
================================ EOPN
Python Program to Count Number of Leaf Node in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of leaf nodes: 2
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 2 at root
What would you like to do? add 7 below 2
What would you like to do? add 8 below 7
What would you like to do? add 9 below 8
What would you like to do? count
Number of leaf nodes: 1
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_leaf_nodes(self):
        leaf_nodes = []
        self.count_leaf_nodes_helper(leaf_nodes)
        return len(leaf_nodes)

    def count_leaf_nodes_helper(self, leaf_nodes):
        if self.children == []:
            leaf_nodes.append(self)
        else:
            for child in self.children:
                child.count_leaf_nodes_helper(leaf_nodes)


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_leaf_nodes()
            print('Number of leaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Number of Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? insert 2 left of 1
inorder traversal of binary tree: 2 1 
What would you like to do? insert 3 right of 1
inorder traversal of binary tree: 2 1 3 
What would you like to do? insert 4 right of 2
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? count
Number of nodes in tree: 4
inorder traversal of binary tree: 2 4 1 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
count
quit
inorder traversal of binary tree: 
What would you like to do? count
Number of nodes in tree: 0
inorder traversal of binary tree: 
What would you like to do? insert 1 at root
inorder traversal of binary tree: 1 
What would you like to do? count
Number of nodes in tree: 1
inorder traversal of binary tree: 1 
What would you like to do? insert 2 right of 1
inorder traversal of binary tree: 1 2 
What would you like to do? count
Number of nodes in tree: 2
inorder traversal of binary tree: 1 2 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def count_nodes(node):
    if node is None:
        return 0
    return 1 + count_nodes(node.left) + count_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('count')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'count':
        print('Number of nodes in tree: {}'.format(count_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOPN
Python Program to Print Border of given Tree in Anticlockwise Direction
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? border
Border of tree: 
1 2 3 
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? insert 7 right of 3
What would you like to do? border
Border of tree: 
1 2 4 5 6 7 3 
What would you like to do? insert 8 left of 4
What would you like to do? insert 9 right of 4
What would you like to do? insert 10 left of 5
What would you like to do? insert 11 right of 5
What would you like to do? insert 12 left of 6
What would you like to do? insert 13 right of 6
What would you like to do? insert 14 left of 7
What would you like to do? insert 15 right of 7
What would you like to do? border
Border of tree: 
1 2 4 8 9 10 11 12 13 14 15 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
border
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 left of 2
What would you like to do? insert 4 right of 2
What would you like to do? insert 5 left of 4
What would you like to do? insert 6 right of 4
What would you like to do? insert 7 right of 1
What would you like to do? insert 8 right of 7
What would you like to do? border
Border of tree: 
1 2 3 5 6 8 7 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left_boundary(self):
        current = self
        while True:
            if current.left is not None:
                print(current.key, end=' ')
                current = current.left
            elif current.right is not None:
                print(current.key, end=' ')
                current = current.right
            else:
                break

    def print_right_boundary(self):
        if self.right is not None:
            self.right.print_right_boundary()
            print(self.key, end=' ')
        elif self.left is not None:
            self.left.print_right_boundary()
            print(self.key, end=' ')


    def print_leaves(self):
        if self.left is not None:
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
        if (self.left is None
            and self.right is None):
            print(self.key, end=' ')

    def print_border(self):
        print(self.key, end=' ')
        if self.left is not None:
            self.left.print_left_boundary()
            self.left.print_leaves()
        if self.right is not None:
            self.right.print_leaves()
            self.right.print_right_boundary()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('border')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'border':
        if btree is not None:
            print('Border of tree: ')
            btree.print_border()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOPN
Python Program to Count Number of Non Leaf Nodes of a given Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? count
Number of nonleaf nodes: 0
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? count
Number of nonleaf nodes: 1
What would you like to do? add 4 below 2
What would you like to do? count
Number of nonleaf nodes: 2
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 3
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
count
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 2
What would you like to do? add 4 below 3
What would you like to do? add 5 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 6 below 4
What would you like to do? count
Number of nonleaf nodes: 4
What would you like to do? add 7 below 6
What would you like to do? count
Number of nonleaf nodes: 5
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def count_nonleaf_nodes(self):
        nonleaf_count = 0
        if self.children != []:
            nonleaf_count = 1
        for child in self.children:
            nonleaf_count = nonleaf_count + child.count_nonleaf_nodes()
        return nonleaf_count


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('count')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'count':
        if tree is None:
            print('Tree is empty.')
        else:
            count = tree.count_nonleaf_nodes()
            print('Number of nonleaf nodes: {}'.format(count))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of all Nodes in a Tree
================================ EOPN
Python Program to Find the Sum of all Nodes in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? sum
Tree is empty.
What would you like to do? add 3 at root
What would you like to do? sum
Sum of all nodes: 3
What would you like to do? add 4 below 3
What would you like to do? sum
Sum of all nodes: 7
What would you like to do? add 5 below 3
What would you like to do? add 10 below 4
What would you like to do? sum
Sum of all nodes: 22
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
sum
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 1
What would you like to do? add 5 below 2
What would you like to do? add 6 below 3
What would you like to do? add 7 below 4
What would you like to do? sum
Sum of all nodes: 28
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def sum_nodes(self):
        summation = self.key
        for child in self.children:
            summation = summation + child.sum_nodes()
        return summation


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('sum')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'sum':
        if tree is None:
            print('Tree is empty.')
        else:
            summation = tree.sum_nodes()
            print('Sum of all nodes: {}'.format(summation))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOPN
Python Program to Construct a Tree & Perform Insertion, Deletion, Display
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? add 3 below 1
What would you like to do? add 4 below 2
What would you like to do? add 5 below 2
What would you like to do? display
BFS traversal display: 1 2 3 4 5 
What would you like to do? remove 1
What would you like to do? display
BFS traversal display: 4 2 3 5 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 4 2 3 
What would you like to do? remove 4
What would you like to do? display
BFS traversal display: 2 3 
What would you like to do? remove 3
What would you like to do? remove 2
What would you like to do? display
Tree is empty.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
remove <data>
display
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 9 below 7
What would you like to do? add 11 below 9
What would you like to do? add 12 below 7
What would you like to do? display
BFS traversal display: 5 7 9 12 11 
What would you like to do? remove 9
What would you like to do? display
BFS traversal display: 5 7 11 12 
What would you like to do? remove 12
What would you like to do? display
BFS traversal display: 5 7 11 
What would you like to do? remove 7
What would you like to do? display
BFS traversal display: 5 11 
What would you like to do? remove 5
What would you like to do? display
BFS traversal display: 11 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None, parent=None):
        self.key = data
        self.children = []
        self.parent = parent

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def remove(self):
        parent = self.parent
        index = parent.children.index(self)
        parent.children.remove(self)
        for child in reversed(self.children):
            parent.children.insert(index, child)
            child.parent = parent

    def bfs_display(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('remove <data>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            new_node.parent = ref_node
            ref_node.add(new_node)

    elif operation == 'remove':
        data = int(do[1])
        to_remove = tree.search(data)
        if tree == to_remove:
            if tree.children == []:
                tree = None
            else:
                leaf = tree.children[0]
                while leaf.children != []:
                    leaf = leaf.children[0]
                leaf.parent.children.remove(leaf)
                leaf.parent = None
                leaf.children = tree.children
                tree = leaf
        else:
            to_remove.remove()

    elif operation == 'display':
        if tree is not None:
            print('BFS traversal display: ', end='')
            tree.bfs_display()
            print()
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOPN
Python Program to Check whether a Tree is a Binary Search Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 1 at root
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 0 left of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 2 right of 1
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? insert 3 left of 2
What would you like to do? bst
Tree is not a binary search tree.
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
bst
quit
What would you like to do? insert 5 at root
What would you like to do? insert 1 left of 5
What would you like to do? insert 10 right of 5
What would you like to do? insert 0 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 15 right of 10
What would you like to do? bst
Tree is a binary search tree.
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def is_bst_p(self):
        if self.left is not None:
            if self.key < self.left.key:
                return False
            elif not self.left.is_bst_p():
                return False
        if self.right is not None:
            if self.key > self.right.key:
                return False
            elif not self.right.is_bst_p():
                return False
        return True


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('bst')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'bst':
        if btree is not None:
            if btree.is_bst_p():
                print('Tree is a binary search tree.')
            else:
                print('Tree is not a binary search tree.')
        else:
            print('Tree is empty.')

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOPN
Python Program to Print all the Paths from the Root to the Leaf in a Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? paths
Tree is empty.
What would you like to do? add 1 at root
What would you like to do? paths
1 
What would you like to do? add 2 below 1
What would you like to do? paths
1 2 
What would you like to do? add 3 below 1
What would you like to do? paths
1 2 
1 3 
What would you like to do? add 4 below 1
What would you like to do? paths
1 2 
1 3 
1 4 
What would you like to do? add 8 below 2
What would you like to do? paths
1 2 8 
1 3 
1 4 
What would you like to do? add 7 below 2
What would you like to do? paths
1 2 8 
1 2 7 
1 3 
1 4 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
paths
quit
What would you like to do? add 1 at root
What would you like to do? add 10 below 1
What would you like to do? add 11 below 10
What would you like to do? add 12 below 11
What would you like to do? add 20 below 1
What would you like to do? add 21 below 20
What would you like to do? add 30 below 1
What would you like to do? paths
1 10 11 12 
1 20 21 
1 30 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def print_all_paths_to_leaf(self):
        self.print_all_paths_to_leaf_helper([])

    def print_all_paths_to_leaf_helper(self, path_till_now):
        path_till_now.append(self.key)
        if self.children == []:
            for key in path_till_now:
                print(key, end=' ')
            print()
        else:
            for child in self.children:
                child.print_all_paths_to_leaf_helper(path_till_now[:])


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('paths')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'paths':
        if tree is None:
            print('Tree is empty.')
        else:
            tree.print_all_paths_to_leaf()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print only Nodes in Left SubTree
================================ EOPN
Python Program to Print only Nodes in Left SubTree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 1 at root
What would you like to do? insert 2 left of 1
What would you like to do? insert 3 right of 1
What would you like to do? insert 4 left of 2
What would you like to do? insert 5 right of 2
What would you like to do? insert 6 left of 3
What would you like to do? left
Nodes of left subtree: 4 2 5 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
left
quit
What would you like to do? insert 10 at root
What would you like to do? left
Nodes of left subtree: 
What would you like to do? insert 1 right of 10
What would you like to do? insert 2 left of 10
What would you like to do? insert 3 right of 2
What would you like to do? left
Nodes of left subtree: 2 3 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None

    def print_left(self):
        if self.left is not None:
            self.left.inorder()


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('left')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'left':
        print('Nodes of left subtree: ', end='')
        if btree is not None:
            btree.print_left()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOPN
Python Program to Display the Nodes of a Tree using BFS Traversal
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 1 at root
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 1 2 
What would you like to do? add 3 below 1
What would you like to do? add 10 below 2
What would you like to do? add 12 below 2
What would you like to do? add 14 below 3
What would you like to do? add 7 below 14
What would you like to do? bfs
BFS traversal: 1 2 3 10 12 14 7 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
add <data> at root
add <data> below <data>
bfs
quit
What would you like to do? add 5 at root
What would you like to do? add 7 below 5
What would you like to do? add 8 below 5
What would you like to do? add 4 below 7
What would you like to do? add 3 below 7
What would you like to do? add 1 below 8
What would you like to do? add 2 below 1
What would you like to do? bfs
BFS traversal: 5 7 8 4 3 1 2 
What would you like to do? quit
--------------------------------
class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []

    def set_root(self, data):
        self.key = data

    def add(self, node):
        self.children.append(node)

    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None

    def bfs(self):
        queue = [self]
        while queue != []:
            popped = queue.pop(0)
            for child in popped.children:
                queue.append(child)
            print(popped.key, end=' ')


tree = None

print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('bfs')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)

    elif operation == 'bfs':
        if tree is None:
            print('Tree is empty.')
        else:
            print('BFS traversal: ', end='')
            tree.bfs()
            print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOPN
Python Program to Find the Sum of All Nodes in a Binary Tree
================================ EOKW
--------------------------------
output:
Case 1:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 3 at root
inorder traversal of binary tree: 3 
What would you like to do? insert 7 left of 3
inorder traversal of binary tree: 7 3 
What would you like to do? sum
Sum of nodes in tree: 10
inorder traversal of binary tree: 7 3 
What would you like to do? quit

Case 2:
Menu (this assumes no duplicate keys)
insert <data> at root
insert <data> left of <data>
insert <data> right of <data>
sum
quit
inorder traversal of binary tree: 
What would you like to do? insert 2 at root
inorder traversal of binary tree: 2 
What would you like to do? insert 10 left of 2
inorder traversal of binary tree: 10 2 
What would you like to do? insert 1 right of 2
inorder traversal of binary tree: 10 2 1 
What would you like to do? insert 5 left of 1
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? sum
Sum of nodes in tree: 18
inorder traversal of binary tree: 10 2 5 1 
What would you like to do? quit
--------------------------------
class BinaryTree:
    def __init__(self, key=None):
        self.key = key
        self.left = None
        self.right = None

    def set_root(self, key):
        self.key = key

    def inorder(self):
        if self.left is not None:
            self.left.inorder()
        print(self.key, end=' ')
        if self.right is not None:
            self.right.inorder()

    def insert_left(self, new_node):
        self.left = new_node

    def insert_right(self, new_node):
        self.right = new_node

    def search(self, key):
        if self.key == key:
            return self
        if self.left is not None:
            temp =  self.left.search(key)
            if temp is not None:
                return temp
        if self.right is not None:
            temp =  self.right.search(key)
            return temp
        return None


def sum_nodes(node):
    if node is None:
        return 0
    return node.key + sum_nodes(node.left) + sum_nodes(node.right)


btree = None

print('Menu (this assumes no duplicate keys)')
print('insert <data> at root')
print('insert <data> left of <data>')
print('insert <data> right of <data>')
print('sum')
print('quit')

while True:
    print('inorder traversal of binary tree: ', end='')
    if btree is not None:
        btree.inorder()
    print()

    do = input('What would you like to do? ').split()

    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        new_node = BinaryTree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
                btree = new_node
        else:
            position = do[4].strip().lower()
            key = int(position)
            ref_node = None
            if btree is not None:
                ref_node = btree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            if suboperation == 'left':
                ref_node.insert_left(new_node)
            elif suboperation == 'right':
                ref_node.insert_right(new_node)

    elif operation == 'sum':
        print('Sum of nodes in tree: {}'.format(sum_nodes(btree)))

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Graph
================================ EOPN
Python Program to Implement Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? display
Vertices: 1 2 
Edges: 

What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 

What would you like to do? add edge 1 3
What would you like to do? add edge 3 1
What would you like to do? display
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=1) 
(src=1, dest=3, weight=1) 
(src=3, dest=1, weight=1) 

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> [weight]
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 4 5
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 

What would you like to do? add edge 5 4
What would you like to do? display
Vertices: 1 2 3 4 5 
Edges: 
(src=1, dest=2, weight=1) 
(src=2, dest=3, weight=1) 
(src=4, dest=5, weight=1) 
(src=5, dest=4, weight=1) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> [weight]')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    if len(do) == 5:
                        weight = int(do[4])
                        g.add_edge(src, dest, weight)
                    else:
                        g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Breadth-First Search on a Graph
================================ EOPN
Python Program to Implement Breadth-First Search on a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add vertex 9
What would you like to do? add vertex 10
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 1 5
What would you like to do? add edge 2 6
What would you like to do? add edge 3 7
What would you like to do? add edge 3 8
What would you like to do? add edge 4 8
What would you like to do? add edge 8 10
What would you like to do? add edge 5 10
What would you like to do? add edge 6 9
What would you like to do? add edge 9 10
What would you like to do? bfs 1
Breadth-first Traversal: 1 3 2 5 7 8 6 10 9 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
bfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bfs 1
Breadth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 
What would you like to do? bfs 2
Breadth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? bfs 2
Breadth-first Traversal: 2 1 
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? bfs 1
Breadth-first Traversal: 1 2 3 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def display_bfs(vertex):
    """Display BFS Traversal starting at vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        print(current.get_key(), end=' ')
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('bfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'bfs':
        key = int(do[1])
        print('Breadth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_bfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using BFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1, 4]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 5 4
What would you like to do? reachable 4
All nodes reachable from 4: [4]
What would you like to do? reachable 5
All nodes reachable from 5: [4, 5]
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2, 3]
What would you like to do? reachable 3
All nodes reachable from 3: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_all_reachable_nodes(vertex):
    """Return set containing all vertices reachable from vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)
    return visited


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using BFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 5 1
What would you like to do? add edge 4 2
What would you like to do? components
Component 1: [5, 2, 4, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add vertex 4
Vertex already exists.
What would you like to do? components
Component 1: [2, 3, 1]
Component 2: [4]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        component[current] = label
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            component_vertices = [v.get_key() for v in component
                                  if component[v] == label]
            print('Component {}:'.format(label), component_vertices)



    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOPN
Python Program to Find Shortest Path From a Vertex using BFS in an Unweighted Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
What would you like to do? add edge 1 3
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
Vertex 3 (distance 1): 3 1
Vertex 2 (distance 1): 2 1
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
shortest <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 1 (distance 0): 1
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? add edge 4 5
What would you like to do? add edge 4 6
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 3): 5 4 2 1
Vertex 6 (distance 3): 6 4 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? add edge 2 6
What would you like to do? add edge 1 5
What would you like to do? shortest 1
Path from destination vertices to source vertex 1:
Vertex 5 (distance 1): 5 1
Vertex 6 (distance 2): 6 2 1
Vertex 3 (distance 2): 3 2 1
Vertex 2 (distance 1): 2 1
Vertex 1 (distance 0): 1
Vertex 4 (distance 2): 4 2 1
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        # dictionary containing destination vertices mapped to the weight of the
        # edge with which they are joined to this vertex
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def find_shortest_paths(src):
    """Returns tuple of two dictionaries: (parent, distance)

    parent contains vertices mapped to their parent vertex in the shortest
    path from src to that vertex.
    distance contains vertices mapped to their shortest distance from src.
    """
    parent = {src: None}
    distance = {src: 0}

    visited = set()
    q = Queue()
    q.enqueue(src)
    visited.add(src)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                distance[dest] = distance[current] + 1
                q.enqueue(dest)
    return (parent, distance)

g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('shortest <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        src = g.get_vertex(key)
        parent, distance = find_shortest_paths(src)

        print('Path from destination vertices to source vertex {}:'.format(key))
        for v in parent:
            print('Vertex {} (distance {}): '.format(v.get_key(), distance[v]),
                  end='')
            while parent[v] is not None:
                print(v.get_key(), end = ' ')
                v = parent[v]
            print(src.get_key()) # print source vertex

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 2 4
What would you like to do? add edge 2 5
What would you like to do? add edge 6 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 6 2
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_cycle_present(vertex, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {vertex: None}
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                parent[dest] = current
                q.enqueue(dest)
            else:
                if parent[current] is not dest:
                    return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using BFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 5 6
What would you like to do? add edge 6 7
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 7 1
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, data):
        self.items.append(data)

    def dequeue(self):
        return self.items.pop(0)


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    visited.add(vertex)
    q = Queue()
    q.enqueue(vertex)
    while not q.is_empty():
        current = q.dequeue()

        next_colour = 1 - colour[current] # switch colour
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                colour[dest] = next_colour
                q.enqueue(dest)
            else:
                if colour[dest] != next_colour:
                    return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph using Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 3 5
What would you like to do? add edge 1 6
What would you like to do? add edge 6 2
What would you like to do? dfs 1
Depth-first Traversal: 1 6 2 3 4 5 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 1 2 
What would you like to do? dfs 2
Depth-first Traversal: 2 
What would you like to do? add edge 2 1
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 2 3
What would you like to do? add edge 2 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? dfs 2
Depth-first Traversal: 2 3 4 1 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def display_dfs(v):
    """Display DFS traversal starting at vertex v."""
    display_dfs_helper(v, set())


def display_dfs_helper(v, visited):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes."""
    visited.add(v)
    print(v.get_key(), end=' ')
    for dest in v.get_neighbours():
        if dest not in visited:
            display_dfs_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOPN
Python Program to Implement Depth-First Search on a Graph without Recursion
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? add edge 3 7
What would you like to do? dfs 1
Depth-first Traversal: 1 5 6 2 3 7 4 
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? dfs 1
Depth-first Traversal: 1 
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 
What would you like to do? add vertex 4
What would you like to do? add edge 3 4
What would you like to do? dfs 1
Depth-first Traversal: 1 2 3 4 
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push(self, data):
        self.items.append(data)

    def pop(self):
        return self.items.pop()


def display_dfs(v):
    visited = set()
    s = Stack()
    s.push(vertex)
    while not s.is_empty():
        current = s.pop()
        if current in visited:
            continue
        print(current.get_key(), end=' ')
        visited.add(current)
        for dest in current.get_neighbours():
            if dest not in visited:
                s.push(dest)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ', end='')
        vertex = g.get_vertex(key)
        display_dfs(vertex)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print DFS Numbering of a Graph
================================ EOPN
Python Program to Print DFS Numbering of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add edge 1 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 6
What would you like to do? add edge 5 6
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Visiting 3... discovered time = 3
Visiting 4... discovered time = 4
Leaving 4... finished time = 5
Leaving 3... finished time = 6
Leaving 2... finished time = 7
Visiting 5... discovered time = 8
Visiting 6... discovered time = 9
Leaving 6... finished time = 10
Leaving 5... finished time = 11
Leaving 1... finished time = 12

What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
dfs <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Leaving 1... finished time = 2

What would you like to do? add vertex 2
What would you like to do? add edge 1 2
What would you like to do? dfs 1
Depth-first Traversal: 
Visiting 1... discovered time = 1
Visiting 2... discovered time = 2
Leaving 2... finished time = 3
Leaving 1... finished time = 4

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to

def dfs(v, pre, post):
    """Display DFS traversal starting at vertex v. Stores pre and post times in
    dictionaries pre and post."""
    dfs_helper(v, set(), pre, post, [0])

def dfs_helper(v, visited, pre, post, time):
    """Display DFS traversal starting at vertex v. Uses set visited to keep
    track of already visited nodes, dictionaries pre and post to store
    discovered and finished times and the one-element list time to keep track of
    current time."""
    visited.add(v)
    time[0] = time[0] + 1
    pre[v] = time[0]
    print('Visiting {}... discovered time = {}'.format(v.get_key(), time[0]))
    for dest in v.get_neighbours():
        if dest not in visited:
            dfs_helper(dest, visited, pre, post, time)
    time[0] = time[0] + 1
    post[v] = time[0]
    print('Leaving {}... finished time = {}'.format(v.get_key(), time[0]))


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('dfs <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'dfs':
        key = int(do[1])
        print('Depth-first Traversal: ')
        vertex = g.get_vertex(key)
        pre = dict()
        post = dict()
        dfs(vertex, pre, post)
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOPN
Python Program to Find All Nodes Reachable from a Node using DFS in a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2
What would you like to do? add edge 1 3
What would you like to do? add edge 4 5
What would you like to do? add edge 5 6
What would you like to do? reachable 1
All nodes reachable from 1: [2, 3, 1]
What would you like to do? reachable 4
All nodes reachable from 4: [6, 4, 5]
What would you like to do? reachable 7
All nodes reachable from 7: [7]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
reachable <vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? reachable 1
All nodes reachable from 1: [1]
What would you like to do? add edge 1 2
What would you like to do? reachable 1
All nodes reachable from 1: [2, 1]
What would you like to do? reachable 2
All nodes reachable from 2: [2]
What would you like to do? add edge 2 1
What would you like to do? reachable 2
All nodes reachable from 2: [2, 1]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def find_all_reachable_nodes(v):
    """Return set containing all vertices reachable from vertex."""
    reachable = set()
    find_all_reachable_nodes_helper(v, reachable)
    return reachable


def find_all_reachable_nodes_helper(v, visited):
    """Add all vertices visited by DFS traversal starting at v to the set visited."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            find_all_reachable_nodes_helper(dest, visited)


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOPN
Python Program to Find All Connected Components using DFS in an Undirected Graph
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? components
Component 1: [1]
Component 2: [2]
Component 3: [3]
Component 4: [4]
Component 5: [5]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [2, 1]
Component 2: [3]
Component 3: [4]
Component 4: [5]
What would you like to do? add edge 3 4
What would you like to do? components
Component 1: [2, 1]
Component 2: [4, 3]
Component 3: [5]
What would you like to do? add edge 1 5
What would you like to do? components
Component 1: [2, 5, 1]
Component 2: [4, 3]
What would you like to do? add edge 2 4
What would you like to do? components
Component 1: [4, 2, 5, 1, 3]
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest>
components
display
quit
What would you like to do? components
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? components
Component 1: [1]
Component 2: [2]
What would you like to do? add edge 1 2
What would you like to do? components
Component 1: [1, 2]
What would you like to do? add vertex 3
What would you like to do? components
Component 1: [1, 2]
Component 2: [3]
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def label_all_reachable(vertex, component, label):
    """Set component[v] = label for all v in the component containing vertex."""
    label_all_reachable_helper(vertex, set(), component, label)


def label_all_reachable_helper(vertex, visited, component, label):
    """Set component[v] = label for all v in the component containing
    vertex. Uses set visited to keep track of nodes alread visited."""
    visited.add(vertex)
    component[vertex] = label
    for dest in vertex.get_neighbours():
        if dest not in visited:
            label_all_reachable_helper(dest, visited, component, label)


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('components')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_undirected_edge_exist(src, dest):
                    g.add_undirected_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'components':
        component = dict.fromkeys(g, None)
        label = 1
        for v in g:
            if component[v] is None:
                label_all_reachable(v, component, label)
                label += 1

        max_label = label
        for label in range(1, max_label):
            print('Component {}:'.format(label),
                  [v.get_key() for v in component if component[v] == label])


    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOPN
Python Program to Find if Undirected Graph is Bipartite using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 3 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 1 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 2 4
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
bipartite
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 5 1
What would you like to do? add edge 6 4
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 5
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 2
What would you like to do? bipartite
Graph is bipartite.
What would you like to do? add edge 6 1
What would you like to do? bipartite
Graph is not bipartite.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_bipartite(vertex, visited):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited."""
    colour = {vertex: 0}
    return is_bipartite_helper(vertex, visited, colour)


def is_bipartite_helper(v, visited, colour):
    """Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited. Uses dictionary colour to keep
    track of colour of each vertex."""
    visited.add(v)
    next_colour = 1 - colour[v] # switch colour
    for dest in v.get_neighbours():
        if dest not in visited:
            colour[dest] = next_colour
            if not is_bipartite_helper(dest, visited, colour):
                return False
        else:
            if colour[dest] != next_colour:
                return False
    return True


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break

        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Undirected Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? add edge 3 4
What would you like to do? add vertex 5
What would you like to do? add edge 4 5
What would you like to do? add edge 5 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight."""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)

    def does_undirected_edge_exist(self, v1_key, v2_key):
        """Return True if there is an undirected edge between v1_key and v2_key."""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(v, visited):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited."""
    parent = {v: None}
    return is_cycle_present_helper(v, visited, parent)


def is_cycle_present_helper(v, visited, parent):
    """Return True if cycle is present in component containing vertex and put
    all vertices in component in set visited. Uses dictionary parent to keep
    track of parents of nodes in the DFS tree."""
    visited.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            parent[dest] = v
            if is_cycle_present_helper(dest, visited, parent):
                return True
        else:
            if parent[v] is not dest:
                return True
    return False


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        present = False
        visited = set()
        for v in g:
            if v not in visited:
                if is_cycle_present(v, visited):
                    present = True
                    break

        if present:
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOPN
Python Program to Find if Directed Graph contains Cycle using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 1 3
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 5
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 3 4
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 4 1
What would you like to do? cycle
Cycle present.
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <vertex1> <vertex2>
cycle
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 3 2
What would you like to do? cycle
Cycle not present.
What would you like to do? add edge 2 3
What would you like to do? cycle
Cycle present.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def is_cycle_present(graph):
    """Return True if cycle is present in the graph."""
    on_stack = set()
    visited = set()
    for v in graph:
        if v not in visited:
            if is_cycle_present_helper(v, visited, on_stack):
                return True
    return False


def is_cycle_present_helper(v, visited, on_stack):
    """Return True if the DFS traversal starting at vertex v detects a
    cycle. Uses set visited to keep track of nodes that have been visited. Uses
    set on_stack to keep track of nodes that are 'on the stack' of the recursive
    calls."""
    if v in on_stack:
        return True
    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if is_cycle_present_helper(dest, visited, on_stack):
                return True
    on_stack.remove(v)
    visited.add(v)
    return False


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_edge_exist(v1, v2):
                    g.add_edge(v1, v2)
                else:
                    print('Edge already exists.')

    elif operation == 'cycle':
        if is_cycle_present(g):
            print('Cycle present.')
        else:
            print('Cycle not present.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOPN
Python Program to Print a Topological Sorting of a Directed Acyclic Graph using DFS
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? topological
Topological Sorting: [3, 2, 1]
What would you like to do? add edge 1 2
What would you like to do? topological
Topological Sorting: [3, 1, 2]
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 4 5
What would you like to do? topological
Topological Sorting: [7, 6, 4, 5, 1, 2, 3]
What would you like to do? add edge 4 6
What would you like to do? topological
Topological Sorting: [7, 4, 5, 6, 1, 2, 3]
What would you like to do? add edge 5 7
What would you like to do? topological
Topological Sorting: [4, 5, 7, 6, 1, 2, 3]
What would you like to do? add edge 3 4
What would you like to do? topological
Topological Sorting: [1, 2, 3, 4, 5, 7, 6]
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
topological
display
quit
What would you like to do? add vertex 1
What would you like to do? topological
Topological Sorting: [1]
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2
What would you like to do? add edge 2 3
What would you like to do? topological
Topological Sorting: [1, 2, 3]
What would you like to do? add edge 3 2
What would you like to do? topological
Graph is not a DAG.
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def get_topological_sorting(graph):
    """Return a topological sorting of the DAG. Return None if graph is not a DAG."""
    tlist = []
    visited = set()
    on_stack = set()
    for v in graph:
        if v not in visited:
            if not get_topological_sorting_helper(v, visited, on_stack, tlist):
                return None
    return tlist


def get_topological_sorting_helper(v, visited, on_stack, tlist):
    """Perform DFS traversal starting at vertex v and store a topological
    sorting of the DAG in tlist. Return False if it is found that the graph is
    not a DAG. Uses set visited to keep track of already visited nodes."""
    if v in on_stack:
        # graph has cycles and is therefore not a DAG.
        return False

    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if not get_topological_sorting_helper(dest, visited, on_stack, tlist):
                return False
    on_stack.remove(v)
    visited.add(v)
    tlist.insert(0, v.get_key()) # prepend node key to tlist
    return True


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('topological')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'topological':
        tlist = get_topological_sorting(g)
        if tlist is not None:
            print('Topological Sorting: ', end='')
            print(tlist)
        else:
            print('Graph is not a DAG.')

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOPN
Python Program to Implement Dijkstras Shortest Path Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 80
What would you like to do? add edge 3 4 70
What would you like to do? add edge 2 5 20
What would you like to do? add edge 2 3 6
What would you like to do? add edge 5 6 50
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? shortest 1
Distances from 1: 
Distance to 6: 45
Distance to 3: 16
Distance to 4: 86
Distance to 5: 30
Distance to 2: 10
Distance to 7: 40
Distance to 1: 0

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
shortest <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 20
What would you like to do? add edge 3 4 30
What would you like to do? add edge 1 4 100
What would you like to do? shortest 1
Distances from 1: 
Distance to 2: 10
Distance to 4: 60
Distance to 3: 30
Distance to 1: 0
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('shortest <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'shortest':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = dijkstra(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Bellman-Ford Algorithm
================================ EOPN
Python Program to Implement Bellman-Ford Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add vertex 8
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 8 8
What would you like to do? add edge 2 6 2
What would you like to do? add edge 3 2 1
What would you like to do? add edge 3 4 1
What would you like to do? add edge 4 5 3
What would you like to do? add edge 5 6 -1
What would you like to do? add edge 6 3 -2
What would you like to do? add edge 7 2 -4
What would you like to do? add edge 7 6 -1
What would you like to do? add edge 8 7 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 5: 9
Distance to 6: 7
Distance to 7: 9
Distance to 2: 5
Distance to 1: 0
Distance to 8: 8
Distance to 3: 5
Distance to 4: 6

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
bellman-ford <source vertex key>
display
quit
What would you like to do? add vertex 1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0

What would you like to do? add vertex 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 2: inf

What would you like to do? add edge 1 2 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 3 -1
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 2

What would you like to do? add edge 3 2 2
What would you like to do? bellman-ford 1
Distances from 1: 
Distance to 1: 0
Distance to 3: -1
Distance to 2: 1

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('bellman-ford <source vertex key>')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'bellman-ford':
        key = int(do[1])
        source = g.get_vertex(key)
        distance = bellman_ford(g, source)
        print('Distances from {}: '.format(key))
        for v in distance:
            print('Distance to {}: {}'.format(v.get_key(), distance[v]))
        print()

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Floyd-Warshall Algorithm
================================ EOPN
Python Program to Implement Floyd-Warshall Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 1 3 8
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 5 -> 4 -> 3 -> 2 (distance 1)
From 1 to 3: 1 -> 5 -> 4 -> 3 (distance -3)
From 1 to 4: 1 -> 5 -> 4 (distance 2)
From 1 to 5: 1 -> 5 (distance -4)
From 2 to 1: 2 -> 4 -> 1 (distance 3)
From 2 to 3: 2 -> 4 -> 3 (distance -4)
From 2 to 4: 2 -> 4 (distance 1)
From 2 to 5: 2 -> 4 -> 1 -> 5 (distance -1)
From 3 to 1: 3 -> 2 -> 4 -> 1 (distance 7)
From 3 to 2: 3 -> 2 (distance 4)
From 3 to 4: 3 -> 2 -> 4 (distance 5)
From 3 to 5: 3 -> 2 -> 4 -> 1 -> 5 (distance 3)
From 4 to 1: 4 -> 1 (distance 2)
From 4 to 2: 4 -> 3 -> 2 (distance -1)
From 4 to 3: 4 -> 3 (distance -5)
From 4 to 5: 4 -> 1 -> 5 (distance -2)
From 5 to 1: 5 -> 4 -> 1 (distance 8)
From 5 to 2: 5 -> 4 -> 3 -> 2 (distance 5)
From 5 to 3: 5 -> 4 -> 3 (distance 1)
From 5 to 4: 5 -> 4 (distance 6)
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest> <weight>
floyd-warshall
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 -7
What would you like to do? add edge 1 3 5
What would you like to do? floyd-warshall
Shortest distances:
From 1 to 2: 1 -> 2 (distance 10)
From 1 to 3: 1 -> 2 -> 3 (distance 3)
From 2 to 3: 2 -> 3 (distance -7)
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def floyd_warshall(g):
    """Return dictionaries distance and next_v.

    distance[u][v] is the shortest distance from vertex u to v.
    next_v[u][v] is the next vertex after vertex v in the shortest path from u
    to v. It is None if there is no path between them. next_v[u][u] should be
    None for all u.

    g is a Graph object which can have negative edge weights.
    """
    distance = {v:dict.fromkeys(g, float('inf')) for v in g}
    next_v = {v:dict.fromkeys(g, None) for v in g}

    for v in g:
        for n in v.get_neighbours():
            distance[v][n] = v.get_weight(n)
            next_v[v][n] = n

    for v in g:
         distance[v][v] = 0
         next_v[v][v] = None

    for p in g: 
        for v in g:
            for w in g:
                if distance[v][w] > distance[v][p] + distance[p][w]:
                    distance[v][w] = distance[v][p] + distance[p][w]
                    next_v[v][w] = next_v[v][p]

    return distance, next_v


def print_path(next_v, u, v):
    """Print shortest path from vertex u to v.

    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u
    in the shortest path from u to v. It is None if there is no path between
    them. next_v[u][u] should be None for all u.

    u and v are Vertex objects.
    """
    p = u
    while (next_v[p][v]):
        print('{} -> '.format(p.get_key()), end='')
        p = next_v[p][v]
    print('{} '.format(v.get_key()), end='')


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('floyd-warshall')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'floyd-warshall':
        distance, next_v = floyd_warshall(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                if next_v[start][end]:
                    print('From {} to {}: '.format(start.get_key(),
                                                    end.get_key()),
                            end = '')
                    print_path(next_v, start, end)
                    print('(distance {})'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Transitive Closure of a Graph
================================ EOPN
Python Program to Find Transitive Closure of a Graph
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
transitive-closure
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
2, 2
What would you like to do? add edge 1 2 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
2, 2
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 1
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
1, 1
1, 2
1, 3
2, 2
2, 3
3, 3
What would you like to do? quit

Case 2:
Menu
add vertex <key>
add edge <src> <dest>
transitive-closure
display
quit
What would you like to do? add vertex 0
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 0 1
What would you like to do? add edge 0 2
What would you like to do? add edge 1 2
What would you like to do? add edge 2 0
What would you like to do? add edge 2 3
What would you like to do? transitive-closure
All pairs (u, v) such that there is a path from u to v: 
0, 0
0, 1
0, 2
0, 3
1, 0
1, 1
1, 2
1, 3
2, 0
2, 1
2, 2
2, 3
3, 3
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def transitive_closure(g):
    """Return dictionary reachable.

    reachable[u][v] = True iff there is a path from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    reachable = {v:dict.fromkeys(g, False) for v in g}

    for v in g:
        for n in v.get_neighbours():
            reachable[v][n] = True

    for v in g:
         reachable[v][v] = True

    for p in g: 
        for v in g:
            for w in g:
                if reachable[v][p] and reachable[p][w]:
                    reachable[v][w] = True

    return reachable


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('transitive-closure')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')

    elif operation == 'transitive-closure':
        reachable = transitive_closure(g)
        print('All pairs (u, v) such that there is a path from u to v: ')
        for start in g:
            for end in g:
                if reachable[start][end]:
                    print('{}, {}'.format(start.get_key(), end.get_key()))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Prims Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add vertex 7
What would you like to do? add edge 1 3 18
What would you like to do? add edge 1 2 10
What would you like to do? add edge 3 4 70
What would you like to do? add edge 3 2 6
What would you like to do? add edge 2 5 20
What would you like to do? add edge 5 6 10
What would you like to do? add edge 5 7 10
What would you like to do? add edge 6 7 5
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 7 
Edges: 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=2, dest=3, weight=6) 
(src=3, dest=2, weight=6) 
(src=3, dest=4, weight=70) 
(src=4, dest=3, weight=70) 
(src=5, dest=6, weight=10) 
(src=5, dest=2, weight=20) 
(src=6, dest=5, weight=10) 
(src=6, dest=7, weight=5) 
(src=7, dest=6, weight=5) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 2 3 100
What would you like to do? add edge 1 3 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=2, weight=10) 
(src=1, dest=3, weight=50) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=50) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_prim(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    # if graph is empty
    if not g:
        return mst

    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    nearest_neighbour = {}
    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST
    # (v is a vertex outside the MST and has at least one neighbour in the MST)
    smallest_distance = {}
    # v is in unvisited iff v has not been added to the MST
    unvisited = set(g)

    u = next(iter(g)) # select any one vertex from g
    mst.add_vertex(u.get_key()) # add a copy of it to the MST
    unvisited.remove(u)

    # for each neighbour of vertex u
    for n in u.get_neighbours():
        if n is u:
            # avoid self-loops
            continue
        # update dictionaries
        nearest_neighbour[n] = mst.get_vertex(u.get_key())
        smallest_distance[n] = u.get_weight(n)

    # loop until smallest_distance becomes empty
    while (smallest_distance):
        # get nearest vertex outside the MST
        outside_mst = min(smallest_distance, key=smallest_distance.get)
        # get the nearest neighbour inside the MST
        inside_mst = nearest_neighbour[outside_mst]

        # add a copy of the outside vertex to the MST
        mst.add_vertex(outside_mst.get_key())
        # add the edge to the MST
        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),
                     smallest_distance[outside_mst])
        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),
                     smallest_distance[outside_mst])

        # now that outside_mst has been added to the MST, remove it from our
        # dictionaries and the set unvisited
        unvisited.remove(outside_mst)
        del smallest_distance[outside_mst]
        del nearest_neighbour[outside_mst]

        # update dictionaries
        for n in outside_mst.get_neighbours():
            if n in unvisited:
                if n not in smallest_distance:
                    smallest_distance[n] = outside_mst.get_weight(n)
                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())
                else:
                    if smallest_distance[n] > outside_mst.get_weight(n):
                        smallest_distance[n] = outside_mst.get_weight(n)
                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_prim(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOPN
Python Program to Find Minimum Spanning Tree using Krusals Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add vertex 6
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 5 30
What would you like to do? add edge 1 4 40
What would you like to do? add edge 2 5 20
What would you like to do? add edge 4 5 40
What would you like to do? add edge 5 3 40
What would you like to do? add edge 5 6 70
What would you like to do? add edge 3 6 50
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 4 5 6 
Edges: 
(src=1, dest=4, weight=40) 
(src=1, dest=2, weight=10) 
(src=2, dest=5, weight=20) 
(src=2, dest=1, weight=10) 
(src=3, dest=5, weight=40) 
(src=3, dest=6, weight=50) 
(src=4, dest=1, weight=40) 
(src=5, dest=2, weight=20) 
(src=5, dest=3, weight=40) 
(src=6, dest=3, weight=50) 

What would you like to do? quit

Case 2:
Undirected Graph
Menu
add vertex <key>
add edge <src> <dest> <weight>
mst
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add edge 1 2 10
What would you like to do? add edge 1 3 20
What would you like to do? add edge 2 3 30
What would you like to do? mst
Minimum Spanning Tree:
Vertices: 1 2 3 
Edges: 
(src=1, dest=3, weight=20) 
(src=1, dest=2, weight=10) 
(src=2, dest=1, weight=10) 
(src=3, dest=1, weight=20) 

What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_vertex_exist(self, key):
        return key in self.vertices

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def display(self):
        print('Vertices: ', end='')
        for v in self:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in self:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def mst_krusal(g):
    """Return a minimum cost spanning tree of the connected graph g."""
    mst = Graph() # create new Graph object to hold the MST

    if len(g) == 1:
        u = next(iter(g)) # get the single vertex
        mst.add_vertex(u.get_key()) # add a copy of it to mst
        return mst

    # get all the edges in a list
    edges = []
    for v in g:
        for n in v.get_neighbours():
            # avoid adding two edges for each edge of the undirected graph
            if v.get_key() < n.get_key():
                edges.append((v, n))

    # sort edges
    edges.sort(key=lambda edge: edge[0].get_weight(edge[1]))

    # initially, each vertex is in its own component
    component = {}
    for i, v in enumerate(g):
        component[v] = i

    # next edge to try
    edge_index = 0

    # loop until mst has the same number of vertices as g
    while len(mst) < len(g):
        u, v = edges[edge_index]
        edge_index += 1

        # if adding edge (u, v) will not form a cycle
        if component[u] != component[v]:

            # add to mst
            if not mst.does_vertex_exist(u.get_key()):
                mst.add_vertex(u.get_key())
            if not mst.does_vertex_exist(v.get_key()):
                mst.add_vertex(v.get_key())
            mst.add_edge(u.get_key(), v.get_key(), u.get_weight(v))
            mst.add_edge(v.get_key(), u.get_key(), u.get_weight(v))

            # merge components of u and v
            for w in g:
                if component[w] == component[v]:
                    component[w] = component[u]

    return mst


g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('mst')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                    g.add_edge(dest, src, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'mst':
        mst = mst_krusal(g)
        print('Minimum Spanning Tree:')
        mst.display()
        print()

    elif operation == 'display':
        g.display()
        print()

    elif operation == 'quit':
        break
 ETP  
 
Python Program to Implement Johnsons Algorithm
================================ EOPN
Python Program to Implement Johnsons Algorithm
================================ EOKW
--------------------------------
output:
Case 1:
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? add vertex 3
What would you like to do? add vertex 4
What would you like to do? add vertex 5
What would you like to do? add edge 1 2 3
What would you like to do? add edge 1 3 8
What would you like to do? add edge 1 5 -4
What would you like to do? add edge 2 5 7
What would you like to do? add edge 2 4 1
What would you like to do? add edge 3 2 4
What would you like to do? add edge 4 3 -5
What would you like to do? add edge 4 1 2
What would you like to do? add edge 5 4 6
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 1
1 to 3 distance -3
1 to 4 distance 2
1 to 5 distance -4
2 to 1 distance 3
2 to 2 distance 0
2 to 3 distance -4
2 to 4 distance 1
2 to 5 distance -1
3 to 1 distance 7
3 to 2 distance 4
3 to 3 distance 0
3 to 4 distance 5
3 to 5 distance 3
4 to 1 distance 2
4 to 2 distance -1
4 to 3 distance -5
4 to 4 distance 0
4 to 5 distance -2
5 to 1 distance 8
5 to 2 distance 5
5 to 3 distance 1
5 to 4 distance 6
5 to 5 distance 0
What would you like to do? quit

Case 2:
python 226__graph_johnson.py
Menu
add vertex <key>
add edge <src> <dest> <weight>
johnson
display
quit
What would you like to do? add vertex 1
What would you like to do? add vertex 2
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance inf
2 to 1 distance inf
2 to 2 distance 0
What would you like to do? add edge 1 2 100
What would you like to do? add vertex 3
What would you like to do? add edge 2 3 -50
What would you like to do? add edge 1 3 60
What would you like to do? johnson
Shortest distances:
1 to 1 distance 0
1 to 2 distance 100
1 to 3 distance 50
2 to 1 distance inf
2 to 2 distance 0
2 to 3 distance -50
3 to 1 distance inf
3 to 2 distance inf
3 to 3 distance 0
What would you like to do? quit
--------------------------------
class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}

    def add_vertex(self, key):
        """Add a vertex with the given key to the graph."""
        vertex = Vertex(key)
        self.vertices[key] = vertex

    def get_vertex(self, key):
        """Return vertex object with the corresponding key."""
        return self.vertices[key]

    def __contains__(self, key):
        return key in self.vertices

    def add_edge(self, src_key, dest_key, weight=1):
        """Add edge from src_key to dest_key with given weight."""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)

    def does_edge_exist(self, src_key, dest_key):
        """Return True if there is an edge from src_key to dest_key."""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        return iter(self.vertices.values())


class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}

    def get_key(self):
        """Return key corresponding to this vertex object."""
        return self.key

    def add_neighbour(self, dest, weight):
        """Make this vertex point to dest with given edge weight."""
        self.points_to[dest] = weight

    def get_neighbours(self):
        """Return all vertices pointed to by this vertex."""
        return self.points_to.keys()

    def get_weight(self, dest):
        """Get weight of edge from this vertex to dest."""
        return self.points_to[dest]

    def set_weight(self, dest, weight):
        """Set weight of edge from this vertex to dest."""
        self.points_to[dest] = weight

    def does_it_point_to(self, dest):
        """Return True if this vertex points to dest."""
        return dest in self.points_to


def johnson(g):
    """Return distance where distance[u][v] is the min distance from u to v.

    distance[u][v] is the shortest distance from vertex u to v.

    g is a Graph object which can have negative edge weights.
    """
    # add new vertex q
    g.add_vertex('q')
    # let q point to all other vertices in g with zero-weight edges
    for v in g:
        g.add_edge('q', v.get_key(), 0)

    # compute shortest distance from vertex q to all other vertices
    bell_dist = bellman_ford(g, g.get_vertex('q'))

    # set weight(u, v) = weight(u, v) + bell_dist(u) - bell_dist(v) for each
    # edge (u, v)
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[v] - bell_dist[n])

    # remove vertex q
    # This implementation of the graph stores edge (u, v) in Vertex object u
    # Since no other vertex points back to q, we do not need to worry about
    # removing edges pointing to q from other vertices.
    del g.vertices['q']

    # distance[u][v] will hold smallest distance from vertex u to v
    distance = {}
    # run dijkstra's algorithm on each source vertex
    for v in g:
        distance[v] = dijkstra(g, v)

    # correct distances
    for v in g:
        for w in g:
            distance[v][w] += bell_dist[w] - bell_dist[v]

    # correct weights in original graph
    for v in g:
        for n in v.get_neighbours():
            w = v.get_weight(n)
            v.set_weight(n, w + bell_dist[n] - bell_dist[v])

    return distance


def bellman_ford(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object which can have negative edge weights.
    source is a Vertex object in g.
    """
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    for _ in range(len(g) - 1):
        for v in g:
            for n in v.get_neighbours():
                distance[n] = min(distance[n], distance[v] + v.get_weight(n))

    return distance


def dijkstra(g, source):
    """Return distance where distance[v] is min distance from source to v.

    This will return a dictionary distance.

    g is a Graph object.
    source is a Vertex object in g.
    """
    unvisited = set(g)
    distance = dict.fromkeys(g, float('inf'))
    distance[source] = 0

    while unvisited != set():
        # find vertex with minimum distance
        closest = min(unvisited, key=lambda v: distance[v])

        # mark as visited
        unvisited.remove(closest)

        # update distances
        for neighbour in closest.get_neighbours():
           if neighbour in unvisited:
               new_distance = distance[closest] + closest.get_weight(neighbour)
               if distance[neighbour] > new_distance:
                   distance[neighbour] = new_distance

    return distance


g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> <weight>')
print('johnson')
print('display')
print('quit')

while True:
    do = input('What would you like to do? ').split()

    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            weight = int(do[4])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest, weight)
                else:
                    print('Edge already exists.')

    elif operation == 'johnson':
        distance = johnson(g)
        print('Shortest distances:')
        for start in g:
            for end in g:
                print('{} to {}'.format(start.get_key(), end.get_key()), end=' ')
                print('distance {}'.format(distance[start][end]))

    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()

        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()

    elif operation == 'quit':
        break
 ETP  
 
